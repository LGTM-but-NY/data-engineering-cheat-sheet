\documentclass[landscape]{article}
\sloppy
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{graphicx}
\usepackage{hyperref}
\usepackage{geometry}
\usepackage{ulem}
\usepackage{multicol} % for multi-column layout
\usepackage{xcolor}
\usepackage{booktabs}
\usepackage{array}
\usepackage[inline]{enumitem} % to tighten list spacing
\usepackage{fancyhdr} % for header and footer customization

% --- VIETNAMESE SUPPORT PACKAGES ---
\usepackage[utf8]{inputenc}
\usepackage[T5]{fontenc}
\usepackage[vietnamese]{babel}
% -----------------------------------

% Tight margins for cheat sheet in landscape (A4 297mm x 210mm)
\geometry{a4paper, landscape, left=8mm, right=8mm, top=6mm, bottom=13mm}

\fancyfoot[C]{\footnotesize\thepage}

\title{Tổng hợp Kiến thức Môn Kỹ thuật Dữ liệu (Data Engineering)}
\author{Học viên Cao học KHMT Bách Khoa TP.HCM (HCMUT)}
\date{\today}

\begin{document}

\thispagestyle{fancy} % Apply fancy style to title page
\maketitle
\footnotesize % smaller font for dense content
% Zero / minimal spacing in itemize and enumerate lists
\setlist{itemsep=0pt,topsep=2pt,parsep=0pt,partopsep=0pt}
\begin{multicols}{3}
    \setlength{\columnsep}{8pt} % space between columns
    \setlength{\multicolsep}{2pt} % vertical space before/after multicols
    \raggedcolumns

    \section{Nguyên lý Phân tích \& Thiết kế CSDL}

    \subsection{Tổng quan Các giai đoạn Thiết kế}
    \begin{enumerate}[leftmargin=*,itemsep=2pt]
        \item \textbf{Mức Quan niệm (Conceptual):} \textit{Mục tiêu} — nắm bắt yêu cầu và ngữ nghĩa (độc lập với cài đặt); \textit{Mô hình/Công cụ} — ER/EER; \textit{Đầu ra} — lược đồ quan niệm (thực thể, thuộc tính, mối kết hợp, ràng buộc).
        \item \textbf{Mức Logic:} \textit{Mục tiêu} — ánh xạ từ mức quan niệm sang mô hình DBMS đích (ví dụ: quan hệ); \textit{Mô hình/Công cụ} — ánh xạ ER-sang-quan hệ, chuẩn hóa (FDs); \textit{Đầu ra} — lược đồ quan hệ (bảng, khóa, ràng buộc toàn vẹn).
        \item \textbf{Mức Vật lý:} \textit{Mục tiêu} — xác định cấu trúc lưu trữ và đường dẫn truy xuất để tối ưu hiệu năng; \textit{Mô hình/Công cụ} — phân tích tải, chỉ mục, tổ chức tập tin, băm; \textit{Đầu ra} — lược đồ trong (cấu trúc lưu trữ, chỉ mục, đường dẫn truy xuất).
    \end{enumerate}

    \subsection{Nguyên lý Thiết kế Mức Quan niệm}
    \begin{itemize}[leftmargin=*, label={--}]
        \item \textbf{Phân tích Yêu cầu:} Làm việc với người dùng/chuyên gia nghiệp vụ để nắm bắt yêu cầu dữ liệu và yêu cầu chức năng (thao tác/giao dịch).
        \item \textbf{Thành phần ER:} \textbf{Thực thể} (vd: NhanVien), \textbf{Thuộc tính} (đơn/phức hợp/đa trị/dẫn xuất), \textbf{Mối kết hợp} (sự liên kết giữa các thực thể).
        \item \textbf{Ràng buộc Cấu trúc:} Tỷ số bản số (1:1, 1:N, M:N) và ràng buộc tham gia (\textit{toàn phần} vs \textit{từng phần}).
        \item \textbf{Thực thể Yếu:} Được xác định thông qua \textbf{mối kết hợp xác định} với một thực thể \textbf{chủ} và một \textbf{khóa bộ phận}; thực thể yếu tham gia \textit{toàn phần} vào mối kết hợp xác định.
        \item \textbf{Tinh chỉnh Top-Down:} Tinh chỉnh lặp lại các thực thể tổng quát; áp dụng chuyên biệt hóa/tổng quát hóa (EER).
    \end{itemize}
    
    \subsection{Nguyên lý Thiết kế Mức Logic}
    \subsubsection{Cơ bản về Mô hình Quan hệ}
    \begin{itemize}[leftmargin=*, label={--}]
        \item \textbf{Cấu trúc:} Lược đồ quan hệ $R(A_1, \dots, A_n)$; các bộ (tuple) không có thứ tự và không cho phép trùng lặp trong mô hình hình thức.
        \item \textbf{Ràng buộc Toàn vẹn:} Ràng buộc miền giá trị (nguyên tố, có kiểu), ràng buộc khóa (siêu khóa/khóa ứng viên/khóa chính), toàn vẹn thực thể (khóa chính không NULL), toàn vẹn tham chiếu (giá trị khóa ngoại phải xuất hiện trong khóa chính được tham chiếu).
    \end{itemize}

    \paragraph{ER-to-Relational Mapping Rules}
    \begin{itemize}[leftmargin=*, label={--}]
        \item \textbf{Strong Entity:} Tạo bảng. PK = Entity PK.
        \item \textbf{Weak Entity:} Tạo bảng. PK = (Owner PK + Partial Key). FK to Owner.
        \item \textbf{1:N Relationship:} Đưa PK của bên "1" làm FK vào bảng bên "N".
        \item \textbf{M:N Relationship:} Tạo \textbf{bảng trung gian}. PK = (PK\_A + PK\_B). Cả hai đều là FK.
        \item \textbf{Multivalued Attribute:} Tạo \textbf{bảng mới}. PK = (Entity PK + Attribute Value).
        \item \textbf{N-ary (Ternary) Relationship:} Tạo \textbf{bảng mới}. PK = (PK\_A + PK\_B + PK\_C). Tất cả đều là FK.
    \end{itemize}

    \subsubsection{Lý thuyết Chuẩn hóa}
    \begin{itemize}[leftmargin=*, label={--}]
        \item \textbf{Mục tiêu:} Giảm thiểu dư thừa, tránh dị thường (Thêm, Xóa, Sửa).
        \item \textbf{Phụ thuộc Hàm (FD):} $X \rightarrow Y$ (Nếu $t_1[X]=t_2[X]$ thì $t_1[Y]=t_2[Y]$).
        \item \textbf{Các loại Key:}
        \begin{itemize}
            \item \textit{Superkey:} Xác định duy nhất một bộ.
            \item \textit{Candidate Key:} Superkey tối thiểu.
            \item \textit{Prime Attribute:} Thuộc tính nằm trong bất kỳ Candidate Key nào.
        \end{itemize}
    \end{itemize}

    \textbf{Các Dạng Chuẩn (Normal Forms)}
    \begin{center}
        \includegraphics[width=0.8\linewidth, height=3cm, keepaspectratio]{./images/normalization_pyramid.png} \\
        \footnotesize \textit{(Hierarchy: BCNF $\subset$ 3NF $\subset$ 2NF $\subset$ 1NF)}
    \end{center}

    \begin{description}[leftmargin=*, labelindent=0pt, font=\bfseries\color{blue!80!black}, nosep]
        
        \item[1NF (Atomic):] Miền giá trị nguyên tố.
        \newline $\hookrightarrow$ \textit{Vi phạm:} Thuộc tính đa trị, lồng nhau, lặp lại nhóm.

        \item[2NF (No Partial):] Là 1NF + Thuộc tính \textit{non-prime} phụ thuộc đầy đủ vào khóa.
        \newline $\hookrightarrow$ \textit{Vi phạm:} $\exists X \subsetneq Key$ sao cho $X \rightarrow NonPrime$.
        \newline \textit{(Chỉ xảy ra nếu Key là khóa phức hợp)}.

        \item[3NF (No Transitive):] Là 2NF + Không có phụ thuộc bắc cầu giữa các \textit{non-prime}.
        \newline $\rightarrow$ \textit{Định nghĩa:} Với mọi $X \rightarrow A$ (không tầm thường), phải thỏa:
        \begin{enumerate*}[label=(\alph*)]
            \item $X$ là Superkey \textbf{HOẶC}
            \item $A$ là Prime Attribute.
        \end{enumerate*}

        \item[BCNF (Strict):] Nghiêm ngặt hơn 3NF.
        \newline $\rightarrow$ \textit{Định nghĩa:} Với mọi $X \rightarrow A$, $X$ \textbf{bắt buộc là Superkey}.
        \newline \textit{(Khác biệt: BCNF không chấp nhận ngoại lệ "A là Prime" như 3NF)}.

    \end{description}

    \textbf{Tính chất Phân rã (Decomposition Properties)}
    \begin{enumerate}[leftmargin=*, label={\arabic*.}]
        \item \textbf{Kết nối bảo toàn thông tin (Lossless Join):} \textit{(Bắt buộc)}
        \newline Để phân rã $R$ thành $R_1, R_2$ không bị mất dữ liệu, điều kiện là:
        \newline $(R_1 \cap R_2) \rightarrow R_1$ \textbf{HOẶC} $(R_1 \cap R_2) \rightarrow R_2$.
        \newline \textit{(Giao của 2 bảng phải là khóa của ít nhất 1 bảng).}
        \item \textbf{Bảo toàn phụ thuộc (Dependency Preservation):}
        \newline Các FD ban đầu có thể được kiểm tra riêng lẻ trên từng $R_i$ mà không cần join lại. (BCNF có thể không bảo toàn phụ thuộc).
    \end{enumerate}

    \subsubsection{Phi chuẩn hóa (Denormalization)}
    \begin{itemize}[leftmargin=*, label={--}]
        \item \textbf{Mục tiêu:} Cải thiện hiệu suất đọc bằng cách đưa dư thừa vào lược đồ, ngược với chuẩn hóa.
        \item \textbf{Động lực:} Tránh Join tốn kém; giảm độ phức tạp truy vấn; tăng locality dữ liệu.
    \end{itemize}
    
    \textbf{Kỹ thuật Denormalization:}
    \begin{itemize}[leftmargin=*, label={--}]
        \item \textbf{Materialized Views:} Kết quả truy vấn được tính trước và lưu trữ; cập nhật khi dữ liệu thay đổi.
        \item \textbf{Precomputed Aggregates:} Lưu giá trị tổng hợp (COUNT, SUM) trong bản ghi để tránh tính lại.
        \newline \textit{VD: Lưu số email chưa đọc trong bảng User thay vì đếm mỗi lần.}
        \item \textbf{Document Databases:} Nhúng (embedding) dữ liệu liên quan trong một document thay vì tham chiếu.
        \newline \textit{VD: MongoDB nhúng thông tin Worker vào document Project.}
        \item \textbf{Star Schema (DW):} Dimension tables được denormalize (VD: Brand, Category trong dim\_product).
        \item \textbf{Microservices:} Sao chép (replicate) dữ liệu giữa các service để tách biệt và giảm phụ thuộc.
    \end{itemize}
    
    \textbf{Đánh đổi (Trade-offs):}
    \begin{itemize}[leftmargin=*, label={--}]
        \item \textbf{Write Overhead:} Mỗi cập nhật phải sửa tất cả bản sao dư thừa $\Rightarrow$ ghi chậm hơn, phức tạp hơn.
        \item \textbf{Data Inconsistency:} Rủi ro không nhất quán nếu một bản sao được cập nhật mà bản khác thì không.
        \item \textbf{Storage Cost:} Lưu trữ dữ liệu trùng lặp tốn bộ nhớ hơn.
    \end{itemize}
    \textit{Khi nào dùng:} OLAP/DW (đọc nhiều), NoSQL (thiếu join), microservices (tách biệt). \textit{Tránh:} OLTP cần ACID chặt.

    \columnbreak

    \subsubsection{Bẫy Thiết kế CSDL (Design Traps)}
    \begin{itemize}[leftmargin=*, label={--}]
        \item \textbf{Bẫy Kết nối trong ER:}
        \begin{center}
            \begin{tabular}{@{} c @{}}
                \includegraphics[width=1\linewidth]{./images/design_trap_fan.png} \\
                \footnotesize (Fan Trap) \\[6pt]
                \includegraphics[width=1\linewidth]{./images/design_trap_chasm.png} \\
                \footnotesize (Chasm Trap) \\
            \end{tabular}
        \end{center}
        \begin{itemize}
            \item \textit{Fan Trap:} Đường dẫn giữa các thực thể mơ hồ do nhiều quan hệ 1:N phân nhánh từ một thực thể. VD: NhanVien $\to$ PhongBan $\to$ ChiNhanh (không xác định được nhân viên làm ở chi nhánh nào). \textit{Giải pháp:} Thêm quan hệ trực tiếp NhanVien-ChiNhanh.
            \item \textit{Chasm Trap:} Đường dẫn không tồn tại do tham gia tùy chọn. VD: KhanhHang $\to$ TaiSan $\to$ ChiNhanh (nếu tài sản chưa niêm yết thì không liên kết được khách hàng với chi nhánh). \textit{Giải pháp:} Đổi sang tham gia bắt buộc hoặc thêm quan hệ trực tiếp.
        \end{itemize}
        \item \textbf{Dị thường Cập nhật (Update Anomalies):} Do thiết kế không chuẩn hóa:
        \begin{itemize}
            \item \textit{Insertion:} Không thể thêm phòng ban mới nếu chưa có nhân viên.
            \item \textit{Deletion:} Xóa nhân viên cuối cùng làm mất thông tin phòng ban.
            \item \textit{Modification:} Thay đổi tên phòng ban phải cập nhật nhiều bộ.
        \end{itemize}
        \item \textbf{Bộ giả (Spurious Tuples):} Kết nối các quan hệ phân rã sai (không qua PK/FK hợp lệ) tạo ra bản ghi ảo. \textit{Giải pháp:} Dùng phân rã bảo toàn thông tin (lossless join).
        \item \textbf{Bẫy NULL:} Quá nhiều thuộc tính NULL lãng phí bộ nhớ và gây khó khăn trong truy vấn tổng hợp.
        \item \textbf{Sai lầm phổ biến:} Dùng PK của thực thể này làm thuộc tính của thực thể khác thay vì mô hình hóa quan hệ; gán PK vào thuộc tính của quan hệ; dùng thuộc tính đơn trị khi cần đa trị.
        \item \textbf{Entity Trap (Kiến trúc):} Thiết kế component 1-1 với bảng DB (VD: CustomerManager cho bảng Customer) thay vì theo workflow nghiệp vụ $\to$ vi phạm tách biệt dữ liệu trong microservices.
    \end{itemize}
    \textit{Thực hành tốt:} Dùng BCNF/3NF; phân rã bảo toàn thông tin; đảm bảo đường dẫn ER rõ ràng; thiết kế theo hành vi nghiệp vụ, không theo thực thể.

    \subsection{Nguyên lý Thiết kế Mức Vật lý}
    \begin{itemize}[leftmargin=*, label={--}]
        \item \textbf{Kiến trúc Lưu trữ:} Dữ liệu bền vững trên đĩa/SSD trong các \textbf{khối (block)} kích thước cố định.
        \item \textbf{Phân tích Tải (Job Mix):} Xác định các quan hệ/tập tin thường truy cập, điều kiện chọn (bằng/khác/khoảng), và tần suất cập nhật so với truy vấn.
        \item \textbf{Cấu trúc Chỉ mục:} Chỉ mục có thứ tự (B+-Trees) và chỉ mục băm; chỉ mục \textbf{chính/phân cụm} (quy định thứ tự vật lý; tối đa một trên mỗi tập tin) so với chỉ mục \textbf{phụ}.
        \item \textbf{Tối ưu hóa Truy vấn:} Dựa trên chi phí (thống kê) và các quy tắc kinh nghiệm (đẩy phép chọn/chiếu xuống sớm) để chọn kế hoạch hiệu quả.
    \end{itemize}
    \subsection{Các bước vẽ ERD}
    \begin{enumerate}[leftmargin=*, label={\textbf{\arabic*.}}]
        \item \textbf{Xác định Thực thể (Entities):} 
        \newline Tìm các \textit{danh từ} (Nouns) quan trọng trong yêu cầu (Vd: Employee, Student). Tránh nhầm lẫn thuộc tính là thực thể.
        
        \item \textbf{Xác định Mối kết hợp (Relationships):} 
        \newline Tìm các \textit{động từ} (Verbs) kết nối các thực thể (Vd: Works\_for, Teaches).
        
        \item \textbf{Xác định Thuộc tính (Attributes):} 
        \newline Xác định thông tin chi tiết cho mỗi thực thể. Xác định thuộc tính đa trị, dẫn xuất, phức hợp.
        
        \item \textbf{Xác định Khóa chính (Primary Keys):} 
        \newline Chọn thuộc tính định danh duy nhất cho mỗi thực thể và gạch chân nó.
        
        \item \textbf{Xác định Bản số (Cardinality Ratio):} 
        \newline Phân tích số lượng tham gia: 1:1, 1:N, hay M:N.
        
        \item \textbf{Xác định Ràng buộc tham gia (Participation):} 
        \newline Có bắt buộc không? (Total - Nét đôi) hay Tùy chọn? (Partial - Nét đơn).
        \newline \textit{Hỏi: `Thực thể A có thể tồn tại mà không cần B không?'}
        
        \item \textbf{Vẽ phác thảo \& Tinh chỉnh:} 
        \newline Vẽ sơ đồ, loại bỏ các thuộc tính dư thừa. Chuyển quan hệ M:N thành thực thể liên kết nếu cần thiết.
    \end{enumerate}
    \subsection{Chen Notation: ER \& EER}
    % Bảng cho Thực thể & Thuộc tính - Tiết kiệm không gian hơn liệt kê
    \subsubsection{Entities \& Attributes}
    \textit{Khi nào dùng:} \textbf{Thực thể} cho đối tượng độc lập (NhanVien, SanPham, KhanhHang); \textbf{Thực thể yếu} cho đối tượng phụ thuộc (NguoiPhuThuoccủa nhân viên, ChiTietDonHang); \textbf{Khóa} là định danh duy nhất (MSNV, CCCD); \textbf{Đa trị} cho thuộc tính nhiều giá trị (số điện thoại, email); \textbf{Dẫn xuất} cho giá trị tính toán (tuổi từ ngày sinh, tổng tiền).
    \begin{center}
        \begin{tabular}{@{} c c @{}}
            % Hàng 1: Thực thể & Thực thể yếu
            \includegraphics[width=0.5\linewidth, height=1.2cm, keepaspectratio]{./images/chen_entity.png}      &
            \includegraphics[width=0.5\linewidth, height=1.2cm, keepaspectratio]{./images/chen_weak_entity.png}                                \\
            \footnotesize (Thực thể)                                                                             & \footnotesize (Thực thể yếu) \\[2pt]

            % Hàng 2: Thuộc tính & Khóa
            \includegraphics[width=0.5\linewidth, height=1.2cm, keepaspectratio]{./images/chen_attribute.png}   &
            \includegraphics[width=0.5\linewidth, height=1.2cm, keepaspectratio]{./images/chen_key.png}                                        \\
            \footnotesize (Thuộc tính)                                                                           & \footnotesize (Khóa)         \\[2pt]

            % Hàng 3: Đa trị & Dẫn xuất
            \includegraphics[width=0.5\linewidth, height=1.2cm, keepaspectratio]{./images/chen_multivalued.png} &
            \includegraphics[width=0.5\linewidth, height=1.2cm, keepaspectratio]{./images/chen_derived.png}                                    \\
            \footnotesize (Đa trị)                                                                               & \footnotesize (Dẫn xuất)     \\
        \end{tabular}
    \end{center}

    \subsubsection{Relationships}
    \textit{Khi nào dùng:} \textbf{Quan hệ thường} cho liên kết độc lập (NhanVien \textit{làm việc cho} PhongBan, KhanhHang \textit{mua} SanPham); \textbf{Quan hệ xác định} khi thực thể yếu phụ thuộc vào thực thể chủ (NguoiPhuThuoc \textit{thuộc về} NhanVien với khóa bộ phận là tên người phụ thuộc).
    \begin{center}
        % Dùng minipage để căn chỉnh nếu ảnh có tỷ lệ khác nhau
        \includegraphics[width=0.8\linewidth]{./images/chen_relationships_summary.png} \\
        \footnotesize \textit{Bao gồm: Quan hệ (Hình thoi), Quan hệ xác định (Thoi đôi)}
    \end{center}

    \columnbreak
    
    \subsubsection{Ràng buộc (Constraints)}
    \textit{Khi nào dùng:} Xác định quy tắc nghiệp vụ giữa các thực thể.
    \begin{itemize}[leftmargin=*, label={}]
        \item \textbf{Bản số (Cardinality):} 1:1 (NhanVien \textit{quản lý} PhongBan - mỗi phòng có 1 trưởng), 1:N (PhongBan \textit{có} NhanVien - nhiều nhân viên/phòng), M:N (NhanVien \textit{tham gia} DUAN - nhiều-nhiều).
        \item \textbf{Tham gia (Participation):}
              \begin{center}
                  \includegraphics[width=0.85\linewidth]{./images/chen_participation.png} \\
                  \footnotesize (Partial Participation (Từng phần): Nét đơn \linebreak Total Participation (Toàn phần): Nét đôi)
              \end{center}
        \item \textbf{Min-Max (min, max):} Ghi cặp số trên cạnh. Ví dụ: NhanVien $(1,1)$ \textit{làm việc cho} $(0,N)$ PhongBan nghĩa là mỗi nhân viên bắt buộc làm việc cho đúng 1 phòng ban, mỗi phòng ban có thể có 0 đến nhiều nhân viên. $(0,1)$: tùy chọn, tối đa 1; $(1,N)$: bắt buộc, có thể nhiều. (An extension of Participation và Cardinality)
    \end{itemize}

    \subsubsection{EER Chuyên biệt hóa \& Tổng quát hóa}
    \textit{Khi nào dùng:} \textbf{Disjoint} khi lớp con không chồng lấp (NhanVien là KỸ SƯ hoặc QUẢN LÝ, không đồng thời); \textbf{Overlapping} khi có thể thuộc nhiều lớp (NGƯỜI là SINH VIÊN và/hoặc NHÂN VIÊN); \textbf{Union} khi lớp con kế thừa từ nhiều lớp cha (CHỦ SỞ HỮU có thể là NGƯỜI hoặc CÔNG TY hoặc NGÂN HÀNG). \textbf{Total} khi mọi thực thể cha phải thuộc ít nhất 1 lớp con; \textbf{Partial} khi không bắt buộc.
    \begin{center}
        \begin{tabular}{@{} c @{}}
            \includegraphics[width=1\linewidth]{./images/chen_eer_disjoint_overlap.png} \\
            \footnotesize (Disjoint \& Overlapping)                                       \\[2pt]
            \includegraphics[width=1\linewidth]{./images/chen_eer_union.png}            \\
            \footnotesize (Union)                                                         \\
        \end{tabular} \\[2pt]
        \footnotesize \textit{Ký hiệu: Hình tròn (d: disjoint, o: overlapping, U: union),\linebreak Nét đôi (Total), Nét đơn (Partial).}
    \end{center}

    \columnbreak

    \subsubsection{Ternary Relationships \& EER Counting}
    \paragraph{Mối kết hợp Tam nguyên (Ternary Relationships)}
    \begin{itemize}[leftmargin=*, label={--}]
        \item \textbf{Định nghĩa:} Mối kết hợp giữa 3 thực thể (A, B, C) cùng lúc.
        \item \textbf{Quy tắc đọc bản số (Look-Across):} Ký hiệu bản số gần thực thể C cho biết số instances của C liên kết với \textit{một cặp} (A, B).
        \newline \textit{VD:} Supplier-Project-Device: Bản số gần Device (ví dụ: N) nghĩa là một cặp (Supplier, Project) có thể cung cấp nhiều Device.
    \end{itemize}
    
    \paragraph{EER Counting Rules (Đếm thực thể)}
    \begin{itemize}[leftmargin=*, label={--}]
        \item \textbf{Disjoint (d):} Các lớp con không giao nhau.
        \newline $|Superclass| = |Subclass_1| + |Subclass_2| + ... + |Subclass_n|$
        \item \textbf{Overlapping (o):} Các lớp con có thể giao nhau.
        \newline $|Superclass| < |Subclass_1| + |Subclass_2| + ...$ (do có phần giao)
        \newline Áp dụng công thức: $|A \cup B| = |A| + |B| - |A \cap B|$
        \item \textbf{Union (U):} Lớp con là tập con của hợp các lớp cha.
        \newline $|Subclass| \leq |Parent_1 \cup Parent_2 \cup ...|$
    \end{itemize}

    \columnbreak

    % ===========================================================================
    % SECTION QUERY PROCESSING & OPTIMIZATION
    % ===========================================================================
    \section{Xử lý \& Tối ưu hóa Truy vấn}

    \textit{Query processing refers to the range of activities involved in extracting data from a database. Because SQL is declarative (specifying \textbf{what} to retrieve, not \textbf{how}), the DBMS must determine the most efficient execution strategy.}

    % ============================================================================
    % OVERVIEW - THREE PHASES
    % ============================================================================
    \subsection{Three Main Phases}
    \begin{enumerate}[leftmargin=*, label={\textbf{\arabic*.}}]
        \item \textbf{Parsing \& Translation:} Translate high-level SQL query into internal relational-algebra representation. Verify syntax and semantics.
        \item \textbf{Optimization:} Generate multiple equivalent execution plans. Estimate cost for each plan using statistics. Choose plan with minimum cost.
        \item \textbf{Evaluation:} Execute chosen plan using query-execution engine. Apply evaluation primitives (algorithms for relational operations).
    \end{enumerate}

    % ============================================================================
    % PHASE 1: PARSING AND TRANSLATION
    % ============================================================================
    \subsection{Phase 1: Parsing \& Translation}

    \subsubsection{Syntax \& Verification}
    \begin{itemize}[leftmargin=*, label={--}]
        \item \textbf{Syntax Checking:} Parser validates SQL syntax against language grammar.
        \item \textbf{Semantic Verification:} Verify relation names, attribute names, data types exist in database schema.
        \item \textbf{Authorization:} Check user has necessary privileges (SELECT, INSERT, UPDATE, DELETE) on referenced relations.
    \end{itemize}

    \subsubsection{Internal Representation}
    \begin{itemize}[leftmargin=*, label={--}]
        \item \textbf{Parse Tree:} Construct hierarchical syntax tree representing query structure.
        \item \textbf{Relational Algebra Translation:} Convert SQL to relational-algebra expression.
        \newline \textit{Example:} \texttt{SELECT name FROM instructor WHERE salary > 80000}
        \newline $\rightarrow$ $\pi_{name}(\sigma_{salary > 80000}(instructor))$
        \item \textbf{Query Blocks:} Decompose complex SQL into basic units (\texttt{SELECT-FROM-WHERE} expressions) that map to algebraic operators.
        \newline \textit{Nested Subqueries:} Each subquery becomes separate query block. Correlated subqueries require special handling.
        \item \textbf{View Expansion:} If query references views, replace view names with their defining relational-algebra expressions.
        \newline \textit{Recursive Process:} Views may reference other views $\rightarrow$ expand until only base relations remain.
    \end{itemize}

    \subsubsection{Query Tree (Initial Canonical Form)}
    \begin{itemize}[leftmargin=*, label={--}]
        \item \textbf{Structure:} Tree representation where:
        \begin{itemize}
            \item \textit{Leaf nodes:} Base relations (tables).
            \item \textit{Internal nodes:} Relational operations (select $\sigma$, project $\pi$, join $\bowtie$, etc.).
            \item \textit{Execution flow:} Bottom-up evaluation - leaf data flows up through operations to root.
        \end{itemize}
        \item \textbf{Canonical Form:} Initial tree follows SQL structure directly:
        \begin{itemize}
            \item Cartesian products appear when multiple relations in FROM without explicit join conditions.
            \item Selections appear high in tree (near root) reflecting WHERE clause position.
            \item Projections at root reflecting SELECT clause.
        \end{itemize}
        \item \textbf{Problem:} Canonical tree often inefficient $\rightarrow$ requires optimization transformation.
    \end{itemize}

    % ============================================================================
    % PHASE 2: QUERY OPTIMIZATION
    % ============================================================================
    \subsection{Phase 2: Tối ưu hóa Truy vấn (Query Optimization)}

    \subsubsection{Tổng quan Quy trình Tối ưu hóa}
    After parsing, the optimizer transforms the canonical query tree into an efficient execution plan through two complementary approaches:
    \begin{itemize}[leftmargin=*, label={--}]
        \item \textbf{Heuristic Optimization:} Apply algebraic transformation rules to restructure tree (reduce search space).
        \item \textbf{Cost-Based Optimization:} Enumerate candidate plans, estimate costs using statistics, choose optimal plan.
    \end{itemize}

    % ----------------------------------------------------------------------------
    % HEURISTIC OPTIMIZATION
    % ----------------------------------------------------------------------------
    \subsubsection{Heuristic Optimization}
    \textit{Goal:} Transform initial canonical query tree into more efficient equivalent tree using algebraic equivalence rules, without detailed cost estimation. This reduces search space for cost-based optimizer.

    \paragraph{3 Core Heuristic Rules}
    \begin{enumerate}[leftmargin=*, label={\textbf{\arabic*.}}]
        \item \textbf{Perform Selections Early ($\sigma$ down):} Push selection down close to leaf nodes (base relations).
        \newline \textit{Reason:} Reduce number of tuples before join $\rightarrow$ smaller intermediate results $\rightarrow$ less I/O.
        \newline \textit{Benefit:} If selection reduces 1M rows to 1K rows, subsequent join processes 1K instead of 1M.
        \item \textbf{Perform Projections Early ($\pi$ down):} Push projection down to reduce number of attributes (columns).
        \newline \textit{Reason:} Reduce "width" of intermediate relations $\rightarrow$ fewer bytes per tuple $\rightarrow$ save memory \& I/O.
        \newline \textit{Caution:} Keep attributes needed by subsequent operations (join keys, selection predicates, final output).
        \item \textbf{Avoid Cartesian Products ($\times$):} Combine Cartesian product + selection into Join ($\bowtie$).
        \newline \textit{Reason:} Cartesian product creates $|R| \times |S|$ tuples - extremely large intermediate relations.
        \newline \textit{Example:} 1000-row $\times$ 1000-row = 1M intermediate tuples. With join condition, result may be only 10K tuples.
    \end{enumerate}

    \paragraph{Transformation Rules}
    \begin{itemize}[leftmargin=*, label={--}]
        \item \textbf{Cascading of Selections:} $\sigma_{c1 \land c2}(R) = \sigma_{c1}(\sigma_{c2}(R))$.
        \newline \textit{Application:} Break conjunctive conditions to move parts down different branches.
        \item \textbf{Commutativity:} $\sigma_{c1}(R \bowtie S) = (\sigma_{c1}(R)) \bowtie S$ (if $c1$ only involves $R$).
        \newline \textit{Application:} Push selections down past joins.
        \item \textbf{Associativity:} $(R \bowtie S) \bowtie T = R \bowtie (S \bowtie T)$.
        \newline \textit{Application:} Reorder join sequence so most restrictive joins (highest selectivity) occur first.
    \end{itemize}

    \paragraph{Heuristic Algorithm (6 steps)}
    \begin{enumerate}[leftmargin=*, label={\textbf{\arabic*.}}]
        \item \textbf{Break up Selections:} Use cascading rule to split conjunctive select conditions.
        \item \textbf{Move Selections Down:} Push $\sigma$ down as far as possible (using commutativity).
        \item \textbf{Reorder Leaf Nodes:} Rearrange leaf nodes (relations) - relation with most restrictive selection (lowest selectivity) first.
        \item \textbf{Form Joins:} Combine Cartesian products with subsequent selections into Join operations.
        \item \textbf{Move Projections Down:} Break projection lists, only keep attributes needed for query result or subsequent operations.
        \item \textbf{Identify Subtrees:} Group operations that can be executed by single algorithm (e.g., single access method).
    \end{enumerate}

    \paragraph{Trade-offs \& Limitations}
    \begin{itemize}[leftmargin=*, label={--}]
        \item \textbf{Not Always Optimal:} Heuristics reduce optimization cost but don't guarantee finding optimal plan.
        \newline \textit{Example:} "Selection early" usually good, but if selection needs to scan large relation while join has efficient index, joining first may be cheaper.
        \item \textbf{Hybrid Approaches:} Commercial optimizers combine both.
        \newline \textit{System R:} Heuristics (only consider left-deep trees) + cost-based (within those constraints).
        \newline \textit{Oracle:} Heuristics rank access paths + cost-based chooses join methods.
    \end{itemize}

    \paragraph{Subquery vs Join Optimization}
    \begin{itemize}[leftmargin=*, label={--}]
        \item \textbf{Subquery Unnesting:} Optimizers generally convert \textbf{Nested Subqueries} (especially correlated) into \textbf{Joins}.
        \item \textbf{Preference Order:} \texttt{JOIN} > \texttt{Correlated Subquery} > \texttt{Cartesian Product} (worst).
        \item \textbf{Why?} Joins allow optimizer to choose efficient algorithms (Hash/Merge Join), whereas correlated subqueries force "Nested Loop" behavior (inner query runs once per outer row).
    \end{itemize}

    % ----------------------------------------------------------------------------
    % COST-BASED OPTIMIZATION FOUNDATIONS
    % ----------------------------------------------------------------------------
    \subsubsection{Cost-Based Optimization: Foundations}

    After heuristic optimization, system generates multiple candidate execution plans and estimates cost for each using statistical information from database catalog.

    \paragraph{Cost Metrics}
    \begin{itemize}[leftmargin=*, label={--}]
        \item \textbf{Primary Metric - Disk I/O:} Number of block transfers + number of disk seeks.
        \newline \textit{Reason:} For large disk-resident databases, I/O cost dominates CPU cost.
        \item \textbf{Secondary Metrics:} CPU time (for in-memory operations), network communication cost (distributed systems).
        \item \textbf{Response Time vs Throughput:} Systems may optimize for fast first-result (pipelining) or total execution time (materialization).
    \end{itemize}

    \paragraph{Cost Function Notation}
    \textit{Ước tính tài nguyên (disk I/O) để xử lý truy vấn: số block transfers ($b$) và số disk seeks ($S$).}
    \begin{itemize}[leftmargin=*, label={--}]
        \item $b$ (hoặc $b_r$): Tổng số blocks trong file.
        \item $r$ (hoặc $n_r$): Tổng số records (tuples) trong relation.
        \item $s$ (hoặc $s_A$): \textbf{Selection cardinality} - số records trung bình thỏa điều kiện.
        \item $bfr$: Blocking factor (số records trên mỗi block).
        \item $x$ (hoặc $h_i$): Số levels trong index (chiều cao B+-tree).
        \item $t_S$: Average time cho disk seek.
        \item $t_T$: Average time để transfer một block.
        \item \textbf{Công thức tổng:} Cost = $b \times t_T + S \times t_S$ (transfer time + seek time).
    \end{itemize}

    \paragraph{Statistical Information (Catalog Metadata)}
    \begin{itemize}[leftmargin=*, label={--}]
        \item \textbf{Relation Statistics:} $n_r$ (number of tuples), $b_r$ (number of blocks), $l_r$ (tuple size in bytes).
        \item \textbf{Attribute Statistics:} $V(A,r)$ (number of distinct values for attribute $A$), $min(A,r)$ and $max(A,r)$ (value range).
        \item \textbf{Index Statistics:} Index type, height ($h_i$), number of leaf blocks, clustering vs non-clustering.
        \item \textbf{Histograms:} Store distribution of attribute values to improve selectivity estimates.
        \newline \textit{Equi-width:} Divide value range into equal-sized buckets, count tuples in each.
        \newline \textit{Equi-depth:} Buckets contain approximately equal number of tuples.
        \newline \textit{Use:} Handle skewed data distributions (e.g., most employees earn 30K-50K, few earn >100K).
    \end{itemize}

    % ----------------------------------------------------------------------------
    % INDEX STRUCTURES (Supporting Access Path Selection)
    % ----------------------------------------------------------------------------
    \subsection{Cơ bản về Chỉ mục (Index Structures)}

    \textit{Indexes are critical data structures that enable efficient access paths for query execution. Understanding index characteristics is essential for cost estimation and access path selection.}

    \subsubsection{Chỉ mục là gì?}
    \begin{itemize}[leftmargin=*, label={--}]
        \item \textbf{Mục đích:} Tăng tốc độ truy xuất dữ liệu bằng cách tạo đường dẫn phụ trợ đến các bản ghi.
        \item \textbf{Khóa tìm kiếm:} (Các) thuộc tính dùng để tìm bản ghi; không nhất thiết là khóa chính; có thể là khóa phức hợp (nhiều cột).
        \item \textbf{Đánh đổi:} Đọc nhanh hơn so với ghi chậm hơn (chi phí bảo trì chỉ mục khi INSERT/UPDATE/DELETE).
    \end{itemize}

    \subsubsection{Phân loại Chỉ mục}
    \begin{itemize}[leftmargin=*, label={--}]
        \item \textbf{Theo Cấu trúc:}
            \begin{itemize}
                \item \textit{Có thứ tự (Ordered):} Các mục được sắp xếp (vd: B+-tree); hỗ trợ truy vấn khoảng.
                \item \textit{Băm (Hash):} Khóa được băm vào bucket; chỉ nhanh khi tìm kiếm chính xác (dấu bằng).
            \end{itemize}
        \item \textbf{Theo Mật độ:}
            \begin{itemize}
                \item \textit{Đặc (Dense):} Một mục chỉ mục cho mỗi giá trị khóa tìm kiếm riêng biệt.
                \item \textit{Thưa (Sparse):} Một mục chỉ mục cho mỗi khối (hoặc mỗi giá trị phân cụm); nhỏ hơn, chi phí bảo trì thấp hơn.
            \end{itemize}
        \item \textbf{Theo Thứ tự Vật lý:}
            \begin{itemize}
                \item \textit{Chỉ mục Chính/Phân cụm:} Khóa tìm kiếm quyết định thứ tự vật lý của tập tin (tối đa một per bảng); thường là chỉ mục thưa.
                \item \textit{Chỉ mục Phụ:} Đường dẫn truy cập thay thế độc lập với thứ tự vật lý; thường là chỉ mục đặc hoặc dùng gián tiếp cho các khóa không duy nhất.
            \end{itemize}
    \end{itemize}

    \paragraph{Multi-level Index Properties}
    \begin{itemize}[leftmargin=*, label={--}]
        \item \textbf{Root Constraint:} Mức cao nhất (root) của B-Tree/B+-Tree \textbf{luôn} chiếm \textbf{đúng 1} disk block.
        \item \textbf{Tree Height:} Cây chỉ tăng chiều cao khi root node bị split.
    \end{itemize}


    \subsubsection{Công thức Số lượng Index Entries}
    \textit{Xác định số hàng trong file chỉ mục (không phải chi phí truy cập).}
    \begin{itemize}[leftmargin=*, label={--}]
        \item \textbf{Primary Index (Sparse):} Số Index Entries = Số \textbf{Blocks} trong Data File.
        \newline $\text{Entries} = b = \lceil r / bfr \rceil$
        \newline \textit{Lý do:} Mỗi block có 1 entry (anchor record/block anchor).
        \item \textbf{Clustering Index (Sparse):} Số Index Entries = Số \textbf{Distinct Values} của clustering field.
        \newline $\text{Entries} = \text{NDV (Number of Distinct Values)}$
        \newline \textit{Lý do:} Mỗi giá trị duy nhất có 1 entry trỏ đến block đầu tiên chứa giá trị đó.
        \item \textbf{Secondary Index (Dense):} Số Index Entries = Số \textbf{Records} trong Data File.
        \newline $\text{Entries} = r$
        \newline \textit{Lý do:} Mỗi record có 1 entry (dense index).
    \end{itemize}

    \subsubsection{B-Trees \& B+-Trees}

    \paragraph{Khác biệt Cấu trúc}
    \textit{Mặc dù thường dùng thay thế cho nhau, B-Tree và B+-Tree có sự khác biệt quan trọng về nơi lưu data pointers.}
    \begin{itemize}[leftmargin=*, label={--}]
        \item \textbf{B-Tree:} Search key values appear \textit{only once} in tree. Data pointers exist at \textit{all levels} (internal + leaf nodes).
        \newline $\rightarrow$ Lookup can terminate at internal node if key is found.
        \item \textbf{B+-Tree:} Data pointers only stored at \textit{leaf nodes}. Internal nodes only contain separator keys to guide search.
        \newline $\rightarrow$ Internal nodes contain more keys $\rightarrow$ higher fan-out $\rightarrow$ shorter tree height.
        \newline $\rightarrow$ Leaf nodes linked together $\rightarrow$ efficient sequential access \& range scans.
        \item \textbf{Industry Standard:} Most modern DBMS use B+-Tree (abbreviated as B-Tree) due to fewer disk I/Os.
    \end{itemize}

    \paragraph{General Structure \& Properties}
    \begin{itemize}[leftmargin=*, label={--}]
        \item \textbf{Balanced Tree:} Every path from root to leaf has same length (uniform height).
        \item \textbf{Node Capacity:} Each node = fixed-size disk block (typically 4KB or larger).
        \item \textbf{Fan-out:} Internal nodes contain from $\lceil n/2 \rceil$ to $n$ children. High fan-out $\rightarrow$ B-Trees "fat and short".
        \newline \textit{Example:} 3-4 levels can store terabytes of data.
        \item \textbf{Leaf Nodes:} Contain from $\lceil (n-1)/2 \rceil$ to $n-1$ values, sorted by search key.
        \item \textbf{Separator Keys:} Internal node with keys $K_1, K_2, \ldots, K_{n-1}$: pointer $P_i$ points to subtree with values $X$ satisfying $K_{i-1} < X < K_i$.
    \end{itemize}

    \paragraph{Algorithms (Complexity: $O(\log_N M)$)}

    \textit{Search (Lookup):}
    \begin{itemize}[leftmargin=*, label={--}]
        \item \textbf{Traversal:} Start from root. At each internal node, binary search finds correct child pointer covering search key range.
        \item \textbf{Termination:} Repeat until leaf node. In B+-Tree, search leaf for specific key and associated record pointer.
        \item \textbf{Range Queries:} Leaf nodes linked (sibling pointers) $\rightarrow$ efficient range scan. Find starting key, traverse linked list.
    \end{itemize}

    \textit{Insertion:}
    \begin{enumerate}[leftmargin=*, label={\textbf{\arabic*.}}]
        \item \textbf{Locate Leaf:} Find leaf node where new key belongs.
        \item \textbf{Space Available:} If leaf has space $\rightarrow$ insert entry in sorted order.
        \item \textbf{Splitting (Overflow):} If leaf full:
        \begin{itemize}
            \item Split into 2 nodes: first $\lceil n/2 \rceil$ entries in original, rest in new node.
            \item Middle key promoted (copied) up to parent as separator.
        \end{itemize}
        \item \textbf{Propagation:} If parent also full $\rightarrow$ split propagates upward. Root split $\rightarrow$ new root $\rightarrow$ tree height increases by 1.
    \end{enumerate}

    \textit{Deletion:}
    \begin{enumerate}[leftmargin=*, label={\textbf{\arabic*.}}]
        \item \textbf{Locate \& Remove:} Find entry in leaf node and delete.
        \item \textbf{Underflow:} If node $< \lceil n/2 \rceil$ full:
        \begin{itemize}
            \item \textit{Redistribute:} Borrow entries from sibling node (shift keys through parent).
            \item \textit{Merge (Coalesce):} If cannot redistribute $\rightarrow$ merge with sibling. Separator key in parent is deleted/demoted.
        \end{itemize}
        \item \textbf{Propagation:} Merge can propagate upward, potentially reducing tree height.
    \end{enumerate}

    \paragraph{Capacity Calculation Example}
    \textit{Parameters:} Block size $B=512$ bytes; key size $V=9$ bytes; data pointer $\Pr=7$ bytes; tree pointer $P=6$ bytes.

    \textit{Step 1: Fan-out Calculation}
    \begin{itemize}[leftmargin=*, label={--}]
        \item \textbf{B-Tree Internal Node:} Contains $p$ tree pointers + $(p-1)$ keys + $(p-1)$ data pointers.
        \newline $(p \times 6) + ((p-1) \times (7+9)) \le 512 \Rightarrow 22p \le 528 \Rightarrow p = 23$

        \item \textbf{B+-Tree Internal Node:} Contains $p$ tree pointers + $(p-1)$ keys (no data pointers).
        \newline $(p \times 6) + ((p-1) \times 9) \le 512 \Rightarrow 15p \le 521 \Rightarrow p = 34$
        \newline \textit{Insight:} B+-Tree fan-out 48\% higher (34 vs 23) $\rightarrow$ shorter tree.

        \item \textbf{B+-Tree Leaf Node:} Contains $p_{leaf}$ key/data pointer pairs + 1 next pointer.
        \newline $(p_{leaf} \times (7+9)) + 6 \le 512 \Rightarrow 16 \times p_{leaf} \le 506 \Rightarrow p_{leaf} = 31$
    \end{itemize}

    \textit{Step 2: Estimate Total Capacity (69\% Full)}
    \begin{itemize}[leftmargin=*, label={--}]
        \item \textbf{B-Tree (3 levels):} Average fan-out $fo = 23 \times 0.69 \approx 16$.
            \begin{itemize}
                \item Level 0 (root): 15 entries, 16 pointers
                \item Level 1: $16 \times 15 = 240$ entries
                \item Level 2: $256 \times 15 = 3{,}840$ entries
                \item \textbf{Total:} $15 + 240 + 3{,}840 \approx \mathbf{4{,}095}$ entries
            \end{itemize}

        \item \textbf{B+-Tree (3 levels):} Internal nodes $fo = 34 \times 0.69 \approx 23$; Leaf capacity $= 31 \times 0.69 \approx 21$.
            \begin{itemize}
                \item Level 0: 22 entries, 23 pointers
                \item Level 1: $23 \times 22 = 506$ entries, 529 pointers
                \item Leaf level: $12{,}167 \times 21 \approx \mathbf{255{,}507}$ data pointers
            \end{itemize}

        \item \textbf{Observation:} B+-Tree holds $\sim 4\times$ more entries at the same height due to lighter internal nodes.
    \end{itemize}

    \paragraph{Implementation \& Optimizations}
    \begin{itemize}[leftmargin=*, label={--}]
        \item \textbf{Write-Ahead Log (WAL):} B-Trees overwrite pages on disk. Crash during multi-page update (split) $\rightarrow$ corruption.
        \newline $\rightarrow$ WAL writes modifications before updating tree pages $\rightarrow$ durability \& atomicity.
        \item \textbf{Concurrency (Latches):} Multiple threads access index concurrently $\rightarrow$ use latches (lightweight locks).
        \newline \textit{Latch Crabbing:} Lock parent $\rightarrow$ lock child $\rightarrow$ release parent $\rightarrow$ high concurrency.
        \item \textbf{Bulk Loading:} Inserting records one-by-one $\rightarrow$ random I/O $\rightarrow$ inefficient.
        \newline $\rightarrow$ Bulk load: Sort data $\rightarrow$ build tree bottom-up (sequential writes) $\rightarrow$ create parent nodes as needed.
        \item \textbf{Flash Storage (SSD):} Random reads fast, random writes expensive (erase-modify-write cycles).
        \newline $\rightarrow$ LSM-Tree (Log-Structured Merge-Tree) preferred for write-heavy workloads, but B-Trees remain general-purpose standard.
        \item \textbf{Prefix Compression:} Internal nodes only store prefix of key (enough to distinguish subtrees) instead of full key $\rightarrow$ increases fan-out.
        \item \textbf{Right-Only Appends:} With auto-incrementing keys, allocate new node when rightmost leaf full instead of split $\rightarrow$ avoids half-empty pages.
    \end{itemize}

    \subsubsection{Advanced Index Types}
    \begin{itemize}[leftmargin=*, label={--}]
        \item \textbf{Composite Indexes:} Multi-column keys (e.g., (City, LastName)); support leftmost prefix queries (City), (City, LastName); order columns by selectivity.
        \item \textbf{Function-Based Indexes:} Indexes on expressions (e.g., \texttt{LOWER(email)}); queries must use the exact function to utilize the index.
        \begin{itemize}
            \item \textit{Problem:} Standard index on \texttt{Name} is \textbf{useless} for \texttt{WHERE lower(Name) = '...'}.
            \item \textit{Solution:} \texttt{CREATE INDEX idx\_lower ON Employee (lower(Name));}
            \item \textit{Key Concept:} The index stores the \textit{result} of the function, allowing the DB to search directly on the computed values.
        \end{itemize}
    \end{itemize}

    \subsubsection{Chỉ mục Băm \& Bitmap}

    \paragraph{Chỉ mục Băm (Hash Indexes)}
    \begin{itemize}[leftmargin=*, label={--}]
        \item \textbf{Sử dụng:} Tìm kiếm chính xác cực nhanh (truy vấn điểm); không hỗ trợ khoảng.
        \item \textbf{Xử lý đụng độ:} Dùng danh sách liên kết (chaining) với bucket tràn.
        \item \textbf{Biến thể động:} Băm mở rộng/tuyến tính (Extendible/Linear hashing) tăng trưởng dần mà không cần xây lại toàn bộ.
    \end{itemize}

    \paragraph{Chỉ mục Bitmap}
    \textit{Tối ưu cho thuộc tính có độ chọn lọc thấp (ít giá trị riêng biệt).}
    \begin{itemize}[leftmargin=*, label={--}]
        \item \textbf{Cấu trúc:} Đánh số thứ tự bản ghi (0, 1, 2, ...); mỗi giá trị riêng biệt có một bitmap; bit $i=1$ nếu bản ghi $i$ có giá trị đó.
        \item \textbf{Ví dụ (bảng 5 dòng):}
            \begin{itemize}
                \item \texttt{gender='m'}: 10010 \quad \texttt{gender='f'}: 01101
                \item \texttt{income='L1'}: 11000 \quad \texttt{income='L2'}: 00100
            \end{itemize}
        \item \textbf{Truy vấn: gender='f' AND income='L2'}
        \item[] $01101 \; \text{AND} \; 00100 = 00100 \quad \Rightarrow \quad \text{bản ghi 2}$
        \item \textbf{Ưu điểm:} Gọn nhẹ (1 triệu dòng = 125 KB mỗi bitmap); thao tác bitwise nhanh; hiệu quả cho bộ lọc nhiều điều kiện; hỗ trợ COUNT qua đếm bit.
    \end{itemize}

    % ----------------------------------------------------------------------------
    % SELECTION COST FUNCTIONS
    % ----------------------------------------------------------------------------
    \subsection{Hàm Chi phí cho Các Phép Toán (Operation Cost Functions)}

    \subsubsection{Selection Cost Functions}
    \textit{Phép chọn ($\sigma$) có thể dùng quét file hoặc truy cập index. Chi phí chưa tính ghi kết quả.}

    \paragraph{S1: Linear Search (File Scan)}\mbox{}\\
    Quét mọi block và test tất cả records. Áp dụng cho mọi cấu trúc file.
    \begin{itemize}[leftmargin=*, label={--}]
        \item \textbf{Trường hợp chung:} $\mathbf{C_{S1a} = b}$ blocks. 
        \newline \textit{Time:} $t_S + b \times t_T$ (1 seek ban đầu + transfer all blocks).
        \item \textbf{Equality on Key:} $\mathbf{C_{S1b} = b/2}$ blocks (trung bình, dừng khi tìm thấy).
        \newline \textit{Time:} $t_S + (b/2) \times t_T$.
    \end{itemize}

    \paragraph{S2: Binary Search}\mbox{}\\
    File đã sắp xếp theo search attribute. $\mathbf{C_{S2} = \lceil \log_2 b \rceil + \lceil s/bfr \rceil - 1}$ blocks.
    \newline \textit{Giải thích:} $\log_2 b$ để locate first block + $\lceil s/bfr \rceil$ để retrieve matching blocks contiguous.

    \paragraph{S3a: Primary Index (Equality on Unique Key)}\mbox{}\\
    File được sắp xếp vật lý theo search key. $\mathbf{C_{S3a} = x + 1}$ blocks.
    \newline \textit{Time:} $(h_i + 1) \times (t_T + t_S)$ (traverse index tree + 1 data block access).
    \newline \textit{VD:} B+-tree height 3 $\rightarrow$ 3 index blocks + 1 data block = 4 I/Os.

    \paragraph{S3b: Hash Index (Equality)}\mbox{}\\
    $\mathbf{C_{S3b} = 1}$ (static/linear hashing) hoặc $\mathbf{2}$ (extendible hashing).

    \paragraph{S5: Clustering Index (Equality on Non-Unique Key)}\mbox{}\\
    File sắp xếp, matching records lưu contiguous. $\mathbf{C_{S5} = x + \lceil s/bfr \rceil}$ blocks.
    \newline \textit{Time:} $h_i \times (t_T + t_S) + t_S + b_{matches} \times t_T$ (index + 1 seek to data + transfer).
    \newline \textit{VD:} Tìm Dno=5 với 1000 matching records, bfr=10 $\rightarrow$ x + 100 blocks.

    \paragraph{S6a: Secondary Index (Equality on Non-Unique Key)}\mbox{}\\
    File \textbf{không} sắp xếp theo attribute này $\rightarrow$ matching records phân tán. 
    \newline $\mathbf{C_{S6a} = x + s + 1}$ blocks (worst case: mỗi record cần 1 random I/O).
    \newline \textit{Time:} $(h_i + n) \times (t_T + t_S)$ với $n$ = số records.
    \newline \textbf{Nguy cơ:} Nếu $s$ lớn, secondary index đắt hơn linear scan do nhiều random seeks.

    \paragraph{S6b: Secondary Index (Range Query)}\mbox{}\\
    $\mathbf{C_{S6b} = x + (b_{I1}/2) + (r/2)}$ (giả sử half file thỏa điều kiện).
    \newline \textit{Performance Implication:} Nếu số records lớn, optimizer thích linear scan hơn secondary index.

    \paragraph{Selections với Comparisons (Range Queries)}
    \begin{itemize}[leftmargin=*, label={--}]
        \item \textbf{Clustering Index:} Hiệu quả - records contiguous. 
        \newline \textit{Cost:} $x + b_{range}$ (find first + sequential scan).
        \item \textbf{Secondary Index:} Đắt - index leaves scan + random I/O cho mỗi record. 
        \newline \textit{Nếu range lớn:} Prefer linear scan.
    \end{itemize}

    \paragraph{Complex Selections}
    \begin{itemize}[leftmargin=*, label={--}]
        \item \textbf{Conjunctive (AND):} Choose single most restrictive access path (smallest selectivity) $\rightarrow$ check remaining conditions in RAM. 
        \newline \textit{Alternatively:} Use multiple secondary indices $\rightarrow$ retrieve pointers $\rightarrow$ compute \textbf{intersection}.
        \item \textbf{Disjunctive (OR):} If 1 condition needs linear scan $\rightarrow$ entire query needs linear scan. 
        \newline \textit{If indices for all:} Retrieve pointers $\rightarrow$ compute \textbf{union}.
    \end{itemize}

    \columnbreak

    \paragraph{Bảng Tóm tắt Chi phí SELECT}
    \begin{center}
        \renewcommand{\arraystretch}{1.15}
        \begin{tabular}{@{} l | l | l @{}}
            \toprule
            \textbf{Algorithm} & \textbf{Mô tả} & \textbf{Block Accesses} \\
            \midrule
            \textbf{S1} & Linear Search & $b$ \\
            \textbf{S2} & Binary Search & $\lceil \log_2 b \rceil + \lceil s/bfr \rceil - 1$ \\
            \textbf{S3a} & Primary Index (Unique) & $x + 1$ \\
            \textbf{S5} & Clustering Index (Equality) & $x + \lceil s/bfr \rceil$ \\
            \textbf{S6a} & Secondary Index (Equality) & $x + s + 1$ \\
            \textbf{S6b} & Secondary Index (Range) & $x + (b_{I1}/2) + (r/2)$ \\
            \bottomrule
        \end{tabular}
    \end{center}

    \textit{Lưu ý: Chi phí thời gian = $b \times t_T + S \times t_S$ (tách biệt transfer và seek).}

    % ----------------------------------------------------------------------------
    % SELECTION EXAMPLES
    % ----------------------------------------------------------------------------
    \subsubsection{Ví dụ Tính toán Chi phí: Phép chọn trên EMPLOYEE}

    \textit{Kịch bản:} Quan hệ EMPLOYEE có thông số:
    \begin{itemize}[leftmargin=*, nosep]
        \item $r_E = 10{,}000$ records, $b_E = 2{,}000$ blocks, $bfr_E = 5$ records/block.
        \item \textbf{Available Access Paths:}
        \begin{itemize}
            \item \textit{Ssn} (Secondary, Unique Key): $x=4$, $s=1$.
            \item \textit{Dno} (Secondary, Non-Unique): $x=2$, $s=80$ (assumption: 125 depts, so $10{,}000/125=80$).
            \item \textit{Salary} (Clustering, Non-Unique): $x=3$, $s=20$.
            \item \textit{Sex} (Secondary, Non-Unique): $x=1$, $s=5{,}000$ (assumption: 2 values, so $10{,}000/2=5{,}000$).
        \end{itemize}
    \end{itemize}

    \paragraph{Example 1: Equality on Unique Key}\mbox{}\\
    Query: $\sigma_{\text{Ssn}='123456789'}(\text{EMPLOYEE})$.
    \begin{itemize}[leftmargin=*, label={--}]
        \item \textbf{S1b (Linear Search):} $C = b_E/2 = 2{,}000/2 = 1{,}000$ blocks.
        \newline \textit{Explanation:} Scan half file on average until record found.
        \item \textbf{S6a (Secondary Index on Key):} $C = x + 1 = 4 + 1 = 5$ blocks.
        \newline \textit{Explanation:} Traverse 4-level index + retrieve 1 data block.
        \item \textbf{Decision:} Use S6a (5 blocks $\ll$ 1{,}000 blocks). \textit{Speedup: 200x}.
    \end{itemize}

    \paragraph{Example 2: Equality on Non-Unique Key}\mbox{}\\
    Query: $\sigma_{\text{Dno}=5}(\text{EMPLOYEE})$.
    \begin{itemize}[leftmargin=*, label={--}]
        \item \textbf{S1a (Linear Search):} $C = b_E = 2{,}000$ blocks.
        \item \textbf{S6a (Secondary Index):} $C = x + s = 2 + 80 = 82$ blocks.
        \newline \textit{Explanation:} 2 index blocks + 80 random I/Os (records scattered across blocks).
        \item \textbf{S5 (If Clustering Index existed):} $C = x + \lceil s/bfr \rceil = 3 + \lceil 80/5 \rceil = 3 + 16 = 19$ blocks.
        \newline \textit{Explanation:} 3 index blocks + 16 contiguous data blocks (records stored together).
        \item \textbf{Decision:} Use S6a (82 blocks $\ll$ 2{,}000). \textit{Note: Clustering index would be 4.3x better (19 vs 82)}.
    \end{itemize}

    \paragraph{Example 3: Conjunctive Selection (Multiple Conditions)}\mbox{}\\
    Query: $\sigma_{\text{Dno}=5 \land \text{Salary}>30{,}000 \land \text{Sex}='F'}(\text{EMPLOYEE})$.
    \newline \textit{Strategy:} Choose most selective access path to retrieve candidate set, then filter remaining conditions in memory.
    \begin{itemize}[leftmargin=*, label={--}]
        \item \textbf{Via Dno (S6a):} $C = x + s = 2 + 80 = 82$ blocks. \textit{Retrieves 80 records}.
        \item \textbf{Via Salary Range (Clustering):} $C \approx x + (b_E/2) = 3 + 1{,}000 = 1{,}003$ blocks.
        \newline \textit{Assumption: Half employees earn $>30{,}000$, need to scan half file.}
        \item \textbf{Via Sex (S6a):} $C = x + s = 1 + 5{,}000 = 5{,}001$ blocks. \textit{5{,}000 random I/Os (very expensive)}.
        \item \textbf{Linear Scan (S1a):} $C = 2{,}000$ blocks.
        \item \textbf{Decision:} Use Dno index (82 blocks) to retrieve 80 candidate records $\rightarrow$ filter Salary $>30{,}000$ and Sex='F' in memory.
        \newline \textit{Final result size estimated:} $80 \times 0.5 \times 0.5 = 20$ records (assuming 50\% pass each filter).
    \end{itemize}

    \paragraph{Example 4: Secondary Index vs Linear Scan Trade-off}\mbox{}\\
    Query: $\sigma_{\text{Sex}='F'}(\text{EMPLOYEE})$ (highly non-selective).
    \begin{itemize}[leftmargin=*, label={--}]
        \item \textbf{S6a (Secondary Index):} $C = x + s = 1 + 5{,}000 = 5{,}001$ blocks.
        \newline \textit{Problem:} 5{,}000 random seeks $\rightarrow$ extremely expensive. At $t_S=10$ms, $t_T=1$ms: $(1 + 5{,}000) \times 11 = 55{,}011$ms $\approx$ 55 seconds.
        \item \textbf{S1a (Linear Scan):} $C = 2{,}000$ blocks.
        \newline \textit{Time:} $1 \times 10 + 2{,}000 \times 1 = 2{,}010$ms $\approx$ 2 seconds.
        \item \textbf{Decision:} Use linear scan (2{,}000 blocks $\ll$ 5{,}001 blocks). \textit{27x faster despite having index!}
        \newline \textbf{Key Insight:} Secondary index only beneficial when selectivity is high ($s \ll b$).
    \end{itemize}

    % ----------------------------------------------------------------------------
    % JOIN COST FUNCTIONS
    % ----------------------------------------------------------------------------
    \subsubsection{Cost Functions for JOIN Operations}

    \paragraph{Notation}
    \begin{itemize}[leftmargin=*, nosep]
        \item $b_r, b_s$: Number of blocks (số khối) in relations $r$ and $s$.
        \item $n_r, n_s$ (or $|R|, |S|$): Number of tuples (số bộ) in relations $r$ and $s$.
        \item $js$: Join selectivity (độ chọn lọc kết nối) - fraction of tuple pairs matching. For equi-join: $js \approx 1/\max(NDV(A), NDV(B))$.
        \item $jc$: Join cardinality (lực lượng kết nối) - number of result tuples = $js \times |R| \times |S|$.
        \item $bfr_{result}$: Blocking factor (hệ số khối) of result relation.
        \item $n_B$ (or $M$): Number of available memory buffer blocks (số khối bộ đệm).
        \item $h_i$ (or $x$): Height of index tree (chiều cao B+-tree).
        \item $s_B$: Selection cardinality - average matching records in index lookup.
    \end{itemize}

    \paragraph{J1: Nested-Loop Join Variants}
    \begin{itemize}[leftmargin=*, label={--}]
        \item \textbf{Basic Nested-Loop:} For each record in outer relation $r$, scan entire inner relation $s$.
        \newline \textit{Cost:} $b_r + n_r \times b_s$ block transfers + $(n_r + b_r)$ seeks.
        \newline \textit{Problem:} Extremely expensive if $n_r$ is large.
        
        \item \textbf{Block Nested-Loop:} Process block-by-block instead of row-by-row.
        \newline \textit{Cost (Worst):} $b_r + (b_r \times b_s)$ transfers + $2 \times b_r$ seeks.
        \newline \textit{Cost (With $n_B$ buffers):} $b_r + \lceil b_r / (n_B - 2) \rceil \times b_s$ transfers.
        \newline \textit{Strategy:} Use $n_B - 2$ buffers for outer, 1 for inner, 1 for output. Use smaller relation as outer.
    \end{itemize}

    \paragraph{J2: Indexed Nested-Loop Join}\mbox{}\\
    Index exists on join attribute of inner relation $s$. Replace file scans with index lookups.
    \begin{itemize}[leftmargin=*, label={--}]
        \item \textbf{General Formula:} $b_r + (n_r \times \text{cost of selection on } s)$.
        \newline \textit{Explanation:} Read outer $r$ ($b_r$) + perform $n_r$ index lookups on $s$.
        \item \textbf{Secondary Index:} $b_r + n_r \times (x + s_B + 1)$ blocks.
        \newline \textit{$s_B$:} Average matching records. Each record needs random I/O if non-unique.
        \item \textbf{Primary/Clustering Index:} $b_r + n_r \times (x + 1)$ blocks.
        \newline \textit{Assumption:} Unique keys or matching records stored contiguous.
    \end{itemize}

    \paragraph{J3: Sort-Merge Join}\mbox{}\\
    Both relations must be sorted on join attributes. Highly efficient if already pre-sorted.
    \begin{itemize}[leftmargin=*, label={--}]
        \item \textbf{If already sorted:} $b_r + b_s$ block transfers (read both once).
        \item \textbf{If not sorted:} Cost(Sort $r$) + Cost(Sort $s$) + $b_r + b_s$.
        \newline \textit{Sort Cost:} Typically $b \times (2 \lceil \log_{n_B-1}(b/n_B) \rceil + 1)$ for external merge-sort.
        \item \textbf{Best Use Case:} Data already sorted, or when result needs to be sorted.
    \end{itemize}

    \paragraph{J4: Hash Join}\mbox{}\\
    Partition both relations by hash of join key. Matching tuples fall into same partition.
    \begin{itemize}[leftmargin=*, label={--}]
        \item \textbf{Standard Hash Join:} $3(b_r + b_s)$ block transfers.
        \newline \textit{3 Passes:} 1. Read/write partitions for $r$. 2. Read/write partitions for $s$. 3. Join partitions.
        \newline \textit{Requirement:} Partitions of smaller relation must fit in memory.
        \item \textbf{Hybrid Hash Join:} $b_r + b_s$ (best case).
        \newline \textit{Optimization:} If entire build relation fits in memory, skip disk writes for some partitions.
    \end{itemize}

    \paragraph{Writing the Result}\mbox{}\\
    Above costs only estimate processing. Must add write cost to get total cost.
    \begin{itemize}[leftmargin=*, label={--}]
        \item \textbf{Write Cost:} $jc / bfr_{result}$ blocks.
        \item \textbf{Total Cost:} Processing Cost + $(js \times |R| \times |S|) / bfr_{result}$.
    \end{itemize}

    % ----------------------------------------------------------------------------
    % JOIN EXAMPLE
    % ----------------------------------------------------------------------------
    \subsubsection{Example: EMPLOYEE $\bowtie$ DEPARTMENT}

    \textbf{Scenario:} EMPLOYEE ($|E|=10{,}000$, $b_E=2{,}000$) $\bowtie_{Dno=Dnumber}$ DEPARTMENT ($|D|=125$, $b_D=13$).
    \newline \textbf{Indices:} Secondary on $E.Dno$ ($x=2$, $s=80$). Primary on $D.Dnumber$ ($x=1$).
    \newline \textbf{Parameters:} $js=1/125$, $jc=10{,}000$, $bfr_{result}=4$ $\rightarrow$ write cost $= 2{,}500$ blocks. $n_B=3$ buffers.

    \begin{itemize}[leftmargin=*, label={--}]
        \item \textbf{J1: Block Nested-Loop (D outer):} 
        \newline $C = 13 + \lceil 13/1 \rceil \times 2{,}000 + 2{,}500 = 13 + 26{,}000 + 2{,}500 = \mathbf{28{,}513}$ blocks.
        \newline \textit{Explanation:} Read D (13) + scan E 13 times (26,000) + write result (2,500).

        \item \textbf{J2a: Indexed Nested-Loop (D outer $\to$ E inner):} 
        \newline $C = 13 + 125 \times (2 + 80) + 2{,}500 = 13 + 10{,}250 + 2{,}500 = \mathbf{12{,}763}$ blocks.
        \newline \textit{Explanation:} Read D (13) + 125 lookups on E (each: 2 index + 80 scattered records) + write.

        \item \textbf{J2b: Indexed Nested-Loop (E outer $\to$ D inner):} 
        \newline $C = 2{,}000 + 10{,}000 \times (1 + 1) + 2{,}500 = 2{,}000 + 20{,}000 + 2{,}500 = \mathbf{24{,}500}$ blocks.
        \newline \textit{Explanation:} Read E (2,000) + 10,000 lookups on D (each: 1 index + 1 data block) + write.

        \item \textbf{J3: Sort-Merge (if already sorted):}
        \newline $C = 2{,}000 + 13 + 2{,}500 = \mathbf{4{,}513}$ blocks.
        \newline \textit{Best case:} Only read both relations once + write result.
        \newline \textit{If not sorted:} Add sorting cost (typically $\approx 2b \log b$ per relation).

        \item \textbf{J4: Hash Join:}
        \newline $C = 3 \times (2{,}000 + 13) + 2{,}500 = 6{,}039 + 2{,}500 = \mathbf{8{,}539}$ blocks.
        \newline \textit{Explanation:} 3 passes through both relations (partition + build + probe) + write result.
    \end{itemize}

    \paragraph{Decision Ranking}\mbox{}\\
    J3 (if sorted) $<$ J4 $<$ J2a $<$ J2b $<$ J1.
    \begin{itemize}[leftmargin=*, label={--}]
        \item \textbf{Best:} Sort-Merge if already sorted (4,513).
        \item \textbf{Good:} Hash Join if not sorted (8,539) - no sorting overhead.
        \item \textbf{Moderate:} Indexed Nested-Loop with small outer (12,763).
        \item \textbf{Avoid:} Block Nested-Loop (28,513) - only use when no index/memory.
    \end{itemize}

    % ----------------------------------------------------------------------------
    % JOIN ORDER OPTIMIZATION
    % ----------------------------------------------------------------------------
    \subsubsection{Join Order \& Left-Deep Trees}

    \paragraph{Optimization Decisions}
    \begin{itemize}[leftmargin=*, label={--}]
        \item \textbf{Choose Join Order:} Most critical decision for multi-way joins.
        \newline \textit{Problem:} $n$ relations have $n!$ possible join orders (exponential search space).
        \newline \textit{Selectivity Estimation:} $js \approx 1/\max(V(A,r), V(B,s))$ (assumption: uniform distribution, no correlation).
        \newline \textit{Join Cardinality:} $jc = js \times |R| \times |S|$ - estimate intermediate result size.
        \newline \textit{Strategy - Dynamic Programming:} Build optimal plans bottom-up:
        \begin{enumerate}[nosep]
            \item Find best access path for each base relation (1-way plans).
            \item Find best plan to join any 2 relations (2-way plans).
            \item Find best plan to join any 3 relations using optimal 2-way plans (3-way plans).
            \item Continue until $n$-way plan found.
        \end{enumerate}
        \textit{Cost Principle:} If $(R \bowtie S)$ is part of optimal plan, then plan for $(R \bowtie S)$ must itself be optimal.
    \end{itemize}

    \paragraph{Left-Deep Trees}
    \textit{Common constraint in cost-based optimization to reduce search space while enabling efficient pipelined execution.}
    \begin{itemize}[leftmargin=*, label={--}]
        \item \textbf{Structure:} In left-deep tree, right child of each join is always base relation (leaf), never intermediate result.
        \newline \textit{Example:} $((R \bowtie S) \bowtie T) \bowtie U$ - left-deep. $(R \bowtie S) \bowtie (T \bowtie U)$ - bushy (not left-deep).
        \item \textbf{Benefits:} 
        \begin{itemize}
            \item \textit{Index Availability:} Right child is base table $\rightarrow$ can use indices on right child for indexed nested-loop join.
            \item \textit{Reduced Search Space:} Only $n!$ left-deep trees for $n$ relations vs $O(4^n)$ for all bushy trees.
            \newline System R optimizer: 4-table join searches 24 plans instead of 256.
            \item \textit{Pipelining-Friendly:} Left-deep trees naturally support pipelined evaluation (see Evaluation section).
            \newline Tuples flow from one operation to next without materializing intermediate results to disk.
        \end{itemize}
        \item \textbf{Trade-off:} May miss optimal bushy tree, but optimization time reduction + pipelining benefits usually outweigh this.
        \newline \textit{Modern Systems:} Some optimizers (PostgreSQL, Oracle) consider limited bushy trees for specific patterns.
    \end{itemize}

    % ============================================================================
    % PHASE 3: QUERY EVALUATION
    % ============================================================================
    \subsection{Phase 3: Query Evaluation}

    \subsubsection{Evaluation Primitives}
    \textit{Query-execution engine implements chosen execution plan using low-level evaluation primitives.}
    \begin{itemize}[leftmargin=*, label={--}]
        \item \textbf{Annotated Operations:} Each relational operation in plan annotated with:
        \begin{itemize}
            \item \textit{Algorithm choice:} e.g., "use hash join", "use index nested-loop", "use external merge-sort".
            \item \textit{Access method:} e.g., "use B+-tree index on salary", "use file scan on instructor".
            \item \textit{Buffer allocation:} How many memory buffers allocated to this operation.
        \end{itemize}
        \item \textbf{Iterator Model (Volcano/Pipeline):} Each operator implements:
        \begin{itemize}
            \item \texttt{open()}: Initialize operator state, allocate resources.
            \item \texttt{next()}: Return next tuple (on-demand production).
            \item \texttt{close()}: Clean up, release resources.
        \end{itemize}
        \textit{Composition:} Parent operator calls \texttt{next()} on child operators to pull tuples up the tree.
    \end{itemize}

    \subsubsection{Materialization vs Pipelining}
    \textit{Two fundamental strategies for evaluating expression trees.}

    \paragraph{Materialization (Eagerly Evaluate Subexpressions)}
    \begin{itemize}[leftmargin=*, label={--}]
        \item \textbf{Strategy:} Evaluate operations one at a time, bottom-up. Store complete result of each operation as temporary relation on disk before executing next operation.
        \item \textbf{Process:}
        \begin{enumerate}[nosep]
            \item Evaluate lowest-level operations (selections on base relations).
            \item Write complete intermediate result to temporary file.
            \item Read temporary file as input to next operation.
            \item Repeat until root operation completes.
        \end{enumerate}
        \item \textbf{Advantages:}
        \begin{itemize}
            \item Simple to implement - each operation independent.
            \item Intermediate results reusable if needed multiple times.
            \item Works for all operation types.
        \end{itemize}
        \item \textbf{Disadvantages:}
        \begin{itemize}
            \item \textit{High I/O Cost:} Write + read temporary file for each intermediate result.
            \item \textit{Delayed Results:} Cannot produce output until all subexpressions evaluated.
            \item \textit{Disk Space:} Requires storage for potentially large temporary relations.
        \end{itemize}
        \item \textbf{Example Cost:} Query with 5 operations $\rightarrow$ 4 temporary relations written + read = 8 extra disk operations.
    \end{itemize}

    \paragraph{Pipelining (On-Demand Evaluation)}
    \begin{itemize}[leftmargin=*, label={--}]
        \item \textbf{Strategy:} Pass tuples from one operation to next \textbf{without} storing intermediate results on disk. Operations combined into pipeline that runs concurrently.
        \item \textbf{Mechanism:} When parent operation needs tuple, it calls \texttt{next()} on child operation:
        \begin{itemize}
            \item Child produces tuple $\rightarrow$ parent processes it $\rightarrow$ may produce output tuple.
            \item Tuples flow through pipeline one-at-a-time or in small batches.
        \end{itemize}
        \item \textbf{Demand-Driven (Pull Model):} Root pulls tuples from children, children pull from their children (iterator model).
        \newline \textit{Alternative - Producer-Driven (Push):} Each operation pushes tuples to parent as produced.
        \item \textbf{Advantages:}
        \begin{itemize}
            \item \textit{Eliminate I/O:} No temporary file writes/reads for intermediate results.
            \item \textit{Fast First Results:} System can start returning query results before complete evaluation finished.
            \item \textit{Memory Efficiency:} Only small buffer of tuples in memory, not entire intermediate relation.
        \end{itemize}
        \item \textbf{Limitations (Pipeline Breakers):} Some operations require entire input before producing output:
        \begin{itemize}
            \item \textit{Sorting:} Must read all tuples to determine sort order.
            \item \textit{Aggregation (GROUP BY):} Must see all tuples in group to compute aggregate.
            \item \textit{Hash Join (Build Phase):} Must build complete hash table from inner relation.
        \end{itemize}
        \textit{Solution:} Use materialization for pipeline-breaking operations, pipelining elsewhere.
        \item \textbf{Left-Deep Trees \& Pipelining:} Left-deep join trees enable long pipelines:
        \newline Indexed nested-loop join: Outer tuples pipeline through join without materialization.
        \newline Right child always base table $\rightarrow$ can use index lookups efficiently.
    \end{itemize}

    \paragraph{Hybrid Approach (Modern DBMS)}
    \begin{itemize}[leftmargin=*, label={--}]
        \item \textbf{Strategy:} Combine both techniques - use pipelining where possible, materialize when necessary.
        \item \textbf{Example Query:} $\pi_{dept\_name, avg\_salary}(\sigma_{year=2017}(instructor) \bowtie department)$
        \begin{enumerate}[nosep]
            \item \textit{Pipeline:} File scan on instructor $\rightarrow$ selection $\rightarrow$ join (if indexed nested-loop).
            \item \textit{Materialize:} Join result temporarily stored (needed for aggregation).
            \item \textit{Pipeline:} Aggregation $\rightarrow$ projection to final output.
        \end{enumerate}
        \item \textbf{Optimization Decision:} Optimizer estimates cost/benefit:
        \begin{itemize}
            \item If intermediate result small $\rightarrow$ materialize (faster subsequent access).
            \item If intermediate result large + used once $\rightarrow$ pipeline (save I/O).
        \end{itemize}
    \end{itemize}

    \begin{center}
        \includegraphics[width=1\linewidth, keepaspectratio]{./images/sql_execution_order.png} \\
        \footnotesize \textit{(SQL Execution Order)}
    \end{center}

    % ============================================================================
    % SECTION: Big Data & Data Engineering
    % ============================================================================
    \section{Big Data \& Data Engineering}

    % ============================================================================
    % TIER 1: FOUNDATIONAL CONCEPTS
    % ============================================================================
    \subsection{Đặc trưng Big Data (The Vs)}
    \begin{itemize}[leftmargin=*, label={--}]
        \item \textbf{5V Cốt lõi (Core):}
        \begin{itemize}
            \item \textbf{Volume:} Dung lượng khổng lồ (TB, PB, ZB).
            \item \textbf{Velocity:} Tốc độ sinh ra \& xử lý (Batch $\to$ Streaming).
            \item \textbf{Variety:} Đa dạng định dạng (Structured, JSON, Video, Log).
            \item \textbf{Veracity:} Độ tin cậy, tính xác thực (Messy/Noisy data).
            \item \textbf{Value:} Giá trị chuyển hóa thành lợi ích kinh doanh.
        \end{itemize}
        
        \item \textbf{Các V Mở rộng (Extended):}
        \begin{itemize}
            \item \textbf{Variability:} Tính biến thiên (Ý nghĩa dữ liệu thay đổi theo ngữ cảnh/thời gian).
            \item \textbf{Validity:} Tính hợp lệ (Dữ liệu có đúng định dạng/chuẩn để dùng không).
            \item \textbf{Vulnerability:} Tính bảo mật (Dễ bị tấn công/rò rỉ).
            \item \textbf{Volatility:} Độ bay hơi (Thời gian lưu trữ trước khi xóa/lưu trữ lâu dài).
            \item \textbf{Visualization:} Khả năng trực quan hóa (Để con người hiểu được).
        \end{itemize}
    \end{itemize}

    \columnbreak

    \subsection{Paradigm: Batch vs Streaming}
    \textit{Hai mô hình xử lý dữ liệu cơ bản trong Big Data.}
    \begin{center}
        \renewcommand{\arraystretch}{1.2}
        \begin{tabular}{@{} p{0.15\linewidth} | p{0.38\linewidth} | p{0.38\linewidth} @{}}
            \toprule
            & \textbf{Batch Processing} & \textbf{Streaming Processing} \\
            \midrule
            \textbf{Đặc trưng} & Xử lý dữ liệu tĩnh, lượng lớn theo lô. & Xử lý dữ liệu động, liên tục theo thời gian thực. \\
            \textbf{Độ trễ} & Cao (minutes - hours). & Thấp (seconds - milliseconds). \\
            \textbf{Công cụ} & Hadoop MapReduce, Apache Spark (Batch mode). & Apache Flink, Spark Streaming, Kafka Streams. \\
            \textbf{Use Case} & ETL, báo cáo cuối ngày, ML training. & Real-time analytics, fraud detection, monitoring. \\
            \textbf{Ưu điểm} & Xử lý hiệu quả khối lượng lớn, đơn giản. & Phản hồi nhanh, phát hiện sự kiện ngay lập tức. \\
            \textbf{Nhược điểm} & Không real-time, lãng phí khi data nhỏ. & Phức tạp, khó debug, cần xử lý out-of-order. \\
            \bottomrule
        \end{tabular}
    \end{center}
    \textbf{Kiến trúc Lai (Hybrid):}
    \begin{itemize}[leftmargin=*, label={--}]
        \item \textbf{Lambda Architecture:} Batch layer (chính xác) + Speed layer (real-time) + Serving layer. Phức tạp, duy trì 2 code base.
        \item \textbf{Kappa Architecture:} Chỉ dùng Streaming (đơn giản hóa). Mọi dữ liệu qua stream processor, replay từ Kafka khi cần.
    \end{itemize}

    \subsection{Partitioning \& Replication}
    
    \subsubsection{Sao chép (Replication)}
    \textit{Mục đích: High Availability (HA) và giảm độ trễ đọc.}
    \begin{itemize}[leftmargin=*, label={--}]
        \item \textbf{Single-Leader (Master-Slave):} Mọi ghi vào Leader, Leader chép sang Followers. \textit{Dễ nhất quán, nhưng Leader là nút cổ chai.}
        \item \textbf{Multi-Leader:} Nhiều node chấp nhận ghi. \textit{Tốt cho đa trung tâm dữ liệu, nhưng khó xử lý xung đột.}
        \item \textbf{Leaderless (Dynamo-style):} Ghi/Đọc gửi tới nhiều node. Dùng cơ chế \textbf{Quorum} để xác nhận:
        \newline $w + r > n$ (Write nodes + Read nodes > Total replicas) $\rightarrow$ Đảm bảo đọc thấy dữ liệu mới nhất.
    \end{itemize}

    \subsubsection{Phân mảnh (Partitioning/Sharding)}
    \textit{Mục đích: Scalability (Mở rộng dung lượng/băng thông).}
    \begin{itemize}[leftmargin=*, label={--}]
        \item \textbf{Key Range Partitioning:} Chia theo khoảng khóa (A-C, D-F). 
        \newline $\rightarrow$ \textit{Ưu:} Query theo khoảng (Range scan) hiệu quả. 
        \newline $\rightarrow$ \textit{Nhược:} Dễ bị \textit{Hotspot} (nếu user dồn vào vần A).
        \item \textbf{Hash Partitioning:} Băm khóa để chia đều ($hash(key) \% N$).
        \newline $\rightarrow$ \textit{Ưu:} Phân phối đều, tránh Hotspot.
        \newline $\rightarrow$ \textit{Nhược:} Mất khả năng Range Query (phải quét tất cả).
    \end{itemize}

    \columnbreak

    \subsection{Định dạng Lưu trữ (File Formats)}
    \textit{Lựa chọn định dạng ảnh hưởng trực tiếp đến hiệu năng đọc/ghi.}
    
    \subsubsection{Row-based vs. Column-based}
    \begin{itemize}[leftmargin=*, label={--}]
        \item \textbf{Row-oriented (CSV, Avro):}
        \begin{itemize}
            \item Lưu trữ tuần tự từng dòng.
            \item \textit{Ưu điểm:} Ghi nhanh (append), tốt khi truy xuất toàn bộ thông tin của 1 entity (OLTP).
            \item \textit{Nhược điểm:} Chậm khi tính toán tổng hợp (SUM, AVG) vì phải đọc cả dữ liệu không cần thiết.
        \end{itemize}
        \item \textbf{Column-oriented (Parquet, ORC):}
        \begin{itemize}
            \item Lưu trữ riêng biệt từng cột.
            \item \textit{Ưu điểm:} Nén cực tốt (do dữ liệu cùng kiểu), tối ưu cho OLAP (chỉ đọc cột cần thiết).
            \item \textit{Nhược điểm:} Ghi chậm, update tốn kém.
        \end{itemize}
    \end{itemize}

    \subsubsection{So sánh Avro, Parquet, ORC}
    \begin{center}
    \renewcommand{\arraystretch}{1.1}
    \begin{tabular}{@{} l l l @{}}
        \toprule
        \textbf{Đặc điểm} & \textbf{Avro} & \textbf{Parquet} \\
        \midrule
        \textbf{Mô hình} & Row-based & Column-based \\
        \textbf{Schema} & JSON (lưu trong file) & Binary (footer) \\
        \textbf{Tối ưu cho} & Ghi nhiều (Write heavy) & Đọc nhiều (Read heavy) \\
        \textbf{Schema Evo} & Rất tốt (Thêm/bớt field) & Hạn chế \\
        \textbf{Ecosystem} & Kafka, Hadoop & Spark, Impala, Presto \\
        \bottomrule
    \end{tabular}
    \end{center}

    % ============================================================================
    % TIER 2: STORAGE LAYER
    % ============================================================================
    \subsection{Hadoop Ecosystem}
    \textit{Open-source framework for distributed storage and processing.}
    \begin{enumerate}[leftmargin=*, label={\textbf{\arabic*.}}]
        \item \textbf{HDFS (Storage):} Distributed file system.
        \begin{itemize}
            \item \textit{NameNode:} Manages metadata (block locations).
            \item \textit{DataNode:} Stores actual data blocks.
            \item \textit{Mechanism:} Splits files into blocks (128MB), replicates (x3) for fault tolerance.
        \end{itemize}
        \item \textbf{YARN (Resource Management):} "Operating system" of the cluster.
        \begin{itemize}
            \item Distributes resources (RAM, CPU) to applications.
            \item Allows multiple engines (Spark, MapReduce) to run on the same cluster.
        \end{itemize}
        \item \textbf{MapReduce (Processing):} Batch processing model - divide and conquer on a distributed cluster.
        \begin{itemize}
            \item \textit{Map:} Chia nhỏ \& Gán nhãn. Input $\rightarrow$ Split $\rightarrow$ \texttt{<Key, Value>}.
            \item \textit{Shuffle:} Xáo trộn \& Gom nhóm. Chuyển dữ liệu qua mạng, gom cùng Key.
            \item \textit{Reduce:} Tổng hợp. Xử lý danh sách Value của mỗi Key.
        \end{itemize}
    \end{enumerate}

    \columnbreak

    \subsection{Công nghệ NoSQL (Storage Tech)}
    \textit{Các mô hình NoSQL cho use case khác nhau.}

    \paragraph{MongoDB (Document Store)}
    \begin{itemize}[leftmargin=*, label={--}]
        \item \textbf{Mô hình:} Schema-on-read, lưu trữ JSON/BSON documents. Collections thay vì tables.
        \item \textbf{Ưu điểm:} Linh hoạt schema (mỗi doc có cấu trúc khác nhau), dễ scale horizontal (sharding), query mạnh (aggregation pipeline).
        \item \textbf{Architecture:} Replica Sets (HA), Sharding (scale-out), WiredTiger storage engine.
        \item \textbf{Use Case:} CMS, Mobile apps, Catalog, Real-time analytics. \textit{VD: Forbes, eBay, Uber.}
        \item \textbf{Trade-offs:} Không ACID cross-document (trước v4.0), chiếm RAM nhiều.
    \end{itemize}

    \paragraph{Redis (Key-Value Store)}
    \begin{itemize}[leftmargin=*, label={--}]
        \item \textbf{Mô hình:} In-memory key-value, data structures (String, Hash, List, Set, Sorted Set).
        \item \textbf{Ưu điểm:} Cực nhanh ($<1$ms latency), atomic operations, support pub/sub, Lua scripting.
        \item \textbf{Persistence:} RDB (snapshot) hoặc AOF (append-only log). Có thể dùng cả 2.
        \item \textbf{Use Case:} Caching (session, query result), Message Queue (Celery), Leaderboard, Rate limiting. \textit{VD: Twitter, GitHub, Stack Overflow.}
        \item \textbf{Trade-offs:} Giới hạn RAM, single-threaded (1 core), không có query phức tạp.
    \end{itemize}

    \paragraph{Cassandra (Wide-Column Store)}
    \begin{itemize}[leftmargin=*, label={--}]
        \item \textbf{Mô hình:} Wide-column, mỗi row có thể có số cột khác nhau. Organize theo Column Family.
        \item \textbf{Ưu điểm:} Ghi cực nhanh (LSM Tree), linear scalability, masterless (P2P), multi-datacenter replication.
        \item \textbf{Architecture:} Consistent hashing (ring), tunable consistency (quorum), compaction strategies.
        \item \textbf{Use Case:} Time-series data, IoT sensor logs, Event logging, Messaging. \textit{VD: Netflix, Apple, Instagram.}
        \item \textbf{Trade-offs:} Đọc chậm hơn (nhiều SSTable), không join, modeling phức tạp (query-first design).
    \end{itemize}

    \paragraph{Neo4j (Graph Database)}
    \begin{itemize}[leftmargin=*, label={--}]
        \item \textbf{Mô hình:} Nodes (entities) + Relationships (edges) + Properties. Native graph storage.
        \item \textbf{Ưu điểm:} Traversal cực nhanh (follow pointers), query trực quan (Cypher), ACID transactions.
        \item \textbf{Architecture:} Index-free adjacency (mỗi node chứa pointer đến neighbors).
        \item \textbf{Use Case:} Social networks, Recommendation engines, Fraud detection, Knowledge graphs. \textit{VD: LinkedIn, Walmart, eBay.}
        \item \textbf{Trade-offs:} Scale khó hơn NoSQL khác, không tốt cho bulk data processing.
    \end{itemize}

    \columnbreak
    % ============================================================================
    % TIER 3: PROCESSING LAYER
    % ============================================================================
    \subsection{Batch Processing}

    \subsubsection{Apache Spark (Unified Analytics Engine)}
    \textit{Thay thế MapReduce với tốc độ cao hơn 100x (in-memory).}
    \begin{itemize}[leftmargin=*, label={--}]
        \item \textbf{Core Concept:} RDD (Resilient Distributed Dataset) - immutable, partitioned, parallel.
        \begin{itemize}
            \item \textit{Transformations:} Lazy (map, filter, join) - tạo DAG.
            \item \textit{Actions:} Eager (collect, count, save) - trigger execution.
        \end{itemize}
        \item \textbf{Components:}
        \begin{itemize}
            \item \textit{Spark SQL:} Query structured data (DataFrame/Dataset API).
            \item \textit{Spark Streaming:} Micro-batch streaming (DStream).
            \item \textit{MLlib:} Machine learning library (classification, clustering, etc.).
            \item \textit{GraphX:} Graph processing (PageRank, connected components).
        \end{itemize}
        \item \textbf{Ưu điểm:} In-memory caching, lazy evaluation, DAG optimization, unified API (batch + streaming).
        \item \textbf{Nhược điểm:} Tốn RAM, không true streaming (micro-batch), overhead cho job nhỏ.
        \item \textbf{Use Case:} ETL, ML training, interactive analytics, log processing. \textit{VD: Netflix, Uber, Airbnb.}
    \end{itemize}

    \subsubsection{Big Data Warehousing / SQL-on-Hadoop}
    \textit{Các công cụ SQL Analytics cho Big Data - phân biệt với NoSQL operational stores.}
    \begin{itemize}[leftmargin=*, label={--}]
        \item \textbf{Apache Hive:} SQL-on-Hadoop, metadata layer trên HDFS. Batch-oriented, high latency.
        \item \textbf{Google BigQuery:} Serverless, columnar storage (Dremel), auto-scaling, pay-per-query.
        \item \textbf{AWS Redshift:} Managed columnar DW, massively parallel processing (MPP).
        \item \textbf{Snowflake:} Cloud-native DW, tách biệt storage/compute, near-zero admin.
        \item \textbf{Presto/Trino:} Distributed SQL query engine, federated queries across data sources.
    \end{itemize}
    \textit{Phân biệt:} Các công cụ trên dùng cho \textbf{Analytics/OLAP}, khác với NoSQL (MongoDB, Cassandra) dùng cho \textbf{Operational/OLTP}.

    % --- PHẦN 4: XỬ LÝ LUỒNG (STREAMING) ---
    \subsection{Streaming Processing}
    \textit{Xử lý dữ liệu liên tục, độ trễ thấp (Real-time).}
    
    \subsubsection{Các chiến lược xử lý (Strategies)}
    \begin{itemize}[leftmargin=*, label={--}]
        \item \textbf{Thời gian (Time Domain):}
        \begin{itemize}
            \item \textit{Event Time:} Thời gian sự kiện xảy ra (quan trọng nhất).
            \item \textit{Processing Time:} Thời gian hệ thống nhận được dữ liệu.
            \item \textit{Watermark:} Cơ chế xử lý độ trễ (data đến muộn) trong Event Time.
        \end{itemize}
        \item \textbf{Cửa sổ (Windowing):}
        \begin{itemize}
            \item \textit{Tumbling:} Cố định, không chồng (vd: mỗi 5p).
            \item \textit{Hopping/Sliding:} Có chồng lấp (vd: 5p, trượt mỗi 1p).
            \item \textit{Session:} Dựa trên hoạt động người dùng (hết timeout thì đóng).
        \end{itemize}
        \item \textbf{Đảm bảo (Guarantees):}
        \begin{itemize}
            \item \textit{At-most-once:} Gửi 1 lần, chấp nhận mất (vd: Log).
            \item \textit{At-least-once:} Không mất, chấp nhận trùng lặp.
            \item \textit{Exactly-once:} Chính xác 1 lần (Khó nhất, cần Flink/Kafka).
        \end{itemize}
    \end{itemize}

    \columnbreak

    % ============================================================================
    % TIER 4: INTEGRATION & ORCHESTRATION
    % ============================================================================
    \subsection{Giao thức IoT (IoT Protocols)}
    \subsubsection{MQTT (Message Queue Telemetry Transport)}

    \paragraph{Design Philosophy}\mbox{}\\
    Được thiết kế cho \textbf{constrained devices (thiết bị hạn chế)} trong môi trường mạng khó khăn:
    \begin{itemize}[leftmargin=*, label={--}]
        \item \textbf{Low bandwidth (băng thông thấp):} Minimized data packets (gói dữ liệu tối thiểu).
        \item \textbf{High latency (độ trễ cao):} Tối ưu cho mạng chậm.
        \item \textbf{Unreliable networks (mạng không ổn định):} Xử lý mất kết nối, chập chờn.
        \item \textbf{Low power usage:} Tiết kiệm pin cho IoT devices.
        \item \textbf{Real-time processing:} Hỗ trợ xử lý real-time cho streaming data.
    \end{itemize}

    \paragraph{Architecture: Publish-Subscribe Model}\mbox{}\\
    Khác với client-server truyền thống (client connect trực tiếp client), MQTT dùng \textbf{pub-sub model}.
    \begin{itemize}[leftmargin=*, label={--}]
        \item \textbf{Broker:} Central component nhận published messages và deliver đến subscribers phù hợp.
        \newline \textit{Flow:} Client gửi \texttt{CONNECT} $\rightarrow$ Broker trả \texttt{CONNACK}.
        \item \textbf{Publisher:} Client publish message đến broker với specific topic.
        \item \textbf{Subscriber:} Client listen incoming messages trên particular topics.
        \item \textbf{Advantage:} Decoupling (tách rời) - publisher không cần biết subscriber, scale dễ dàng.
    \end{itemize}

    \paragraph{Topics (Routing Mechanism)}\mbox{}\\
    \textbf{Structure:} Hierarchical strings với topic levels phân cách bởi \texttt{/}.
    \begin{center}
        \renewcommand{\arraystretch}{1.15}
        \begin{tabular}{@{} p{0.15\linewidth} | l | p{0.50\linewidth} @{}}
            \toprule
            \textbf{Type} & \textbf{Pattern} & \textbf{Matches \& Description} \\
            \midrule
            \textbf{Exact} & \texttt{area1/humidity} & Chỉ match chính xác topic này. \textit{Use:} Specific sensor. \\
            \addlinespace[2pt]
            \textbf{Single-level} & \texttt{area1/+} & \texttt{+} matches \textit{1} level bất kỳ.\newline $\checkmark$ \texttt{area1/humidity}, \texttt{area1/light}\newline $\times$ \texttt{area1/sensors/temp} \\
            \addlinespace[2pt]
            \textbf{Multi-level} & \texttt{area1/\#} & \texttt{\#} matches \textit{tất cả} levels.\newline $\checkmark$ \texttt{area1/humidity}, \texttt{area1/sensors/temp}\newline $\checkmark$ \texttt{area1/zone2/light} \\
            \addlinespace[2pt]
            \textbf{Root wildcard} & \texttt{\#} & Matches \textit{everything} in broker.\newline (Use with caution - high load) \\
            \bottomrule
        \end{tabular}
    \end{center}
    \textit{Smart Farming Example:} Publisher sends \texttt{area1/humidity:65\%} $\rightarrow$ Subscribers với patterns \texttt{area1/humidity}, \texttt{area1/+}, hoặc \texttt{area1/\#} đều nhận được.

    \columnbreak

    \paragraph{Quality of Service (QoS) Levels}\mbox{}\\
    Để xử lý network reliability khác nhau, MQTT định nghĩa 3 QoS levels:
    \begin{center}
        \renewcommand{\arraystretch}{1.15}
        \begin{tabular}{@{} c | l | p{0.55\linewidth} @{}}
            \toprule
            \textbf{Level} & \textbf{Guarantee} & \textbf{Mechanism \& Use Case} \\
            \midrule
            \textbf{0} & At most once & Delivered once, no confirmation. Fast, có thể mất message. \textit{Use:} Sensor readings không critical. \\
            \textbf{1} & At least once & Delivered ít nhất 1 lần, requires confirmation (ACK). Có thể duplicate. \textit{Use:} Important data. \\
            \textbf{2} & Exactly once & Four-step handshake. Chậm nhất nhưng không duplicate. \textit{Use:} Financial transactions, critical commands. \\
            \bottomrule
        \end{tabular}
    \end{center}
    \textit{Note:} Actual QoS = min(Publisher QoS, Subscriber QoS).

    \paragraph{Practical Application: Smart Farming}
    \begin{itemize}[leftmargin=*, label={--}]
        \item \textbf{Sensors (Publishers):}
        \begin{itemize}
            \item \textit{DHT11:} Temperature \& air humidity.
            \item \textit{BH1750:} Luminosity (độ sáng).
            \item \textit{DHT22:} Soil moisture (độ ẩm đất).
        \end{itemize}
        \item \textbf{Flow:} Sensors publish data đến broker với topics như \texttt{area1/moisture} $\rightarrow$ Management system subscribes topics $\rightarrow$ Real-time monitoring \& decision making.
        \item \textbf{Benefits:} Cost-effective, scalable, knowledge base creation cho farming management.
    \end{itemize}
    
    \subsubsection{MQTT vs HTTP Comparison}
    \begin{center}
        \renewcommand{\arraystretch}{1.2}
        \begin{tabular}{p{0.2\linewidth} | p{0.3\linewidth} | p{0.40\linewidth} @{}}
            \toprule
            \textbf{Aspect} & \textbf{HTTP} & \textbf{MQTT} \\
            \midrule
            \textbf{Model} & Request-Response\newline (Client-Server) & Publish-Subscribe\newline (qua Broker) \\
            \addlinespace[2pt]
            \textbf{Connection} & Short-lived\newline (đóng sau request) & Persistent\newline (Keep-alive, lightweight) \\
            \addlinespace[2pt]
            \textbf{Header Size} & Large (KB range)\newline Cồng kềnh metadata & Very small (2 bytes)\newline Tiết kiệm bandwidth \\
            \addlinespace[2pt]
            \textbf{Power} & High consumption & Low power\newline (tối ưu battery devices) \\
            \addlinespace[2pt]
            \textbf{Network} & Reliable networks & Unreliable networks\newline (chập chờn, high latency) \\
            \addlinespace[2pt]
            \textbf{Use Cases} & • Web browsing\newline • REST APIs\newline • Large file transfers & • IoT sensors\newline • M2M communication\newline • Constrained devices \\
            \bottomrule
        \end{tabular}
    \end{center}
    \textit{Key Insight:} HTTP designed cho human-to-machine (web), MQTT designed cho machine-to-machine (IoT).

    % --- PHẦN 5: PIPELINES & ORCHESTRATION ---
    \subsection{Pipelines \& Orchestration}
    
    \subsubsection{Apache Kafka vs Airflow}
    \begin{center}
        \renewcommand{\arraystretch}{1.2} % Adjust row height for readability
        \begin{tabular}{@{} >{\raggedright\arraybackslash}p{0.48\linewidth} >{\raggedright\arraybackslash}p{0.48\linewidth} @{}}
            \toprule
            \textbf{Apache Kafka} & \textbf{Apache Airflow} \\
            \midrule
            
            \textbf{Loại:} Event Streaming Platform (Message Broker). & 
            \textbf{Loại:} Workflow Orchestration (Quản lý quy trình). \\
            \addlinespace[4pt] % Extra space between sections
            
            \textbf{Đặc trưng:}
            \begin{itemize}[leftmargin=10pt, nosep, label=\tiny$\bullet$]
                \item Log bền vững (Durable log).
                \item Decoupling (Tách rời).
                \item Replayable, High throughput.
            \end{itemize} & 
            \textbf{Đặc trưng:}
            \begin{itemize}[leftmargin=10pt, nosep, label=\tiny$\bullet$]
                \item Code-as-infra (Python DAGs).
                \item Quản lý dependency phức tạp.
                \item Backfill (chạy lại quá khứ).
            \end{itemize} \\
            \addlinespace[4pt]
            
            \textbf{Vai trò:} "Xương sống" vận chuyển dữ liệu \textit{Real-time}. & 
            \textbf{Vai trò:} "Nhạc trưởng" điều phối Job (\textit{Batch/ETL}). \\
            \bottomrule
        \end{tabular}
    \end{center}

    \subsubsection{CDC (Change Data Capture)}
    \textit{Theo dõi và đồng bộ thay đổi từ database nguồn sang đích.}
    \begin{itemize}[leftmargin=*, label={--}]
        \item \textbf{Mục đích:} Real-time data replication, sync giữa OLTP và OLAP, event-driven architecture.
        \item \textbf{Cơ chế:}
        \begin{itemize}
            \item \textit{Log-based CDC:} Đọc database transaction log (binlog MySQL, WAL PostgreSQL). \textbf{Tốt nhất} - không ảnh hưởng source.
            \item \textit{Trigger-based:} Trigger trên INSERT/UPDATE/DELETE. Ảnh hưởng performance.
            \item \textit{Timestamp/Version-based:} Poll dựa trên \texttt{updated\_at} column. Thiếu DELETE events.
        \end{itemize}
        \item \textbf{Tools:} Debezium (Kafka Connect), AWS DMS, Oracle GoldenGate, Airbyte.
        \item \textbf{Use Case:} Sync OLTP $\to$ DW, Microservices data sharing, Cache invalidation, Audit logs.
        \item \textbf{Pattern:} Source DB $\to$ CDC Tool $\to$ Kafka $\to$ Sink (DW/Cache/Search).
    \end{itemize}

    \subsubsection{ETL vs ELT}
    \begin{itemize}[leftmargin=*, label={--}]
        \item \textbf{ETL (Extract-Transform-Load):} Transform \textit{trước} khi vào kho. Schema-on-write. Dữ liệu sạch, bảo mật. (Truyền thống).
        \item \textbf{ELT (Extract-Load-Transform):} Load raw vào kho \textit{trước}, transform sau. Schema-on-read. Tận dụng sức mạnh Cloud DW (BigQuery, Snowflake). (Hiện đại).
    \end{itemize}

    \paragraph{Common ETL Logic Patterns}
    \textit{Các pattern phổ biến khi thiết kế ETL flow (cho luận văn/essay).}
    \begin{itemize}[leftmargin=*, label={--}]
        \item \textbf{Soft Deletes:} Nếu source có cờ \texttt{is\_deleted}, lọc bỏ trong Extract, hoặc load vào DW với \texttt{Status = 'Inactive'} trong dimension (không xóa row khỏi Fact table).
        \item \textbf{Date Derivation:} Luôn mở rộng cột \texttt{Date} đơn giản thành \textbf{Date Dimension} đầy đủ (Day, Week, Month, Quarter, Year, HolidayFlag).
        \item \textbf{Calculated Measures:} Tính toán như \texttt{Revenue = Price * Quantity} trong giai đoạn \textbf{Transform}, lưu vào Fact table để aggregation nhanh.
        \item \textbf{SCD for Price Changes:} Khi \texttt{Item\_price} thay đổi, dùng \textbf{Type 2 SCD} trong dimension hoặc snapshot fact table để lưu lịch sử giá.
    \end{itemize}

    \columnbreak
    % ============================================================================
    % TIER 5: ANALYTICS & WAREHOUSING
    % ============================================================================
    \subsection{Kho Dữ liệu (Data Warehousing)}

    \subsubsection{OLTP vs OLAP}
    \begin{center}
        \renewcommand{\arraystretch}{1.2}
        \begin{tabular}{@{} p{0.15\linewidth} | p{0.38\linewidth} | p{0.38\linewidth} @{}}
            \toprule
            & \textbf{OLTP (Transactional)} & \textbf{OLAP (Analytical)} \\
            \midrule
            \textbf{Mục tiêu} & Vận hành hàng ngày (Operational). & Ra quyết định (Decision support). \\
            \textbf{Dữ liệu} & Hiện hành, chi tiết, cập nhật liên tục. & Lịch sử, tổng hợp, đa chiều. \\
            \textbf{Truy vấn} & Đơn giản, trả về ít dòng (Lookup). & Phức tạp, join nhiều, quét bảng lớn. \\
            \textbf{Thiết kế} & Chuẩn hóa cao (3NF) để tránh dị thường. & Phi chuẩn hóa (Star/Snowflake) để đọc nhanh. \\
            \textbf{User} & NV, App, Khách hàng. & Manager, Data Analyst. \\
            \bottomrule
        \end{tabular}
    \end{center}

    \paragraph{OLAP Data Cube Operations}
    \textit{Thao tác trên khối dữ liệu đa chiều (Dimensions: Product, Time, Location, ...).}
    \begin{itemize}[leftmargin=*, label={--}]
        \item \textbf{Slice:} Cố định 1 dimension, xem ma trận 2D còn lại.
        \newline \textit{VD:} Slice Year=2024 $\rightarrow$ Xem doanh thu theo (City, Product) cho năm 2024.
        \item \textbf{Dice:} Chọn sub-cube với nhiều điều kiện trên nhiều dimensions.
        \newline \textit{VD:} Dice (Year $\in$ [2023,2024], City $\in$ [HCM, HN]) $\rightarrow$ Sub-cube 2x2.
        \item \textbf{Roll-up (Drill-up):} Tổng hợp lên mức cao hơn (chi tiết $\to$ tổng quát).
        \newline \textit{VD:} Roll-up từ City $\to$ Region $\to$ Country.
        \item \textbf{Drill-down:} Phân rã xuống mức chi tiết hơn (tổng quát $\to$ chi tiết).
        \newline \textit{VD:} Drill-down từ Year $\to$ Quarter $\to$ Month $\to$ Day.
        \item \textbf{Pivot (Rotate):} Xoay trục để thay đổi góc nhìn.
        \newline \textit{VD:} Đổi trục X từ Product sang Time.
    \end{itemize}

    \subsubsection{4 Đặc trưng Chính (Inmon)}
    \begin{enumerate}[leftmargin=*, label={\textbf{\arabic*.}}]
        \item \textbf{Hướng chủ đề (Subject-oriented):} Tổ chức theo chủ đề chính (Khách hàng, Sản phẩm) thay vì theo ứng dụng (App Bán hàng, App Kho).
        \item \textbf{Tích hợp (Integrated):} Dữ liệu từ nhiều nguồn được làm sạch, đồng nhất (đơn vị, format, encoding) trước khi nạp.
        \item \textbf{Bất biến (Non-volatile):} Dữ liệu đã vào DW thì (thường) không bị sửa/xóa, chỉ đọc.
        \item \textbf{Biến thiên theo thời gian (Time-variant):} Mọi dữ liệu đều gắn với mốc thời gian để phân tích xu hướng (Historical data).
    \end{enumerate}

    \subsubsection{Thách thức Xây dựng DW}
    \begin{itemize}[leftmargin=*, label={--}]
        \item \textbf{Data Quality:} "Garbage In, Garbage Out". Dữ liệu nguồn bẩn làm sai lệch báo cáo.
        \item \textbf{ETL Complexity:} Tích hợp các hệ thống cũ (Legacy) rất phức tạp.
        \item \textbf{Performance:} Truy vấn phân tích tốn tài nguyên, cần tối ưu index/partition.
        \item \textbf{User Acceptance:} Người dùng không hiểu hoặc không tin tưởng dữ liệu.
        \item \textbf{Cost:} Chi phí lưu trữ và duy trì hạ tầng cao.
    \end{itemize}
    
    \subsubsection{Mô hình hóa (Modeling)}
    \begin{itemize}[leftmargin=*, label={--}]
        \item \textbf{Star Schema:} Fact ở giữa, Dimension xung quanh. Phi chuẩn hóa dimension. \textit{Hiệu năng cao, dễ query.}
        \item \textbf{Snowflake Schema:} Chuẩn hóa dimension (tách nhỏ). \textit{Tiết kiệm không gian, join phức tạp.}
    \end{itemize}

    \paragraph{Fact Table Additivity}
    \textit{Phân loại measures theo khả năng aggregation.}
    \begin{center}
    \renewcommand{\arraystretch}{1.15}
    \begin{tabular}{@{} l | p{0.25\linewidth} | l | p{0.25\linewidth} @{}}
        \toprule
        \textbf{Type} & \textbf{Definition} & \textbf{Example} & \textbf{Rule} \\
        \midrule
        \textbf{Additive} & Có thể SUM qua \textbf{tất cả} dimensions. & Sales\_Amount, Quantity & SUM over Time? Yes. SUM over Store? Yes. \\
        \textbf{Semi-Additive} & Có thể SUM qua \textbf{một số} dimensions, \textbf{không} Time. & Account\_Balance, Inventory\_Level & SUM over Store? Yes. SUM over Time? \textbf{No}. \\
        \textbf{Non-Additive} & \textbf{Không} thể SUM qua bất kỳ dimension nào. & Unit\_Price, Margin\_Rate & Phải dùng AVG, MIN, MAX. \\
        \bottomrule
    \end{tabular}
    \end{center}

    \subsubsection{Kimball's 4-Step Dimensional Modeling}
    \textit{Phương pháp thiết kế DW theo Kimball (bottom-up, theo chủ đề nghiệp vụ).}
    \begin{enumerate}[leftmargin=*, label={\textbf{\arabic*.}}]
        \item \textbf{Select the Business Process:} Chọn quy trình nghiệp vụ cần phân tích.
        \newline \textit{VD:} Orders, Billing, Inventory, Shipments.
        \item \textbf{Declare the Grain:} Xác định mức chi tiết của mỗi row trong fact table.
        \newline \textit{VD:} One row per order line item, one row per transaction.
        \newline \textbf{Lưu ý:} Phải xác định grain \textbf{TRƯỚC} khi chọn dimensions/facts.
        \item \textbf{Identify the Dimensions:} Xác định các chiều phân tích (Who, What, Where, When).
        \newline \textit{VD:} dim\_customer, dim\_product, dim\_store, dim\_date.
        \item \textbf{Identify the Facts:} Xác định các measures/metrics (Số liệu đo lường).
        \newline \textit{VD:} quantity\_sold, revenue, discount\_amount, cost.
    \end{enumerate}

    \subsubsection{Schema Evolution Trade-offs}
    \textit{Khi yêu cầu thay đổi, có 2 chiến lược phổ biến để mở rộng schema DW.}
    \begin{itemize}[leftmargin=*, label={--}]
        \item \textbf{Strategy 1: Extend Star Schema (Add Columns to Dimension)}
        \begin{itemize}
            \item \textit{Pros:} Queries đơn giản hơn (không join mới), backward compatible.
            \item \textit{Cons:} Dimension table trở nên rất rộng (wide/fat dimension), tiềm ẩn redundancy và anomalies.
        \end{itemize}
        \item \textbf{Strategy 2: Convert to Snowflake (Normalize New Attributes)}
        \begin{itemize}
            \item \textit{Pros:} Tiết kiệm storage, cấu trúc rõ ràng hơn cho dữ liệu phân cấp (VD: Region $\to$ City).
            \item \textit{Cons:} Breaking Change - queries cũ cần sửa (thêm join mới), ETL phức tạp hơn (quản lý keys giữa các bảng normalized).
        \end{itemize}
    \end{itemize}

    \subsubsection{DW vs DL vs Lakehouse}
    \begin{itemize}[leftmargin=*, label={--}]
        \item \textbf{Data Warehouse:} Dữ liệu có cấu trúc, cho BI/Reporting.
        \item \textbf{Data Lake:} Dữ liệu thô (Raw), đa dạng, giá rẻ, cho ML/DS.
        \item \textbf{Lakehouse:} Kết hợp (Lưu trữ rẻ của Lake + Quản lý/ACID của Warehouse).
    \end{itemize}

    \subsubsection{SCD (Slowly Changing Dimensions)}
    \textit{Tại sao cần?} Để đảm bảo báo cáo lịch sử chính xác. Nếu KH chuyển từ HCM ra HN năm 2024, doanh số năm 2020 vẫn phải tính cho HCM.
    \begin{center}
        \renewcommand{\arraystretch}{1.2}
        \begin{tabular}{@{} c | p{0.32\linewidth} | p{0.5\linewidth} @{}}
            \toprule
            \textbf{Type} & \textbf{Chiến lược} & \textbf{Đặc điểm \& Use Case} \\
            \midrule
            \textbf{0} & \textbf{Retain Original:} Giữ nguyên, không bao giờ sửa. & 
            Dữ liệu gốc là chân lý. (VD: Ngày sinh). \\
            \hline
            \textbf{1} & \textbf{Overwrite:} Ghi đè giá trị mới lên cũ. & 
            Không cần lịch sử. Sửa lỗi chính tả. \\
            \hline
            \textbf{2} & \textbf{Add Row:} Add new row + \textit{Effective Date} + \textit{Current\_Flag}. & 
            \textbf{Most standard}. Track complete history of changes. \\
            \hline
            \textbf{3} & \textbf{Add Column:} Thêm cột \textit{Previous\_Value}. & 
            Chỉ cần biết giá trị liền trước. (Ít dùng). \\
            \hline
            \textbf{4} & \textbf{Add History Table:} Tách bảng lịch sử riêng (Mini-Dimension). & 
            Tối ưu khi bảng chính quá lớn và chỉ một nhóm thuộc tính thay đổi nhanh. \\
            \hline
            \textbf{5} & \textbf{Hybrid (4 + 1):} Mini-dimension + "Current" reference in main table. & 
            Optimize queries when need both detailed history and current value quickly. \\
            \hline
            \textbf{6} & \textbf{Hybrid (1 + 2 + 3):} Type 2 row + column containing current value (Type 1). & 
            \textit{"Pure Type 6"}: Helps query history while still easily group by current value. \\
            \hline
            \textbf{7} & \textbf{Hybrid (Dual Keys):} Fact table contains both \textit{Surrogate Key} (history) and \textit{Natural Key} (current). & 
            Most flexible: Join by Surrogate to view history, join by Natural to view current. \\
            \bottomrule
        \end{tabular}
            \textit{Các kỹ thuật xử lý dữ liệu thay đổi theo thời gian (0 $\to$ 7).}

    \end{center}

    \columnbreak

    % ============================================================================
    % TIER 6: DATA MANAGEMENT & OPERATIONAL
    % ============================================================================
    \subsection{Quản lý Dữ liệu}

    \subsubsection{Vấn đề Tích hợp (Data Integration Issues)}
    \begin{itemize}[leftmargin=*, label={--}]
        \item \textbf{Heterogeneous data sources:} Khác biệt về hệ quản trị cơ sở dữ liệu và định dạng tệp.
        \newline \textit{VD: MySQL, PostgreSQL, Oracle, MongoDB, CSV, JSON, XML, Parquet.}
        
        \item \textbf{Data Mapping:} Khác biệt về cấu trúc schema giữa các nguồn.
        \newline \textit{VD: Bảng `Employee' (Full\_Name, DOB) vs `Emp' (First\_Name, Last\_Name, Birth\_Date).}
        
        \item \textbf{Data Conflicts:} Conflicts in data type, value, format, unit, precision.
        \newline \textit{Type:} String vs Integer for employee code. \textit{Format:} DD/MM/YYYY vs MM/DD/YYYY. 
        \newline \textit{Unit:} USD vs VND, km vs miles. \textit{Precision:} 2 vs 4 decimal places.
        
        \item \textbf{Data Redundancy:} Dữ liệu trùng lặp từ nhiều nguồn cần khử trùng (Deduplication).
        \newline \textit{VD: Cùng khách hàng xuất hiện trong CRM và ERP với ID khác nhau.}
        
        \item \textbf{Entity Resolution:} Xác định 2 bản ghi từ 2 nguồn khác nhau là cùng 1 thực thể.
        \newline \textit{VD: `Nguyen Van A' (DB1) và `A Nguyen' (DB2), `IBM' vs `International Business Machines'.}
        \newline \textit{Kỹ thuật:} Fuzzy matching, similarity scores (Levenshtein distance), Master Data Management (MDM).
        
        \item \textbf{Constraints Violation:} Constraint violations during data integration.
        \newline \textit{Primary Key:} Duplicate primary keys during merge. \textit{Foreign Key:} References don't exist.
        \newline \textit{Semantic:} Invalid values (negative age, future dates).
        
        \item \textbf{Data Quality Issues:} Data quality problems during integration process.
        \newline \textit{Accuracy:} Deviates from reality. \textit{Completeness:} Missing required fields (NULL).
        \newline \textit{Uniqueness:} Duplicates. \textit{Timeliness:} Stale/outdated data. \textit{Consistency:} Conflicts between sources.
        
        \item \textbf{Communication Heterogeneity:} Khác biệt về giao diện và giao thức truyền thông.
        \newline \textit{VD: REST API vs SOAP, HTTP vs FTP, Batch files vs Real-time streams, GraphQL vs SQL.}
    \end{itemize}

    \columnbreak

    \subsubsection{Data Quality Dimensions}
    \textit{Các tiêu chí đánh giá chất lượng dữ liệu trong hệ thống thông tin.}
    
    \paragraph{6 Core Dimensions}
    \begin{enumerate}[leftmargin=*, label={\textbf{\arabic*.}}]
        \item \textbf{Accuracy (Chính xác):} Mức độ dữ liệu phản ánh đúng đối tượng/sự kiện thực tế.
        \newline \textit{Định nghĩa:} Sự không chính xác có nghĩa là hệ thống biểu diễn một trạng thái thế giới thực khác với trạng thái đáng lẽ phải được biểu diễn.
        \newline \textit{VD:} Địa chỉ sai, số điện thoại cũ, thông tin lỗi thời.
        
        \item \textbf{Completeness (Đầy đủ):} Tỷ lệ dữ liệu được lưu trữ so với khả năng 100\% hoàn chỉnh.
        \newline \textit{Định nghĩa:} Khả năng của hệ thống biểu diễn mọi trạng thái có nghĩa của hệ thống thế giới thực.
        \newline \textit{VD:} NULL values, missing fields, incomplete records (missing email, phone number).
        
        \item \textbf{Consistency (Nhất quán):} Sự vắng mặt của sự khác biệt khi so sánh hai hoặc nhiều biểu diễn của cùng một thứ.
        \newline \textit{Định nghĩa:} Sự không nhất quán có nghĩa là ánh xạ biểu diễn là một-nhiều (one-to-many).
        \newline \textit{VD:} Tổng doanh thu trong bảng Orders $\neq$ tổng trong Report, tên KH khác nhau giữa CRM và ERP.
        
        \item \textbf{Validity (Hợp lệ):} Dữ liệu hợp lệ nếu tuân thủ cú pháp của định nghĩa (format, type, range).
        \newline \textit{VD:} Email correct format (has @), age in range [0, 150], enum has allowed values.
        
        \item \textbf{Timeliness (Kịp thời):} Mức độ dữ liệu phản ánh thực tế từ mốc thời gian yêu cầu.
        \newline \textit{Định nghĩa:} Độ trễ giữa thay đổi trạng thái thế giới thực và sửa đổi tương ứng trong hệ thống.
        \newline \textit{VD:} Giá cổ phiếu cập nhật delay 10s, báo cáo tồn kho cách 1 ngày (stale data).
        
        \item \textbf{Uniqueness (Duy nhất):} Không có thứ nào được ghi lại nhiều hơn một lần dựa trên cách xác định thứ đó.
        \newline \textit{VD:} Không có duplicate records, một khách hàng chỉ có một ID duy nhất.
    \end{enumerate}
    
    \paragraph{Extended Dimensions}
    \begin{itemize}[leftmargin=*, label={--}]
        \item \textbf{Interpretability (Khả năng Diễn giải):} Liên quan đến tài liệu và metadata có sẵn để diễn giải chính xác ý nghĩa và thuộc tính của nguồn dữ liệu.
        \newline \textit{VD:} Data dictionary, schema documentation, column descriptions, business glossary.
        
        \item \textbf{Accessibility (Khả năng Truy cập):} Đo lường khả năng người dùng truy cập dữ liệu từ văn hóa, trạng thái/chức năng vật lý và công nghệ có sẵn của họ.
        \newline \textit{VD:} API with rate limit, role-based access (RBAC), multi-language support.
        
        \item \textbf{Usability (Khả dụng):} Đo lường hiệu quả, hiệu suất, sự hài lòng mà người dùng cụ thể cảm nhận và sử dụng dữ liệu.
        \newline \textit{VD:} Dashboard dễ hiểu, query response time nhanh, format phù hợp với use case.
        
        \item \textbf{Trustworthiness:} Đo lường mức độ đáng tin cậy của tổ chức trong việc cung cấp nguồn dữ liệu.
        \newline \textit{VD:} Clear data lineage, complete audit logs, data provenance.
    \end{itemize}

    \subsubsection{Quản lý Thông tin}
    \textit{Quản lý dữ liệu như một tài sản chiến lược của doanh nghiệp.}
    
    \paragraph{6 Khía cạnh Quản lý Thông tin}
    \begin{enumerate}[leftmargin=*, label={\textbf{\arabic*.}}]
        \item \textbf{Information Collection (Thu thập):} Xác định và thu thập dữ liệu từ các nguồn khác nhau.
        \newline \textit{Hoạt động:} Data ingestion, ETL pipelines, API integration, web scraping, sensors/IoT.
        \newline \textit{VD:} Crawl web data, stream from Kafka, batch import from CSV, CDC from transactional DB.
        
        \item \textbf{Information Organization (Tổ chức):} Cấu trúc hóa và phân loại dữ liệu để dễ quản lý và truy xuất.
        \newline \textit{Hoạt động:} Schema design, data modeling (Star/Snowflake), taxonomy, metadata management.
        \newline \textit{VD:} Design DW dimensions/facts, create data catalog, tag data by domain.
        
        \item \textbf{Information Storage (Lưu trữ):} Chọn và triển khai hệ thống lưu trữ phù hợp với đặc điểm dữ liệu.
        \newline \textit{Hoạt động:} Choose DBMS (RDBMS, NoSQL, DW), partitioning, replication, backup strategy.
        \newline \textit{VD:} OLTP on PostgreSQL, OLAP on Snowflake, unstructured data on S3/Data Lake.
        
        \item \textbf{Information Manipulation (Thao tác):} Thực hiện các thao tác CRUD và chuyển đổi dữ liệu.
        \newline \textit{Hoạt động:} INSERT/UPDATE/DELETE, data transformation, cleansing, enrichment, aggregation.
        \newline \textit{VD:} Chuẩn hóa địa chỉ, deduplicate records, merge datasets, derive calculated fields.
        
        \item \textbf{Information Processing (Xử lý):} Phân tích và tính toán để tạo insights từ dữ liệu thô.
        \newline \textit{Hoạt động:} Query execution, analytics, ML training, reporting, dashboarding, data mining.
        \newline \textit{VD:} SQL queries, Spark jobs, BI reports, predictive models, real-time analytics.
        
        \item \textbf{Information Protection (Bảo vệ):} Đảm bảo an toàn, riêng tư và tuân thủ quy định.
        \newline \textit{Hoạt động:} Access control (RBAC), encryption (at-rest/in-transit), audit logging, compliance (GDPR).
        \newline \textit{VD:} Mã hóa PII, masking sensitive data, role-based permissions, backup/disaster recovery.
    \end{enumerate}
    
    \textit{Tổng thể:} Information Management bao gồm Data Governance (quản trị), Data Quality, Master Data Management (MDM), Security, và Lifecycle Management. Mục tiêu cuối cùng là đảm bảo dữ liệu \textbf{tin cậy, an toàn, dễ truy cập} để tạo giá trị kinh doanh.

    \columnbreak

    \subsection{Distributed Systems Challenges}
    \textit{Khác với hệ thống đơn, hệ phân tán đối mặt với \textbf{partial failures} - một số phần hỏng trong khi phần khác hoạt động.}
    
    \subsubsection{8 Fallacies (Ngụy biện) của Distributed Computing}
    \textit{Những giả định sai lầm mà lập trình viên thường mắc phải (L. Peter Deutsch, Sun Microsystems).}
    \begin{enumerate}[leftmargin=*, label={\textbf{\arabic*.}}]
        \item \textbf{The Network is Reliable:} Mạng không đáng tin cậy - switches hỏng, cables ngắt, packets bị mất/reorder.
        \item \textbf{Latency is Zero:} Local call (ns/$\mu$s) $\neq$ Remote call (ms). Chain calls $\rightarrow$ latency tích lũy.
        \item \textbf{Bandwidth is Infinite:} Băng thông hữu hạn. Stamp coupling (truyền dữ liệu thừa) gây bottleneck.
        \item \textbf{The Network is Secure:} Attack surface tăng. Mọi endpoint phải được bảo mật.
        \item \textbf{Topology Never Changes:} Topology thay đổi liên tục (upgrades, failures, scaling) $\rightarrow$ timeout/failures.
        \item \textbf{Only One Administrator:} Nhiều admin quản lý các segment khác nhau (firewall, DB) $\rightarrow$ khó phối hợp.
        \item \textbf{Transport Cost is Zero:} Serialization, marshalling, network infra đều tốn chi phí.
        \item \textbf{Network is Homogeneous:} Mạng gồm nhiều vendor (routers, switches) $\rightarrow$ packet loss, anomalies.
    \end{enumerate}
    
    \subsubsection{Unreliability: Network \& Time}
    \begin{itemize}[leftmargin=*, label={--}]
        \item \textbf{Network Unreliability:}
        \begin{itemize}
            \item \textit{Timeouts:} No bounded time $\rightarrow$ must use timeout. Too short: false positive. Too long: delayed detection.
            \item \textit{Network Partition (Netsplit):} Group of nodes isolated $\rightarrow$ "Split brain" (2 leaders both accept conflicting writes).
        \end{itemize}
        \item \textbf{Time Unreliability:} "Time is an illusion" - không có global clock.
        \begin{itemize}
            \item \textit{Clock Drift:} Quartz clock drifts due to temperature. Even NTP sync has discrepancies.
            \item \textit{Process Pauses:} GC or VM suspension $\rightarrow$ node pauses longer than lease timeout $\rightarrow$ declared dead but still thinks it's alive $\rightarrow$ data corruption.
            \item \textit{Ordering Issues:} Last Write Wins (LWW) using timestamp dangerous - clocks not synced $\rightarrow$ overwrites new value with old.
        \end{itemize}
    \end{itemize}
    
    \subsubsection{Consistency \& Consensus Challenges}
    \begin{itemize}[leftmargin=*, label={--}]
        \item \textbf{CAP Theorem:} Can only achieve 2/3: \textbf{C}onsistency, \textbf{A}vailability, \textbf{P}artition Tolerance. Partitions unavoidable $\rightarrow$ choose CP or AP.
        \newline $\rightarrow$ \textit{NoSQL thường chọn AP (Sẵn sàng + Chịu lỗi) thay vì CP.}
        \item \textbf{FLP Impossibility:} Async system cannot guarantee consensus termination if 1 node crashes $\rightarrow$ must use timeout.
        \item \textbf{Two Generals' Problem:} Không thể đạt common knowledge (chắc chắn đồng ý) qua kênh unreliable - ACK cuối cùng có thể bị mất.
        \item \textbf{BASE:} \textbf{B}asically \textbf{A}vailable, \textbf{S}oft state, \textbf{E}ventual consistency (Nhất quán cuối cùng - chấp nhận dữ liệu cũ tạm thời).
    \end{itemize}
    
    \subsubsection{Failure Models}
    \begin{itemize}[leftmargin=*, label={--}]
        \item \textbf{Crash Faults:} Process stops completely, never returns (simplest).
        \item \textbf{Omission Faults:} Process skips steps or doesn't send/receive messages (buffer overflow, congestion).
        \item \textbf{Byzantine Faults:} Process behaves arbitrarily/maliciously, sends wrong messages (hardest, blockchain).
    \end{itemize}
    
    \subsubsection{Managing "Truth" in Distributed Systems}
    \begin{itemize}[leftmargin=*, label={--}]
        \item \textbf{Truth by Majority:} Không node nào tin được view của chính mình. \textit{Sự thật = Quorum quyết định.}
        \newline \textit{VD:} Node tưởng mình là leader, nhưng quorum khai tử (do GC pause) $\rightarrow$ node đó "đã chết".
        \item \textbf{Fencing Tokens:} Monotonic number for storage to reject writes from nodes holding expired locks (zombie nodes).
    \end{itemize}
    
    \subsubsection{Thách thức Xử lý Dữ liệu Phân tán}
    \begin{itemize}[leftmargin=*, label={--}]
        \item \textbf{Data Skew (Lệch dữ liệu):} One partition contains too much data.
        \newline $\rightarrow$ \textit{Consequence:} Straggler problem - job waits for slowest node.
        \newline $\rightarrow$ \textit{Solution:} Salting (add random prefix) to split hot key.
        \item \textbf{Shuffle:} Transfer data between nodes over network (Map $\to$ Reduce).
        \newline $\rightarrow$ \textit{Optimization:} Broadcast Join (copy small table to all nodes) to avoid shuffling large table.
    \end{itemize}

    \section{Appendix: Quick Exam Q\&A}
    \textit{Các câu hỏi lý thuyết "bẫy" thường gặp trong đề thi.}
    \begin{description}[leftmargin=*, font=\bfseries\color{red!70!black}, nosep]
        \item[Q: Chọn công nghệ/DBMS ở giai đoạn nào?] 
        \newline $\rightarrow$ \textbf{Trước/Bắt đầu Thiết kế Logic.} (Vì logic design phụ thuộc vào mô hình dữ liệu của DBMS đã chọn: Quan hệ, NoSQL...).
        \item[Q: Mục tiêu của lược đồ Trong (Internal)?]
        \newline $\rightarrow$ Định nghĩa cấu trúc lưu trữ vật lý và đường dẫn truy cập (mức vật lý).
        \item[Q: Data Warehouse hướng chủ đề (Subject-oriented) là gì?]
        \newline $\rightarrow$ Dữ liệu tổ chức theo thực thể nghiệp vụ (Sales, Customer) thay vì theo chức năng App.
        \item[Q: Khi nào xác định Measures (Facts)?]
        \newline $\rightarrow$ Bước 4 trong Kimball (sau khi chọn Process, Grain, Dimensions).
        \item[Q: Điểm yếu lớn nhất của kiến trúc Lambda?]
        \newline $\rightarrow$ Phải duy trì và code trên 2 code base khác nhau (Batch \& Speed layer).
        \item[Q: Tại sao Secondary Index thường là Dense?]
        \newline $\rightarrow$ Vì thứ tự vật lý của data file không trùng với index key, nên mỗi record cần 1 entry riêng.
    \end{description}
\end{multicols}
\end{document}