\documentclass[landscape]{article}
\sloppy
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{graphicx}
\usepackage{hyperref}
\usepackage{geometry}
\usepackage{ulem}
\usepackage{multicol} % for multi-column layout
\usepackage{xcolor}
\usepackage{booktabs}
\usepackage{array}
\usepackage[inline]{enumitem} % to tighten list spacing

% --- VIETNAMESE SUPPORT PACKAGES ---
\usepackage[utf8]{inputenc}
\usepackage[T5]{fontenc}
\usepackage[vietnamese]{babel}
% -----------------------------------

% Tight margins for cheat sheet in landscape (A4 297mm x 210mm)
\geometry{a4paper, landscape, left=8mm, right=8mm, top=8mm, bottom=8mm}

\title{Tổng hợp Kiến thức Môn Kỹ thuật Dữ liệu (Data Engineering)}
\author{Học viên Cao học KHMT Bách Khoa TP.HCM (HCMUT)}
\date{\today}

\begin{document}

\maketitle
\footnotesize % smaller font for dense content
% Zero / minimal spacing in itemize and enumerate lists
\setlist{itemsep=0pt,topsep=2pt,parsep=0pt,partopsep=0pt}
\begin{multicols}{3}
    \setlength{\columnsep}{8pt} % space between columns
    \setlength{\multicolsep}{2pt} % vertical space before/after multicols
    \raggedcolumns

    \section{Nguyên lý Phân tích \& Thiết kế CSDL}

    \subsection{Tổng quan Các giai đoạn Thiết kế}
    \begin{enumerate}[leftmargin=*,itemsep=2pt]
        \item \textbf{Mức Quan niệm (Conceptual):} \textit{Mục tiêu} — nắm bắt yêu cầu và ngữ nghĩa (độc lập với cài đặt); \textit{Mô hình/Công cụ} — ER/EER; \textit{Đầu ra} — lược đồ quan niệm (thực thể, thuộc tính, mối kết hợp, ràng buộc).
        \item \textbf{Mức Logic:} \textit{Mục tiêu} — ánh xạ từ mức quan niệm sang mô hình DBMS đích (ví dụ: quan hệ); \textit{Mô hình/Công cụ} — ánh xạ ER-sang-quan hệ, chuẩn hóa (FDs); \textit{Đầu ra} — lược đồ quan hệ (bảng, khóa, ràng buộc toàn vẹn).
        \item \textbf{Mức Vật lý:} \textit{Mục tiêu} — xác định cấu trúc lưu trữ và đường dẫn truy xuất để tối ưu hiệu năng; \textit{Mô hình/Công cụ} — phân tích tải, chỉ mục, tổ chức tập tin, băm; \textit{Đầu ra} — lược đồ trong (cấu trúc lưu trữ, chỉ mục, đường dẫn truy xuất).
    \end{enumerate}

    \subsection{Nguyên lý Thiết kế Mức Quan niệm}
    \begin{itemize}[leftmargin=*, label={--}]
        \item \textbf{Phân tích Yêu cầu:} Làm việc với người dùng/chuyên gia nghiệp vụ để nắm bắt yêu cầu dữ liệu và yêu cầu chức năng (thao tác/giao dịch).
        \item \textbf{Thành phần ER:} \textbf{Thực thể} (vd: NhanVien), \textbf{Thuộc tính} (đơn/phức hợp/đa trị/dẫn xuất), \textbf{Mối kết hợp} (sự liên kết giữa các thực thể).
        \item \textbf{Ràng buộc Cấu trúc:} Tỷ số bản số (1:1, 1:N, M:N) và ràng buộc tham gia (\textit{toàn phần} vs \textit{từng phần}).
        \item \textbf{Thực thể Yếu:} Được xác định thông qua \textbf{mối kết hợp xác định} với một thực thể \textbf{chủ} và một \textbf{khóa bộ phận}; thực thể yếu tham gia \textit{toàn phần} vào mối kết hợp xác định.
        \item \textbf{Tinh chỉnh Top-Down:} Tinh chỉnh lặp lại các thực thể tổng quát; áp dụng chuyên biệt hóa/tổng quát hóa (EER).
    \end{itemize}
    
    \subsection{Nguyên lý Thiết kế Mức Logic}
    \subsubsection{Cơ bản về Mô hình Quan hệ}
    \begin{itemize}[leftmargin=*, label={--}]
        \item \textbf{Cấu trúc:} Lược đồ quan hệ $R(A_1, \dots, A_n)$; các bộ (tuple) không có thứ tự và không cho phép trùng lặp trong mô hình hình thức.
        \item \textbf{Ràng buộc Toàn vẹn:} Ràng buộc miền giá trị (nguyên tố, có kiểu), ràng buộc khóa (siêu khóa/khóa ứng viên/khóa chính), toàn vẹn thực thể (khóa chính không NULL), toàn vẹn tham chiếu (giá trị khóa ngoại phải xuất hiện trong khóa chính được tham chiếu).
    \end{itemize}

    \subsubsection{Lý thuyết Chuẩn hóa (Normalization Theory)}
    \begin{itemize}[leftmargin=*, label={--}]
        \item \textbf{Mục tiêu:} Giảm thiểu dư thừa, tránh dị thường (Thêm, Xóa, Sửa).
        \item \textbf{Phụ thuộc Hàm (FD):} $X \rightarrow Y$ (Nếu $t_1[X]=t_2[X]$ thì $t_1[Y]=t_2[Y]$).
        \item \textbf{Các loại Key:}
        \begin{itemize}
            \item \textit{Superkey:} Xác định duy nhất một bộ.
            \item \textit{Candidate Key:} Superkey tối thiểu.
            \item \textit{Prime Attribute:} Thuộc tính nằm trong bất kỳ Candidate Key nào.
        \end{itemize}
    \end{itemize}

    \textbf{Các Dạng Chuẩn (Normal Forms)}
    \begin{center}
        \includegraphics[width=0.8\linewidth, height=3cm, keepaspectratio]{./images/normalization_pyramid.png} \\
        \footnotesize \textit{(Hierarchy: BCNF $\subset$ 3NF $\subset$ 2NF $\subset$ 1NF)}
    \end{center}

    \begin{description}[leftmargin=*, labelindent=0pt, font=\bfseries\color{blue!80!black}, nosep]
        
        \item[1NF (Atomic):] Miền giá trị nguyên tố.
        \newline $\hookrightarrow$ \textit{Vi phạm:} Thuộc tính đa trị, lồng nhau, lặp lại nhóm.

        \item[2NF (No Partial):] Là 1NF + Thuộc tính \textit{non-prime} phụ thuộc đầy đủ vào khóa.
        \newline $\hookrightarrow$ \textit{Vi phạm:} $\exists X \subsetneq Key$ sao cho $X \rightarrow NonPrime$.
        \newline \textit{(Chỉ xảy ra nếu Key là khóa phức hợp)}.

        \item[3NF (No Transitive):] Là 2NF + Không có phụ thuộc bắc cầu giữa các \textit{non-prime}.
        \newline $\rightarrow$ \textit{Định nghĩa:} Với mọi $X \rightarrow A$ (không tầm thường), phải thỏa:
        \begin{enumerate*}[label=(\alph*)]
            \item $X$ là Superkey \textbf{HOẶC}
            \item $A$ là Prime Attribute.
        \end{enumerate*}

        \item[BCNF (Strict):] Nghiêm ngặt hơn 3NF.
        \newline $\rightarrow$ \textit{Định nghĩa:} Với mọi $X \rightarrow A$, $X$ \textbf{bắt buộc là Superkey}.
        \newline \textit{(Khác biệt: BCNF không chấp nhận ngoại lệ "A là Prime" như 3NF)}.

    \end{description}

    \textbf{Tính chất Phân rã (Decomposition Properties)}
    \begin{enumerate}[leftmargin=*, label={\arabic*.}]
        \item \textbf{Kết nối bảo toàn thông tin (Lossless Join):} \textit{(Bắt buộc)}
        \newline Để phân rã $R$ thành $R_1, R_2$ không bị mất dữ liệu, điều kiện là:
        \newline $(R_1 \cap R_2) \rightarrow R_1$ \textbf{HOẶC} $(R_1 \cap R_2) \rightarrow R_2$.
        \newline \textit{(Giao của 2 bảng phải là khóa của ít nhất 1 bảng).}
        \item \textbf{Bảo toàn phụ thuộc (Dependency Preservation):}
        \newline Các FD ban đầu có thể được kiểm tra riêng lẻ trên từng $R_i$ mà không cần join lại. (BCNF có thể không bảo toàn phụ thuộc).
    \end{enumerate}

    \subsubsection{Phi chuẩn hóa (Denormalization)}
    \begin{itemize}[leftmargin=*, label={--}]
        \item \textbf{Mục tiêu:} Cải thiện hiệu suất đọc bằng cách đưa dư thừa vào lược đồ, ngược với chuẩn hóa.
        \item \textbf{Động lực:} Tránh Join tốn kém; giảm độ phức tạp truy vấn; tăng locality dữ liệu.
    \end{itemize}
    
    \textbf{Kỹ thuật Denormalization:}
    \begin{itemize}[leftmargin=*, label={--}]
        \item \textbf{Materialized Views:} Kết quả truy vấn được tính trước và lưu trữ; cập nhật khi dữ liệu thay đổi.
        \item \textbf{Precomputed Aggregates:} Lưu giá trị tổng hợp (COUNT, SUM) trong bản ghi để tránh tính lại.
        \newline \textit{VD: Lưu số email chưa đọc trong bảng User thay vì đếm mỗi lần.}
        \item \textbf{Document Databases:} Nhúng (embedding) dữ liệu liên quan trong một document thay vì tham chiếu.
        \newline \textit{VD: MongoDB nhúng thông tin Worker vào document Project.}
        \item \textbf{Star Schema (DW):} Dimension tables được denormalize (VD: Brand, Category trong dim\_product).
        \item \textbf{Microservices:} Sao chép (replicate) dữ liệu giữa các service để tách biệt và giảm phụ thuộc.
    \end{itemize}
    
    \textbf{Đánh đổi (Trade-offs):}
    \begin{itemize}[leftmargin=*, label={--}]
        \item \textbf{Write Overhead:} Mỗi cập nhật phải sửa tất cả bản sao dư thừa $\Rightarrow$ ghi chậm hơn, phức tạp hơn.
        \item \textbf{Data Inconsistency:} Rủi ro không nhất quán nếu một bản sao được cập nhật mà bản khác thì không.
        \item \textbf{Storage Cost:} Lưu trữ dữ liệu trùng lặp tốn bộ nhớ hơn.
    \end{itemize}
    \textit{Khi nào dùng:} OLAP/DW (đọc nhiều), NoSQL (thiếu join), microservices (tách biệt). \textit{Tránh:} OLTP cần ACID chặt.

    \columnbreak

    \subsubsection{Bẫy Thiết kế CSDL (Design Traps)}
    \begin{itemize}[leftmargin=*, label={--}]
        \item \textbf{Bẫy Kết nối trong ER:}
        \begin{center}
            \begin{tabular}{@{} c @{}}
                \includegraphics[width=0.8\linewidth]{./images/design_trap_fan.png} \\
                \footnotesize (Fan Trap) \\[6pt]
                \includegraphics[width=0.8\linewidth]{./images/design_trap_chasm.png} \\
                \footnotesize (Chasm Trap) \\
            \end{tabular}
        \end{center}
        \begin{itemize}
            \item \textit{Fan Trap:} Đường dẫn giữa các thực thể mơ hồ do nhiều quan hệ 1:N phân nhánh từ một thực thể. VD: NhanVien $\to$ PhongBan $\to$ ChiNhanh (không xác định được nhân viên làm ở chi nhánh nào). \textit{Giải pháp:} Thêm quan hệ trực tiếp NhanVien-ChiNhanh.
            \item \textit{Chasm Trap:} Đường dẫn không tồn tại do tham gia tùy chọn. VD: KhanhHang $\to$ TaiSan $\to$ ChiNhanh (nếu tài sản chưa niêm yết thì không liên kết được khách hàng với chi nhánh). \textit{Giải pháp:} Đổi sang tham gia bắt buộc hoặc thêm quan hệ trực tiếp.
        \end{itemize}
        \item \textbf{Dị thường Cập nhật (Update Anomalies):} Do thiết kế không chuẩn hóa:
        \begin{itemize}
            \item \textit{Insertion:} Không thể thêm phòng ban mới nếu chưa có nhân viên.
            \item \textit{Deletion:} Xóa nhân viên cuối cùng làm mất thông tin phòng ban.
            \item \textit{Modification:} Thay đổi tên phòng ban phải cập nhật nhiều bộ.
        \end{itemize}
        \item \textbf{Bộ giả (Spurious Tuples):} Kết nối các quan hệ phân rã sai (không qua PK/FK hợp lệ) tạo ra bản ghi ảo. \textit{Giải pháp:} Dùng phân rã bảo toàn thông tin (lossless join).
        \item \textbf{Bẫy NULL:} Quá nhiều thuộc tính NULL lãng phí bộ nhớ và gây khó khăn trong truy vấn tổng hợp.
        \item \textbf{Sai lầm phổ biến:} Dùng PK của thực thể này làm thuộc tính của thực thể khác thay vì mô hình hóa quan hệ; gán PK vào thuộc tính của quan hệ; dùng thuộc tính đơn trị khi cần đa trị.
        \item \textbf{Entity Trap (Kiến trúc):} Thiết kế component 1-1 với bảng DB (VD: CustomerManager cho bảng Customer) thay vì theo workflow nghiệp vụ $\to$ vi phạm tách biệt dữ liệu trong microservices.
    \end{itemize}
    \textit{Thực hành tốt:} Dùng BCNF/3NF; phân rã bảo toàn thông tin; đảm bảo đường dẫn ER rõ ràng; thiết kế theo hành vi nghiệp vụ, không theo thực thể.

    \subsection{Nguyên lý Thiết kế Mức Vật lý}
    \begin{itemize}[leftmargin=*, label={--}]
        \item \textbf{Kiến trúc Lưu trữ:} Dữ liệu bền vững trên đĩa/SSD trong các \textbf{khối (block)} kích thước cố định.
        \item \textbf{Phân tích Tải (Job Mix):} Xác định các quan hệ/tập tin thường truy cập, điều kiện chọn (bằng/khác/khoảng), và tần suất cập nhật so với truy vấn.
        \item \textbf{Cấu trúc Chỉ mục:} Chỉ mục có thứ tự (B+-Trees) và chỉ mục băm; chỉ mục \textbf{chính/phân cụm} (quy định thứ tự vật lý; tối đa một trên mỗi tập tin) so với chỉ mục \textbf{phụ}.
        \item \textbf{Tối ưu hóa Truy vấn:} Dựa trên chi phí (thống kê) và các quy tắc kinh nghiệm (đẩy phép chọn/chiếu xuống sớm) để chọn kế hoạch hiệu quả.
    \end{itemize}
    \subsection{Các bước vẽ ERD}
    \begin{enumerate}[leftmargin=*, label={\textbf{\arabic*.}}]
        \item \textbf{Xác định Thực thể (Entities):} 
        \newline Tìm các \textit{danh từ} (Nouns) quan trọng trong yêu cầu (Vd: Employee, Student). Tránh nhầm lẫn thuộc tính là thực thể.
        
        \item \textbf{Xác định Mối kết hợp (Relationships):} 
        \newline Tìm các \textit{động từ} (Verbs) kết nối các thực thể (Vd: Works\_for, Teaches).
        
        \item \textbf{Xác định Thuộc tính (Attributes):} 
        \newline Xác định thông tin chi tiết cho mỗi thực thể. Xác định thuộc tính đa trị, dẫn xuất, phức hợp.
        
        \item \textbf{Xác định Khóa chính (Primary Keys):} 
        \newline Chọn thuộc tính định danh duy nhất cho mỗi thực thể và gạch chân nó.
        
        \item \textbf{Xác định Bản số (Cardinality Ratio):} 
        \newline Phân tích số lượng tham gia: 1:1, 1:N, hay M:N.
        
        \item \textbf{Xác định Ràng buộc tham gia (Participation):} 
        \newline Có bắt buộc không? (Total - Nét đôi) hay Tùy chọn? (Partial - Nét đơn).
        \newline \textit{Hỏi: `Thực thể A có thể tồn tại mà không cần B không?'}
        
        \item \textbf{Vẽ phác thảo \& Tinh chỉnh:} 
        \newline Vẽ sơ đồ, loại bỏ các thuộc tính dư thừa. Chuyển quan hệ M:N thành thực thể liên kết nếu cần thiết.
    \end{enumerate}
    \subsection{Chen Notation: ER \& EER}
    % Bảng cho Thực thể & Thuộc tính - Tiết kiệm không gian hơn liệt kê
    \subsubsection{Entities \& Attributes}
    \textit{Khi nào dùng:} \textbf{Thực thể} cho đối tượng độc lập (NhanVien, SanPham, KhanhHang); \textbf{Thực thể yếu} cho đối tượng phụ thuộc (NguoiPhuThuoccủa nhân viên, ChiTietDonHang); \textbf{Khóa} là định danh duy nhất (MSNV, CCCD); \textbf{Đa trị} cho thuộc tính nhiều giá trị (số điện thoại, email); \textbf{Dẫn xuất} cho giá trị tính toán (tuổi từ ngày sinh, tổng tiền).
    \begin{center}
        \begin{tabular}{@{} c c @{}}
            % Hàng 1: Thực thể & Thực thể yếu
            \includegraphics[width=0.45\linewidth, height=1.2cm, keepaspectratio]{./images/chen_entity.png}      &
            \includegraphics[width=0.45\linewidth, height=1.2cm, keepaspectratio]{./images/chen_weak_entity.png}                                \\
            \footnotesize (Thực thể)                                                                             & \footnotesize (Thực thể yếu) \\[2pt]

            % Hàng 2: Thuộc tính & Khóa
            \includegraphics[width=0.45\linewidth, height=1.2cm, keepaspectratio]{./images/chen_attribute.png}   &
            \includegraphics[width=0.45\linewidth, height=1.2cm, keepaspectratio]{./images/chen_key.png}                                        \\
            \footnotesize (Thuộc tính)                                                                           & \footnotesize (Khóa)         \\[2pt]

            % Hàng 3: Đa trị & Dẫn xuất
            \includegraphics[width=0.45\linewidth, height=1.2cm, keepaspectratio]{./images/chen_multivalued.png} &
            \includegraphics[width=0.45\linewidth, height=1.2cm, keepaspectratio]{./images/chen_derived.png}                                    \\
            \footnotesize (Đa trị)                                                                               & \footnotesize (Dẫn xuất)     \\
        \end{tabular}
    \end{center}

    \subsubsection{Relationships}
    \textit{Khi nào dùng:} \textbf{Quan hệ thường} cho liên kết độc lập (NhanVien \textit{làm việc cho} PhongBan, KhanhHang \textit{mua} SanPham); \textbf{Quan hệ xác định} khi thực thể yếu phụ thuộc vào thực thể chủ (NguoiPhuThuoc \textit{thuộc về} NhanVien với khóa bộ phận là tên người phụ thuộc).
    \begin{center}
        % Dùng minipage để căn chỉnh nếu ảnh có tỷ lệ khác nhau
        \includegraphics[width=0.9\linewidth]{./images/chen_relationships_summary.png} \\
        \footnotesize \textit{Bao gồm: Quan hệ (Hình thoi), Quan hệ xác định (Thoi đôi)}
    \end{center}
    
    \subsubsection{Ràng buộc (Constraints)}
    \textit{Khi nào dùng:} Xác định quy tắc nghiệp vụ giữa các thực thể.
    \begin{itemize}[leftmargin=*, label={}]
        \item \textbf{Bản số (Cardinality):} 1:1 (NhanVien \textit{quản lý} PhongBan - mỗi phòng có 1 trưởng), 1:N (PhongBan \textit{có} NhanVien - nhiều nhân viên/phòng), M:N (NhanVien \textit{tham gia} DUAN - nhiều-nhiều).
        \item \textbf{Tham gia (Participation):}
              \begin{center}
                  \includegraphics[width=0.85\linewidth]{./images/chen_participation.png} \\
                  \footnotesize (Partial Participation (Từng phần): Nét đơn \linebreak Total Participation (Toàn phần): Nét đôi)
              \end{center}
        \item \textbf{Min-Max (min, max):} Ghi cặp số trên cạnh. Ví dụ: NhanVien $(1,1)$ \textit{làm việc cho} $(0,N)$ PhongBan nghĩa là mỗi nhân viên bắt buộc làm việc cho đúng 1 phòng ban, mỗi phòng ban có thể có 0 đến nhiều nhân viên. $(0,1)$: tùy chọn, tối đa 1; $(1,N)$: bắt buộc, có thể nhiều. (An extension of Participation và Cardinality)
    \end{itemize}

    \columnbreak

    \subsubsection{EER Chuyên biệt hóa \& Tổng quát hóa}
    \begin{center}
        \begin{tabular}{@{} c @{}}
            \includegraphics[width=1\linewidth]{./images/chen_eer_disjoint_overlap.png} \\
            \footnotesize (Disjoint \& Overlapping)                                       \\[2pt]
            \includegraphics[width=1\linewidth]{./images/chen_eer_union.png}            \\
            \footnotesize (Union)                                                         \\
        \end{tabular} \\[2pt]
        \footnotesize \textit{Ký hiệu: Hình tròn (d: disjoint, o: overlapping, U: union),\linebreak Nét đôi (Total), Nét đơn (Partial).}
    \end{center}
    \textit{Khi nào dùng:} \textbf{Disjoint} khi lớp con không chồng lấp (NhanVien là KỸ SƯ hoặc QUẢN LÝ, không đồng thời); \textbf{Overlapping} khi có thể thuộc nhiều lớp (NGƯỜI là SINH VIÊN và/hoặc NHÂN VIÊN); \textbf{Union} khi lớp con kế thừa từ nhiều lớp cha (CHỦ SỞ HỮU có thể là NGƯỜI hoặc CÔNG TY hoặc NGÂN HÀNG). \textbf{Total} khi mọi thực thể cha phải thuộc ít nhất 1 lớp con; \textbf{Partial} khi không bắt buộc.

    % ===========================================================================
    % SECTION INDEXING & QUERY OPTIMIZATION
    % ===========================================================================
    \section{Chỉ mục \& Tối ưu hóa Truy vấn}

    % ============================================================================
    % FOUNDATIONAL CONCEPTS
    % ============================================================================
    \subsection{Cơ bản về Chỉ mục}

    \subsubsection{Chỉ mục là gì?}
    \begin{itemize}[leftmargin=*, label={--}]
        \item \textbf{Mục đích:} Tăng tốc độ truy xuất dữ liệu bằng cách tạo đường dẫn phụ trợ đến các bản ghi.
        \item \textbf{Khóa tìm kiếm:} (Các) thuộc tính dùng để tìm bản ghi; không nhất thiết là khóa chính; có thể là khóa phức hợp (nhiều cột).
        \item \textbf{Đánh đổi:} Đọc nhanh hơn so với ghi chậm hơn (chi phí bảo trì chỉ mục khi INSERT/UPDATE/DELETE).
    \end{itemize}

    \subsubsection{Phân loại Chỉ mục}
    \begin{itemize}[leftmargin=*, label={--}]
        \item \textbf{Theo Cấu trúc:}
              \begin{itemize}
                  \item \textit{Có thứ tự (Ordered):} Các mục được sắp xếp (vd: B+-tree); hỗ trợ truy vấn khoảng.
                  \item \textit{Băm (Hash):} Khóa được băm vào bucket; chỉ nhanh khi tìm kiếm chính xác (dấu bằng).
              \end{itemize}
        \item \textbf{Theo Mật độ:}
              \begin{itemize}
                  \item \textit{Đặc (Dense):} Một mục chỉ mục cho mỗi giá trị khóa tìm kiếm riêng biệt.
                  \item \textit{Thưa (Sparse):} Một mục chỉ mục cho mỗi khối (hoặc mỗi giá trị phân cụm); nhỏ hơn, chi phí bảo trì thấp hơn.
              \end{itemize}
        \item \textbf{Theo Thứ tự Vật lý:}
              \begin{itemize}
                  \item \textit{Chỉ mục Chính/Phân cụm:} Khóa tìm kiếm quyết định thứ tự vật lý của tập tin (tối đa một per bảng); thường là chỉ mục thưa.
                  \item \textit{Chỉ mục Phụ:} Đường dẫn truy cập thay thế độc lập với thứ tự vật lý; thường là chỉ mục đặc hoặc dùng gián tiếp cho các khóa không duy nhất.
              \end{itemize}
    \end{itemize}

    % ============================================================================
    % CORE INDEX STRUCTURES
    % ============================================================================
    \subsection{B-Trees \& B+-Trees}

    \subsubsection{Khác biệt Cấu trúc}
    \textit{Mặc dù thường dùng thay thế cho nhau, B-Tree và B+-Tree có sự khác biệt quan trọng về nơi lưu data pointers.}
    \begin{itemize}[leftmargin=*, label={--}]
        \item \textbf{B-Tree:} Search key values xuất hiện \textit{chỉ một lần} trong tree. Data pointers tồn tại ở \textit{tất cả levels} (internal + leaf nodes).
        \newline $\rightarrow$ Lookup có thể terminate tại internal node nếu tìm thấy key.
        \item \textbf{B+-Tree:} Data pointers chỉ lưu ở \textit{leaf nodes}. Internal nodes chỉ chứa separator keys (khóa phân tách) để guide search.
        \newline $\rightarrow$ Internal nodes chứa nhiều keys hơn $\rightarrow$ higher fan-out (hệ số rẽ nhánh cao hơn) $\rightarrow$ shorter tree height.
        \newline $\rightarrow$ Leaf nodes linked together $\rightarrow$ efficient sequential access \& range scans.
        \item \textbf{Industry Standard:} Hầu hết DBMS hiện đại dùng B+-Tree (gọi tắt là B-Tree) vì fewer disk I/Os.
    \end{itemize}

    \subsubsection{General Structure \& Properties}
    \begin{itemize}[leftmargin=*, label={--}]
        \item \textbf{Balanced Tree:} Mọi path từ root đến leaf có cùng length (chiều cao đồng đều).
        \item \textbf{Node Capacity:} Mỗi node = fixed-size disk block (thường 4KB hoặc lớn hơn).
        \item \textbf{Fan-out:} Internal nodes chứa từ $\lceil n/2 \rceil$ đến $n$ children. High fan-out $\rightarrow$ B-Trees "fat and short".
        \newline \textit{VD:} 3-4 levels có thể store terabytes of data.
        \item \textbf{Leaf Nodes:} Chứa từ $\lceil (n-1)/2 \rceil$ đến $n-1$ values, sorted by search key.
        \item \textbf{Separator Keys:} Internal node với keys $K_1, K_2, \ldots, K_{n-1}$: pointer $P_i$ trỏ đến subtree với values $X$ thỏa $K_{i-1} < X < K_i$.
    \end{itemize}

    \subsubsection{Algorithms (Complexity: $O(\log_N M)$)}
    
    \paragraph{Search (Lookup)}
    \begin{itemize}[leftmargin=*, label={--}]
        \item \textbf{Traversal:} Bắt đầu từ root. Tại mỗi internal node, binary search tìm correct child pointer covering search key range.
        \item \textbf{Termination:} Lặp lại cho đến leaf node. Trong B+-Tree, search leaf cho specific key và associated record pointer.
        \item \textbf{Range Queries:} Leaf nodes linked (sibling pointers) $\rightarrow$ efficient range scan. Tìm starting key, traverse linked list.
    \end{itemize}

    \paragraph{Insertion}
    \begin{enumerate}[leftmargin=*, label={\textbf{\arabic*.}}]
        \item \textbf{Locate Leaf:} Tìm leaf node nơi new key thuộc về.
        \item \textbf{Space Available:} Nếu leaf có space $\rightarrow$ insert entry in sorted order.
        \item \textbf{Splitting (Overflow):} Nếu leaf full:
        \begin{itemize}
            \item Split thành 2 nodes: first $\lceil n/2 \rceil$ entries ở original, rest ở new node.
            \item Middle key promoted (copied) lên parent làm separator.
        \end{itemize}
        \item \textbf{Propagation:} Nếu parent cũng full $\rightarrow$ split propagates upward. Root split $\rightarrow$ new root $\rightarrow$ tree height tăng 1.
    \end{enumerate}

    \paragraph{Deletion}
    \begin{enumerate}[leftmargin=*, label={\textbf{\arabic*.}}]
        \item \textbf{Locate \& Remove:} Tìm entry trong leaf node và xóa.
        \item \textbf{Underflow:} Nếu node $< \lceil n/2 \rceil$ full:
        \begin{itemize}
            \item \textit{Redistribute:} Borrow entries từ sibling node (shift keys qua parent).
            \item \textit{Merge (Coalesce):} Nếu không thể redistribute $\rightarrow$ merge với sibling. Separator key ở parent bị deleted/demoted.
        \end{itemize}
        \item \textbf{Propagation:} Merge có thể propagate upward, potentially giảm tree height.
    \end{enumerate}
    \columnbreak
    \subsubsection{Implementation \& Optimizations}
    \begin{itemize}[leftmargin=*, label={--}]
        \item \textbf{Write-Ahead Log (WAL):} B-Trees overwrite pages on disk. Crash trong multi-page update (split) $\rightarrow$ corruption.
        \newline $\rightarrow$ WAL ghi modifications trước khi update tree pages $\rightarrow$ durability \& atomicity.
        \item \textbf{Concurrency (Latches):} Multiple threads access index đồng thời $\rightarrow$ dùng latches (lightweight locks).
        \newline \textit{Latch Crabbing:} Lock parent $\rightarrow$ lock child $\rightarrow$ release parent $\rightarrow$ high concurrency.
        \item \textbf{Bulk Loading:} Inserting records one-by-one $\rightarrow$ random I/O $\rightarrow$ inefficient.
        \newline $\rightarrow$ Bulk load: Sort data $\rightarrow$ build tree bottom-up (sequential writes) $\rightarrow$ create parent nodes as needed.
        \item \textbf{Flash Storage (SSD):} Random reads nhanh, random writes đắt (erase-modify-write cycles).
        \newline $\rightarrow$ LSM-Tree (Log-Structured Merge-Tree) preferred cho write-heavy workloads, nhưng B-Trees vẫn là general-purpose standard.
        \item \textbf{Prefix Compression:} Internal nodes chỉ lưu prefix của key (đủ để distinguish subtrees) thay vì full key $\rightarrow$ tăng fan-out.
        \item \textbf{Right-Only Appends:} Với auto-incrementing keys, allocate new node khi rightmost leaf full thay vì split $\rightarrow$ tránh half-empty pages.
    \end{itemize}

    \subsubsection{Capacity Calculation Example}
    \textit{Parameters:} Block size $B=512$ bytes; key size $V=9$ bytes; data pointer $\Pr=7$ bytes; tree pointer $P=6$ bytes.

    \paragraph{Step 1: Fan-out Calculation}
    \begin{itemize}[leftmargin=*, label={--}]
        \item \textbf{B-Tree Internal Node:} Chứa $p$ tree pointers + $(p-1)$ keys + $(p-1)$ data pointers.
        \newline $(p \times 6) + ((p-1) \times (7+9)) \le 512 \Rightarrow 22p \le 528 \Rightarrow p = 23$

        \item \textbf{B+-Tree Internal Node:} Chứa $p$ tree pointers + $(p-1)$ keys (no data pointers).
        \newline $(p \times 6) + ((p-1) \times 9) \le 512 \Rightarrow 15p \le 521 \Rightarrow p = 34$
        \newline \textit{Insight:} B+-Tree fan-out 48\% higher (34 vs 23) $\rightarrow$ shorter tree.

        \item \textbf{B+-Tree Leaf Node:} Chứa $p_{leaf}$ key/data pointer pairs + 1 next pointer.
        \newline $(p_{leaf} \times (7+9)) + 6 \le 512 \Rightarrow 16 \times p_{leaf} \le 506 \Rightarrow p_{leaf} = 31$
    \end{itemize}

    \paragraph{Step 2: Estimate Total Capacity (69\% Full)}
    \begin{itemize}[leftmargin=*, label={--}]
        \item \textbf{B-Tree (3 levels):} Average fan-out $fo = 23 \times 0.69 \approx 16$.
              \begin{itemize}
                  \item Level 0 (root): 15 entries, 16 pointers
                  \item Level 1: $16 \times 15 = 240$ entries
                  \item Level 2: $256 \times 15 = 3{,}840$ entries
                  \item \textbf{Total:} $15 + 240 + 3{,}840 \approx \mathbf{4{,}095}$ entries
              \end{itemize}

        \item \textbf{B+-Tree (3 levels):} Internal nodes $fo = 34 \times 0.69 \approx 23$; Leaf capacity $= 31 \times 0.69 \approx 21$.
              \begin{itemize}
                  \item Level 0: 22 entries, 23 pointers
                  \item Level 1: $23 \times 22 = 506$ entries, 529 pointers
                  \item Leaf level: $12{,}167 \times 21 \approx \mathbf{255{,}507}$ data pointers
              \end{itemize}

        \item \textbf{Observation:} B+-Tree holds $\sim 4\times$ more entries at the same height due to lighter internal nodes.
    \end{itemize}

    \subsubsection{Advanced Index Types}
    \begin{itemize}[leftmargin=*, label={--}]
        \item \textbf{Composite Indexes:} Multi-column keys (e.g., (City, LastName)); support leftmost prefix queries (City), (City, LastName); order columns by selectivity.
        \item \textbf{Function-Based Indexes:} Indexes on expressions (e.g., \texttt{LOWER(email)}); queries must use the exact function to utilize the index.
    \end{itemize}

    % ============================================================================
    % SPECIALIZED STRUCTURES
    % ============================================================================
    \subsection{Chỉ mục Băm \& Bitmap}

    \subsubsection{Chỉ mục Băm (Hash Indexes)}
    \begin{itemize}[leftmargin=*, label={--}]
        \item \textbf{Sử dụng:} Tìm kiếm chính xác cực nhanh (truy vấn điểm); không hỗ trợ khoảng.
        \item \textbf{Xử lý đụng độ:} Dùng danh sách liên kết (chaining) với bucket tràn.
        \item \textbf{Biến thể động:} Băm mở rộng/tuyến tính (Extendible/Linear hashing) tăng trưởng dần mà không cần xây lại toàn bộ.
    \end{itemize}
    
    \subsubsection{Chỉ mục Bitmap}
    \textit{Tối ưu cho thuộc tính có độ chọn lọc thấp (ít giá trị riêng biệt).}
    \begin{itemize}[leftmargin=*, label={--}]
        \item \textbf{Cấu trúc:} Đánh số thứ tự bản ghi (0, 1, 2, ...); mỗi giá trị riêng biệt có một bitmap; bit $i=1$ nếu bản ghi $i$ có giá trị đó.
        \item \textbf{Ví dụ (bảng 5 dòng):}
              \begin{itemize}
                  \item \texttt{gender='m'}: 10010 \quad \texttt{gender='f'}: 01101
                  \item \texttt{income='L1'}: 11000 \quad \texttt{income='L2'}: 00100
              \end{itemize}
        \item \textbf{Truy vấn: gender='f' AND income='L2'}
        \item[] $01101 \; \text{AND} \; 00100 = 00100 \quad \Rightarrow \quad \text{bản ghi 2}$
        \item \textbf{Ưu điểm:} Gọn nhẹ (1 triệu dòng = 125 KB mỗi bitmap); thao tác bitwise nhanh; hiệu quả cho bộ lọc nhiều điều kiện; hỗ trợ COUNT qua đếm bit.
    \end{itemize}

    % ============================================================================
    % QUERY COST MODELING
    % ============================================================================
    \subsection{Tối ưu hóa Truy vấn \& Phân tích Chi phí}

    \subsubsection{Ký hiệu Chi phí (Cost Function Notation)}
    \textit{Ước tính tài nguyên (disk I/O) để xử lý truy vấn: số block transfers ($b$) và số disk seeks ($S$).}
    \begin{itemize}[leftmargin=*, label={--}]
        \item $b$ (hoặc $b_r$): Tổng số blocks trong file.
        \item $r$ (hoặc $n_r$): Tổng số records (tuples) trong relation.
        \item $s$ (hoặc $s_A$): \textbf{Selection cardinality} - số records trung bình thỏa điều kiện.
        \item $bfr$: Blocking factor (số records trên mỗi block).
        \item $x$ (hoặc $h_i$): Số levels trong index (chiều cao B+-tree).
        \item $t_S$: Average time cho disk seek.
        \item $t_T$: Average time để transfer một block.
        \item \textbf{Công thức tổng:} Cost = $b \times t_T + S \times t_S$ (transfer time + seek time).
    \end{itemize}

    \subsubsection{Hàm Chi phí cho Phép Chọn (SELECT Cost Functions)}
    \textit{Phép chọn ($\sigma$) có thể dùng quét file hoặc truy cập index. Chi phí chưa tính ghi kết quả.}
    
    \paragraph{S1: Linear Search (File Scan)}\mbox{}\\
    Quét mọi block và test tất cả records. Áp dụng cho mọi cấu trúc file.
    \begin{itemize}[leftmargin=*, label={--}]
        \item \textbf{Trường hợp chung:} $\mathbf{C_{S1a} = b}$ blocks. 
        \newline \textit{Time:} $t_S + b \times t_T$ (1 seek ban đầu + transfer all blocks).
        \item \textbf{Equality on Key:} $\mathbf{C_{S1b} = b/2}$ blocks (trung bình, dừng khi tìm thấy).
        \newline \textit{Time:} $t_S + (b/2) \times t_T$.
    \end{itemize}

    \paragraph{S2: Binary Search}\mbox{}\\
    File đã sắp xếp theo search attribute. $\mathbf{C_{S2} = \lceil \log_2 b \rceil + \lceil s/bfr \rceil - 1}$ blocks.
    \newline \textit{Giải thích:} $\log_2 b$ để locate first block + $\lceil s/bfr \rceil$ để retrieve matching blocks contiguous.

    \paragraph{S3a: Primary Index (Equality on Unique Key)}\mbox{}\\
    File được sắp xếp vật lý theo search key. $\mathbf{C_{S3a} = x + 1}$ blocks.
    \newline \textit{Time:} $(h_i + 1) \times (t_T + t_S)$ (traverse index tree + 1 data block access).
    \newline \textit{VD:} B+-tree height 3 $\rightarrow$ 3 index blocks + 1 data block = 4 I/Os.

    \paragraph{S3b: Hash Index (Equality)}\mbox{}\\
    $\mathbf{C_{S3b} = 1}$ (static/linear hashing) hoặc $\mathbf{2}$ (extendible hashing).

    \paragraph{S5: Clustering Index (Equality on Non-Unique Key)}\mbox{}\\
    File sắp xếp, matching records lưu contiguous. $\mathbf{C_{S5} = x + \lceil s/bfr \rceil}$ blocks.
    \newline \textit{Time:} $h_i \times (t_T + t_S) + t_S + b_{matches} \times t_T$ (index + 1 seek to data + transfer).
    \newline \textit{VD:} Tìm Dno=5 với 1000 matching records, bfr=10 $\rightarrow$ x + 100 blocks.

    \paragraph{S6a: Secondary Index (Equality on Non-Unique Key)}\mbox{}\\
    File \textbf{không} sắp xếp theo attribute này $\rightarrow$ matching records phân tán. 
    \newline $\mathbf{C_{S6a} = x + s + 1}$ blocks (worst case: mỗi record cần 1 random I/O).
    \newline \textit{Time:} $(h_i + n) \times (t_T + t_S)$ với $n$ = số records.
    \newline \textbf{Nguy cơ:} Nếu $s$ lớn, secondary index đắt hơn linear scan do nhiều random seeks.

    \paragraph{S6b: Secondary Index (Range Query)}\mbox{}\\
    $\mathbf{C_{S6b} = x + (b_{I1}/2) + (r/2)}$ (giả sử half file thỏa điều kiện).
    \newline \textit{Performance Implication:} Nếu số records lớn, optimizer thích linear scan hơn secondary index.

    \subsubsection{Selections với Comparisons (Range Queries)}
    \begin{itemize}[leftmargin=*, label={--}]
        \item \textbf{Clustering Index:} Hiệu quả - records contiguous. 
        \newline \textit{Cost:} $x + b_{range}$ (find first + sequential scan).
        \item \textbf{Secondary Index:} Đắt - index leaves scan + random I/O cho mỗi record. 
        \newline \textit{Nếu range lớn:} Prefer linear scan.
    \end{itemize}

    \subsubsection{Complex Selections}
    \begin{itemize}[leftmargin=*, label={--}]
        \item \textbf{Conjunctive (AND):} Chọn single most restrictive access path (smallest selectivity) $\rightarrow$ check conditions còn lại trong RAM. 
        \newline \textit{Hoặc:} Dùng nhiều secondary indices $\rightarrow$ retrieve pointers $\rightarrow$ compute \textbf{intersection}.
        \item \textbf{Disjunctive (OR):} Nếu 1 condition cần linear scan $\rightarrow$ toàn bộ query cần linear scan. 
        \newline \textit{Nếu indices cho tất cả:} Retrieve pointers $\rightarrow$ compute \textbf{union}.
    \end{itemize}

    \subsubsection{Bảng Tóm tắt Chi phí SELECT}
    \begin{center}
        \renewcommand{\arraystretch}{1.15}
        \begin{tabular}{@{} l | l | l @{}}
            \toprule
            \textbf{Algorithm} & \textbf{Mô tả} & \textbf{Block Accesses} \\
            \midrule
            \textbf{S1} & Linear Search & $b$ \\
            \textbf{S2} & Binary Search & $\lceil \log_2 b \rceil + \lceil s/bfr \rceil - 1$ \\
            \textbf{S3a} & Primary Index (Unique) & $x + 1$ \\
            \textbf{S5} & Clustering Index (Equality) & $x + \lceil s/bfr \rceil$ \\
            \textbf{S6a} & Secondary Index (Equality) & $x + s + 1$ \\
            \textbf{S6b} & Secondary Index (Range) & $x + (b_{I1}/2) + (r/2)$ \\
            \bottomrule
        \end{tabular}
    \end{center}

    \textit{Lưu ý: Chi phí thời gian = $b \times t_T + S \times t_S$ (tách biệt transfer và seek).}

    \subsubsection{Ví dụ: Phép chọn trên EMPLOYEE}
    \textit{Kịch bản:} Quan hệ EMPLOYEE có thông số:
    \begin{itemize}[leftmargin=*, nosep]
        \item $r_E = 10{,}000$ records, $b_E = 2{,}000$ blocks, $bfr_E = 5$ records/block.
        \item \textbf{Available Access Paths:}
        \begin{itemize}
            \item \textit{Ssn} (Secondary, Unique Key): $x=4$, $s=1$.
            \item \textit{Dno} (Secondary, Non-Unique): $x=2$, $s=80$ (assumption: 125 depts, so $10{,}000/125=80$).
            \item \textit{Salary} (Clustering, Non-Unique): $x=3$, $s=20$.
            \item \textit{Sex} (Secondary, Non-Unique): $x=1$, $s=5{,}000$ (assumption: 2 values, so $10{,}000/2=5{,}000$).
        \end{itemize}
    \end{itemize}

    \paragraph{Example 1: Equality on Unique Key}\mbox{}\\
    Query: $\sigma_{\text{Ssn}='123456789'}(\text{EMPLOYEE})$.
    \begin{itemize}[leftmargin=*, label={--}]
        \item \textbf{S1b (Linear Search):} $C = b_E/2 = 2{,}000/2 = 1{,}000$ blocks.
        \newline \textit{Explanation:} Scan half file on average until record found.
        \item \textbf{S6a (Secondary Index on Key):} $C = x + 1 = 4 + 1 = 5$ blocks.
        \newline \textit{Explanation:} Traverse 4-level index + retrieve 1 data block.
        \item \textbf{Decision:} Use S6a (5 blocks $\ll$ 1{,}000 blocks). \textit{Speedup: 200x}.
    \end{itemize}

    \paragraph{Example 2: Equality on Non-Unique Key}\mbox{}\\
    Query: $\sigma_{\text{Dno}=5}(\text{EMPLOYEE})$.
    \begin{itemize}[leftmargin=*, label={--}]
        \item \textbf{S1a (Linear Search):} $C = b_E = 2{,}000$ blocks.
        \item \textbf{S6a (Secondary Index):} $C = x + s = 2 + 80 = 82$ blocks.
        \newline \textit{Explanation:} 2 index blocks + 80 random I/Os (records scattered across blocks).
        \item \textbf{S5 (If Clustering Index existed):} $C = x + \lceil s/bfr \rceil = 3 + \lceil 80/5 \rceil = 3 + 16 = 19$ blocks.
        \newline \textit{Explanation:} 3 index blocks + 16 contiguous data blocks (records stored together).
        \item \textbf{Decision:} Use S6a (82 blocks $\ll$ 2{,}000). \textit{Note: Clustering index would be 4.3x better (19 vs 82)}.
    \end{itemize}

    \paragraph{Example 3: Conjunctive Selection (Multiple Conditions)}\mbox{}\\
    Query: $\sigma_{\text{Dno}=5 \land \text{Salary}>30{,}000 \land \text{Sex}='F'}(\text{EMPLOYEE})$.
    \newline \textit{Strategy:} Choose most selective access path to retrieve candidate set, then filter remaining conditions in memory.
    \begin{itemize}[leftmargin=*, label={--}]
        \item \textbf{Via Dno (S6a):} $C = x + s = 2 + 80 = 82$ blocks. \textit{Retrieves 80 records}.
        \item \textbf{Via Salary Range (Clustering):} $C \approx x + (b_E/2) = 3 + 1{,}000 = 1{,}003$ blocks.
        \newline \textit{Assumption: Half employees earn $>30{,}000$, need to scan half file.}
        \item \textbf{Via Sex (S6a):} $C = x + s = 1 + 5{,}000 = 5{,}001$ blocks. \textit{5{,}000 random I/Os (very expensive)}.
        \item \textbf{Linear Scan (S1a):} $C = 2{,}000$ blocks.
        \item \textbf{Decision:} Use Dno index (82 blocks) to retrieve 80 candidate records $\rightarrow$ filter Salary $>30{,}000$ and Sex='F' in memory.
        \newline \textit{Final result size estimated:} $80 \times 0.5 \times 0.5 = 20$ records (assuming 50\% pass each filter).
    \end{itemize}

    \paragraph{Example 4: Secondary Index vs Linear Scan Trade-off}\mbox{}\\
    Query: $\sigma_{\text{Sex}='F'}(\text{EMPLOYEE})$ (highly non-selective).
    \begin{itemize}[leftmargin=*, label={--}]
        \item \textbf{S6a (Secondary Index):} $C = x + s = 1 + 5{,}000 = 5{,}001$ blocks.
        \newline \textit{Problem:} 5{,}000 random seeks $\rightarrow$ extremely expensive. At $t_S=10$ms, $t_T=1$ms: $(1 + 5{,}000) \times 11 = 55{,}011$ms $\approx$ 55 seconds.
        \item \textbf{S1a (Linear Scan):} $C = 2{,}000$ blocks.
        \newline \textit{Time:} $1 \times 10 + 2{,}000 \times 1 = 2{,}010$ms $\approx$ 2 seconds.
        \item \textbf{Decision:} Use linear scan (2{,}000 blocks $\ll$ 5{,}001 blocks). \textit{27x faster despite having index!}
        \newline \textbf{Key Insight:} Secondary index only beneficial when selectivity is high ($s \ll b$).
    \end{itemize}

    \subsubsection{Cost Functions for JOIN Operations}

    \paragraph{Notation}
    \begin{itemize}[leftmargin=*, nosep]
        \item $b_r, b_s$: Number of blocks (số khối) in relations $r$ and $s$.
        \item $n_r, n_s$ (or $|R|, |S|$): Number of tuples (số bộ) in relations $r$ and $s$.
        \item $js$: Join selectivity (độ chọn lọc kết nối) - fraction of tuple pairs matching. For equi-join: $js \approx 1/\max(NDV(A), NDV(B))$.
        \item $jc$: Join cardinality (lực lượng kết nối) - number of result tuples = $js \times |R| \times |S|$.
        \item $bfr_{result}$: Blocking factor (hệ số khối) of result relation.
        \item $n_B$ (or $M$): Number of available memory buffer blocks (số khối bộ đệm).
        \item $h_i$ (or $x$): Height of index tree (chiều cao B+-tree).
        \item $s_B$: Selection cardinality - average matching records in index lookup.
    \end{itemize}

    \paragraph{J1: Nested-Loop Join Variants}
    \begin{itemize}[leftmargin=*, label={--}]
        \item \textbf{Basic Nested-Loop:} For each record in outer relation (quan hệ ngoài) $r$, scan entire inner relation (quan hệ trong) $s$.
        \newline \textit{Cost:} $b_r + n_r \times b_s$ block transfers + $(n_r + b_r)$ seeks.
        \newline \textit{Problem:} Cực kỳ đắt nếu $n_r$ lớn.
        
        \item \textbf{Block Nested-Loop:} Process block-by-block thay vì row-by-row.
        \newline \textit{Cost (Worst):} $b_r + (b_r \times b_s)$ transfers + $2 \times b_r$ seeks.
        \newline \textit{Cost (With $n_B$ buffers):} $b_r + \lceil b_r / (n_B - 2) \rceil \times b_s$ transfers.
        \newline \textit{Strategy:} Dùng $n_B - 2$ buffers cho outer, 1 cho inner, 1 cho output. Dùng quan hệ nhỏ hơn làm outer.
    \end{itemize}

    \paragraph{J2: Indexed Nested-Loop Join}\mbox{}\\
    Index tồn tại trên join attribute của inner relation $s$. Thay file scans bằng index lookups (tra cứu chỉ mục).
    \begin{itemize}[leftmargin=*, label={--}]
        \item \textbf{General Formula:} $b_r + (n_r \times \text{cost of selection on } s)$.
        \newline \textit{Explanation:} Đọc outer $r$ ($b_r$) + thực hiện $n_r$ index lookups trên $s$.
        \item \textbf{Secondary Index (Chỉ mục phụ):} $b_r + n_r \times (x + s_B + 1)$ blocks.
        \newline \textit{$s_B$:} Average matching records. Mỗi record cần random I/O nếu non-unique.
        \item \textbf{Primary/Clustering Index (Chỉ mục chính/phân cụm):} $b_r + n_r \times (x + 1)$ blocks.
        \newline \textit{Assumption:} Unique keys hoặc matching records lưu contiguous (liền kề).
    \end{itemize}

    \paragraph{J3: Sort-Merge Join}\mbox{}\\
    Cả hai quan hệ phải được sắp xếp theo join attributes. Hiệu quả cao nếu đã pre-sorted.
    \begin{itemize}[leftmargin=*, label={--}]
        \item \textbf{If already sorted:} $b_r + b_s$ block transfers (đọc cả hai một lần).
        \item \textbf{If not sorted:} Cost(Sort $r$) + Cost(Sort $s$) + $b_r + b_s$.
        \newline \textit{Sort Cost:} Thường $b \times (2 \lceil \log_{n_B-1}(b/n_B) \rceil + 1)$ cho external merge-sort.
        \item \textbf{Best Use Case:} Dữ liệu đã sorted, hoặc khi kết quả cần sorted.
    \end{itemize}

    \paragraph{J4: Hash Join}\mbox{}\\
    Partition both relations by hash of join key. Matching tuples fall into same partition.
    \begin{itemize}[leftmargin=*, label={--}]
        \item \textbf{Standard Hash Join:} $3(b_r + b_s)$ block transfers.
        \newline \textit{3 Passes:} 1. Read/write partitions for $r$. 2. Read/write partitions for $s$. 3. Join partitions.
        \newline \textit{Requirement:} Partitions of smaller relation must fit in memory.
        \item \textbf{Hybrid Hash Join:} $b_r + b_s$ (best case).
        \newline \textit{Optimization:} If entire build relation fits in memory, skip disk writes for some partitions.
    \end{itemize}

    \paragraph{Writing the Result}\mbox{}\\
    Chi phí trên chỉ ước tính *processing*. Phải cộng thêm write cost (chi phí ghi) để có tổng chi phí.
    \begin{itemize}[leftmargin=*, label={--}]
        \item \textbf{Write Cost:} $jc / bfr_{result}$ blocks.
        \item \textbf{Total Cost:} Processing Cost + $(js \times |R| \times |S|) / bfr_{result}$.
    \end{itemize}
    \columnbreak
    \subsubsection{Example: EMPLOYEE $\bowtie$ DEPARTMENT}
    \textbf{Scenario:} EMPLOYEE ($|E|=10{,}000$, $b_E=2{,}000$) $\bowtie_{Dno=Dnumber}$ DEPARTMENT ($|D|=125$, $b_D=13$).
    \newline \textbf{Indices:} Secondary on $E.Dno$ ($x=2$, $s=80$). Primary on $D.Dnumber$ ($x=1$).
    \newline \textbf{Parameters:} $js=1/125$, $jc=10{,}000$, $bfr_{result}=4$ $\rightarrow$ write cost $= 2{,}500$ blocks. $n_B=3$ buffers.

    \begin{itemize}[leftmargin=*, label={--}]
        \item \textbf{J1: Block Nested-Loop (D outer):} 
        \newline $C = 13 + \lceil 13/1 \rceil \times 2{,}000 + 2{,}500 = 13 + 26{,}000 + 2{,}500 = \mathbf{28{,}513}$ blocks.
        \newline \textit{Explanation:} Đọc D (13) + scan E 13 lần (26,000) + ghi kết quả (2,500).

        \item \textbf{J2a: Indexed Nested-Loop (D outer $\to$ E inner):} 
        \newline $C = 13 + 125 \times (2 + 80) + 2{,}500 = 13 + 10{,}250 + 2{,}500 = \mathbf{12{,}763}$ blocks.
        \newline \textit{Explanation:} Đọc D (13) + 125 lookups trên E (mỗi lần: 2 index + 80 scattered records) + ghi.

        \item \textbf{J2b: Indexed Nested-Loop (E outer $\to$ D inner):} 
        \newline $C = 2{,}000 + 10{,}000 \times (1 + 1) + 2{,}500 = 2{,}000 + 20{,}000 + 2{,}500 = \mathbf{24{,}500}$ blocks.
        \newline \textit{Explanation:} Đọc E (2,000) + 10,000 lookups trên D (mỗi lần: 1 index + 1 data block) + ghi.

        \item \textbf{J3: Sort-Merge (if already sorted):}
        \newline $C = 2{,}000 + 13 + 2{,}500 = \mathbf{4{,}513}$ blocks.
        \newline \textit{Best case:} Chỉ đọc cả hai quan hệ một lần + ghi kết quả.
        \newline \textit{If not sorted:} Cộng thêm sorting cost (thường $\approx 2b \log b$ per relation).

        \item \textbf{J4: Hash Join:}
        \newline $C = 3 \times (2{,}000 + 13) + 2{,}500 = 6{,}039 + 2{,}500 = \mathbf{8{,}539}$ blocks.
        \newline \textit{Explanation:} 3 passes qua cả hai quan hệ (partition + build + probe) + ghi kết quả.
    \end{itemize}

    \paragraph{Decision Ranking}\mbox{}\\
    J3 (if sorted) $<$ J4 $<$ J2a $<$ J2b $<$ J1.
    \begin{itemize}[leftmargin=*, label={--}]
        \item \textbf{Best:} Sort-Merge nếu đã sorted (4,513).
        \item \textbf{Good:} Hash Join nếu chưa sorted (8,539) - không có sorting overhead.
        \item \textbf{Moderate:} Indexed Nested-Loop với small outer (12,763).
        \item \textbf{Avoid:} Block Nested-Loop (28,513) - chỉ dùng khi không có index/memory.
    \end{itemize}

    % ============================================================================
    % OPTIMIZATION STRATEGIES
    % ============================================================================
    \subsection{Quy trình Tối ưu hóa Truy vấn (Query Optimization Process)}

    \subsubsection{Tổng quan Quy trình}
    \begin{enumerate}[leftmargin=*]
        \item \textbf{Parse \& Validate:} Kiểm tra cú pháp (syntax), tuân thủ schema (schema compliance).
        \item \textbf{Translate:} Chuyển SQL sang relational algebra (đại số quan hệ) - tạo query tree (cây truy vấn) canonical.
        \item \textbf{Heuristic Optimization (Tối ưu Kinh nghiệm):} Áp dụng equivalence rules (quy tắc tương đương) để restructure tree.
        \item \textbf{Cost-Based Optimization (Tối ưu Dựa Chi phí):} Liệt kê execution plans (kế hoạch thực thi), ước tính cost, chọn plan tối ưu.
        \item \textbf{Execution (Thực thi):} Materialization (hiện thực hóa) kết quả trung gian hoặc pipelining.
    \end{enumerate}
    
    \subsubsection{Heuristic Optimization}
    \textit{Mục tiêu:} Transform initial query tree thành equivalent tree hiệu quả hơn mà không cần estimate cost chi tiết.
    
    \paragraph{3 Quy tắc Heuristic Cốt lõi}
    \begin{enumerate}[leftmargin=*, label={\textbf{\arabic*.}}]
        \item \textbf{Perform Selections Early ($\sigma$ down):} Đẩy selection xuống gần leaf nodes (quan hệ gốc).
        \newline \textit{Lý do:} Giảm số tuples (rows) trước khi join $\rightarrow$ intermediate results nhỏ hơn.
        \item \textbf{Perform Projections Early ($\pi$ down):} Đẩy projection xuống để giảm số attributes (columns).
        \newline \textit{Lý do:} Giảm "chiều rộng" quan hệ trung gian $\rightarrow$ tiết kiệm memory.
        \item \textbf{Avoid Cartesian Products ($\times$):} Combine Cartesian product + selection thành Join ($\bowtie$).
        \newline \textit{Lý do:} Cartesian product tạo intermediate relations cực lớn - rất tốn kém.
    \end{enumerate}

    \paragraph{Transformation Rules (Quy tắc Biến đổi)}
    \begin{itemize}[leftmargin=*, label={--}]
        \item \textbf{Cascading of Selections:} $\sigma_{c1 \land c2}(R) = \sigma_{c1}(\sigma_{c2}(R))$.
        \newline \textit{Ứng dụng:} Break conjunctive conditions để move các parts xuống different branches.
        \item \textbf{Commutativity (Giao hoán):} $\sigma_{c1}(R \bowtie S) = (\sigma_{c1}(R)) \bowtie S$ (nếu $c1$ chỉ liên quan $R$).
        \newline \textit{Ứng dụng:} Push selections down past joins.
        \item \textbf{Associativity (Kết hợp):} $(R \bowtie S) \bowtie T = R \bowtie (S \bowtie T)$.
        \newline \textit{Ứng dụng:} Reorder join sequence để most restrictive joins (joins có selectivity cao nhất) xảy ra trước.
    \end{itemize}

    \paragraph{Heuristic Algorithm (6 bước)}
    \begin{enumerate}[leftmargin=*, label={\textbf{\arabic*.}}]
        \item \textbf{Break up Selections:} Dùng cascading rule để tách conjunctive select conditions.
        \item \textbf{Move Selections Down:} Đẩy $\sigma$ xuống xa nhất có thể (dùng commutativity).
        \item \textbf{Reorder Leaf Nodes:} Sắp xếp lại leaf nodes (relations) - quan hệ có most restrictive selection (selectivity thấp nhất) trước.
        \item \textbf{Form Joins:} Combine Cartesian products với subsequent selections thành Join operations.
        \item \textbf{Move Projections Down:} Break projection lists, chỉ giữ attributes cần thiết cho query result hoặc subsequent operations.
        \item \textbf{Identify Subtrees:} Nhóm operations có thể thực thi bởi single algorithm (vd: single access method).
    \end{enumerate}

    \paragraph{Trade-offs \& Limitations}
    \begin{itemize}[leftmargin=*, label={--}]
        \item \textbf{Not Always Optimal:} Heuristics giảm optimization cost nhưng không đảm bảo tìm optimal plan.
        \newline \textit{VD:} "Selection early" thường tốt, nhưng nếu selection cần scan large relation mà join có efficient index, join trước có thể rẻ hơn.
        \item \textbf{Hybrid Approaches:} Commercial optimizers kết hợp cả hai.
        \newline \textit{System R:} Heuristics (chỉ xét left-deep trees) + cost-based (trong constraints đó).
        \newline \textit{Oracle:} Heuristics rank access paths + cost-based chọn join methods.
    \end{itemize}

    \subsubsection{Cost-Based Optimization}
    Sau khi heuristic optimization, system estimate cost cho remaining candidate plans.
    \begin{itemize}[leftmargin=*, label={--}]
        \item \textbf{Chọn Access Path:} So sánh full scan, clustering index, secondary index, bitmap cho mỗi predicate (vị từ).
        \item \textbf{Chọn Join Algorithm:} Nested-loop (index/block), hash join, sort-merge dựa trên tuple count và available memory ($n_B$).
        \item \textbf{Chọn Join Order:} Ước lượng join selectivity $js \approx 1/\max(NDV(A), NDV(B))$; join cardinality $jc = js \times |R| \times |S|$.
        \newline \textit{Strategy:} Dynamic programming (System R) - build optimal plan cho subqueries, combine lên.
    \end{itemize}

    \subsubsection{Left-Deep Trees}
    \textit{Constraint phổ biến trong cost-based optimization để giảm search space.}
    \begin{itemize}[leftmargin=*, label={--}]
        \item \textbf{Đặc điểm:} Right child (con phải) luôn là base table (bảng cơ sở), không phải intermediate result.
        \item \textbf{Lợi ích:} 
        \begin{itemize}
            \item Cho phép index lookups trên right child.
            \item Giảm exponential search space (chỉ $n!$ thay vì $O(4^n)$ bushy trees).
            \item Enable pipelining - không cần materialize mọi intermediate results.
        \end{itemize}
        \item \textbf{Nhược điểm:} Có thể bỏ lỡ optimal bushy tree plans, nhưng trade-off chấp nhận được cho performance.
    \end{itemize}

    % ============================================================================
    % SECTION: Big Data & Data Engineering
    % ============================================================================
    \section{Big Data \& Data Engineering}

    % ============================================================================
    % TIER 1: FOUNDATIONAL CONCEPTS
    % ============================================================================
    \subsection{Đặc trưng Big Data (The Vs)}
    \begin{itemize}[leftmargin=*, label={--}]
        \item \textbf{5V Cốt lõi (Core):}
        \begin{itemize}
            \item \textbf{Volume:} Dung lượng khổng lồ (TB, PB, ZB).
            \item \textbf{Velocity:} Tốc độ sinh ra \& xử lý (Batch $\to$ Streaming).
            \item \textbf{Variety:} Đa dạng định dạng (Structured, JSON, Video, Log).
            \item \textbf{Veracity:} Độ tin cậy, tính xác thực (Messy/Noisy data).
            \item \textbf{Value:} Giá trị chuyển hóa thành lợi ích kinh doanh.
        \end{itemize}
        
        \item \textbf{Các V Mở rộng (Extended):}
        \begin{itemize}
            \item \textbf{Variability:} Tính biến thiên (Ý nghĩa dữ liệu thay đổi theo ngữ cảnh/thời gian).
            \item \textbf{Validity:} Tính hợp lệ (Dữ liệu có đúng định dạng/chuẩn để dùng không).
            \item \textbf{Vulnerability:} Tính bảo mật (Dễ bị tấn công/rò rỉ).
            \item \textbf{Volatility:} Độ bay hơi (Thời gian lưu trữ trước khi xóa/lưu trữ lâu dài).
            \item \textbf{Visualization:} Khả năng trực quan hóa (Để con người hiểu được).
        \end{itemize}
    \end{itemize}

    \columnbreak

    \subsection{Paradigm: Batch vs Streaming}
    \textit{Hai mô hình xử lý dữ liệu cơ bản trong Big Data.}
    \begin{center}
        \renewcommand{\arraystretch}{1.2}
        \begin{tabular}{@{} p{0.15\linewidth} | p{0.38\linewidth} | p{0.38\linewidth} @{}}
            \toprule
            & \textbf{Batch Processing} & \textbf{Streaming Processing} \\
            \midrule
            \textbf{Đặc trưng} & Xử lý dữ liệu tĩnh, lượng lớn theo lô. & Xử lý dữ liệu động, liên tục theo thời gian thực. \\
            \textbf{Độ trễ} & Cao (minutes - hours). & Thấp (seconds - milliseconds). \\
            \textbf{Công cụ} & Hadoop MapReduce, Apache Spark (Batch mode). & Apache Flink, Spark Streaming, Kafka Streams. \\
            \textbf{Use Case} & ETL, báo cáo cuối ngày, ML training. & Real-time analytics, fraud detection, monitoring. \\
            \textbf{Ưu điểm} & Xử lý hiệu quả khối lượng lớn, đơn giản. & Phản hồi nhanh, phát hiện sự kiện ngay lập tức. \\
            \textbf{Nhược điểm} & Không real-time, lãng phí khi data nhỏ. & Phức tạp, khó debug, cần xử lý out-of-order. \\
            \bottomrule
        \end{tabular}
    \end{center}
    \textbf{Kiến trúc Lai (Hybrid):}
    \begin{itemize}[leftmargin=*, label={--}]
        \item \textbf{Lambda Architecture:} Batch layer (chính xác) + Speed layer (real-time) + Serving layer. Phức tạp, duy trì 2 code base.
        \item \textbf{Kappa Architecture:} Chỉ dùng Streaming (đơn giản hóa). Mọi dữ liệu qua stream processor, replay từ Kafka khi cần.
    \end{itemize}

    \subsection{Partitioning \& Replication}
    
    \subsubsection{Sao chép (Replication)}
    \textit{Mục đích: High Availability (HA) và giảm độ trễ đọc.}
    \begin{itemize}[leftmargin=*, label={--}]
        \item \textbf{Single-Leader (Master-Slave):} Mọi ghi vào Leader, Leader chép sang Followers. \textit{Dễ nhất quán, nhưng Leader là nút cổ chai.}
        \item \textbf{Multi-Leader:} Nhiều node chấp nhận ghi. \textit{Tốt cho đa trung tâm dữ liệu, nhưng khó xử lý xung đột.}
        \item \textbf{Leaderless (Dynamo-style):} Ghi/Đọc gửi tới nhiều node. Dùng cơ chế \textbf{Quorum} để xác nhận:
        \newline $w + r > n$ (Write nodes + Read nodes > Total replicas) $\rightarrow$ Đảm bảo đọc thấy dữ liệu mới nhất.
    \end{itemize}

    \subsubsection{Phân mảnh (Partitioning/Sharding)}
    \textit{Mục đích: Scalability (Mở rộng dung lượng/băng thông).}
    \begin{itemize}[leftmargin=*, label={--}]
        \item \textbf{Key Range Partitioning:} Chia theo khoảng khóa (A-C, D-F). 
        \newline $\rightarrow$ \textit{Ưu:} Query theo khoảng (Range scan) hiệu quả. 
        \newline $\rightarrow$ \textit{Nhược:} Dễ bị \textit{Hotspot} (nếu user dồn vào vần A).
        \item \textbf{Hash Partitioning:} Băm khóa để chia đều ($hash(key) \% N$).
        \newline $\rightarrow$ \textit{Ưu:} Phân phối đều, tránh Hotspot.
        \newline $\rightarrow$ \textit{Nhược:} Mất khả năng Range Query (phải quét tất cả).
    \end{itemize}

    \subsection{Định dạng Lưu trữ (File Formats)}
    \textit{Lựa chọn định dạng ảnh hưởng trực tiếp đến hiệu năng đọc/ghi.}
    
    \subsubsection{Row-based vs. Column-based}
    \begin{itemize}[leftmargin=*, label={--}]
        \item \textbf{Row-oriented (CSV, Avro):}
        \begin{itemize}
            \item Lưu trữ tuần tự từng dòng.
            \item \textit{Ưu điểm:} Ghi nhanh (append), tốt khi truy xuất toàn bộ thông tin của 1 entity (OLTP).
            \item \textit{Nhược điểm:} Chậm khi tính toán tổng hợp (SUM, AVG) vì phải đọc cả dữ liệu không cần thiết.
        \end{itemize}
        \item \textbf{Column-oriented (Parquet, ORC):}
        \begin{itemize}
            \item Lưu trữ riêng biệt từng cột.
            \item \textit{Ưu điểm:} Nén cực tốt (do dữ liệu cùng kiểu), tối ưu cho OLAP (chỉ đọc cột cần thiết).
            \item \textit{Nhược điểm:} Ghi chậm, update tốn kém.
        \end{itemize}
    \end{itemize}

    \subsubsection{So sánh Avro, Parquet, ORC}
    \begin{center}
    \renewcommand{\arraystretch}{1.1}
    \begin{tabular}{@{} l l l @{}}
        \toprule
        \textbf{Đặc điểm} & \textbf{Avro} & \textbf{Parquet} \\
        \midrule
        \textbf{Mô hình} & Row-based & Column-based \\
        \textbf{Schema} & JSON (lưu trong file) & Binary (footer) \\
        \textbf{Tối ưu cho} & Ghi nhiều (Write heavy) & Đọc nhiều (Read heavy) \\
        \textbf{Schema Evo} & Rất tốt (Thêm/bớt field) & Hạn chế \\
        \textbf{Ecosystem} & Kafka, Hadoop & Spark, Impala, Presto \\
        \bottomrule
    \end{tabular}
    \end{center}

    % ============================================================================
    % TIER 2: STORAGE LAYER
    % ============================================================================
    \subsection{Hadoop Ecosystem}
    \textit{Open-source framework for distributed storage and processing.}
    \begin{enumerate}[leftmargin=*, label={\textbf{\arabic*.}}]
        \item \textbf{HDFS (Storage):} Distributed file system.
        \begin{itemize}
            \item \textit{NameNode:} Manages metadata (block locations).
            \item \textit{DataNode:} Stores actual data blocks.
            \item \textit{Mechanism:} Splits files into blocks (128MB), replicates (x3) for fault tolerance.
        \end{itemize}
        \item \textbf{YARN (Resource Management):} "Operating system" of the cluster.
        \begin{itemize}
            \item Distributes resources (RAM, CPU) to applications.
            \item Allows multiple engines (Spark, MapReduce) to run on the same cluster.
        \end{itemize}
        \item \textbf{MapReduce (Processing):} Batch processing model - divide and conquer on a distributed cluster.
        \begin{itemize}
            \item \textit{Map:} Chia nhỏ \& Gán nhãn. Input $\rightarrow$ Split $\rightarrow$ \texttt{<Key, Value>}.
            \item \textit{Shuffle:} Xáo trộn \& Gom nhóm. Chuyển dữ liệu qua mạng, gom cùng Key.
            \item \textit{Reduce:} Tổng hợp. Xử lý danh sách Value của mỗi Key.
        \end{itemize}
    \end{enumerate}

    \subsection{Công nghệ NoSQL (Storage Tech)}
    \textit{Các mô hình NoSQL cho use case khác nhau.}

    \paragraph{MongoDB (Document Store)}
    \begin{itemize}[leftmargin=*, label={--}]
        \item \textbf{Mô hình:} Schema-on-read, lưu trữ JSON/BSON documents. Collections thay vì tables.
        \item \textbf{Ưu điểm:} Linh hoạt schema (mỗi doc có cấu trúc khác nhau), dễ scale horizontal (sharding), query mạnh (aggregation pipeline).
        \item \textbf{Architecture:} Replica Sets (HA), Sharding (scale-out), WiredTiger storage engine.
        \item \textbf{Use Case:} CMS, Mobile apps, Catalog, Real-time analytics. \textit{VD: Forbes, eBay, Uber.}
        \item \textbf{Trade-offs:} Không ACID cross-document (trước v4.0), chiếm RAM nhiều.
    \end{itemize}

    \paragraph{Redis (Key-Value Store)}
    \begin{itemize}[leftmargin=*, label={--}]
        \item \textbf{Mô hình:} In-memory key-value, data structures (String, Hash, List, Set, Sorted Set).
        \item \textbf{Ưu điểm:} Cực nhanh ($<1$ms latency), atomic operations, support pub/sub, Lua scripting.
        \item \textbf{Persistence:} RDB (snapshot) hoặc AOF (append-only log). Có thể dùng cả 2.
        \item \textbf{Use Case:} Caching (session, query result), Message Queue (Celery), Leaderboard, Rate limiting. \textit{VD: Twitter, GitHub, Stack Overflow.}
        \item \textbf{Trade-offs:} Giới hạn RAM, single-threaded (1 core), không có query phức tạp.
    \end{itemize}

    \paragraph{Cassandra (Wide-Column Store)}
    \begin{itemize}[leftmargin=*, label={--}]
        \item \textbf{Mô hình:} Wide-column, mỗi row có thể có số cột khác nhau. Organize theo Column Family.
        \item \textbf{Ưu điểm:} Ghi cực nhanh (LSM Tree), linear scalability, masterless (P2P), multi-datacenter replication.
        \item \textbf{Architecture:} Consistent hashing (ring), tunable consistency (quorum), compaction strategies.
        \item \textbf{Use Case:} Time-series data, IoT sensor logs, Event logging, Messaging. \textit{VD: Netflix, Apple, Instagram.}
        \item \textbf{Trade-offs:} Đọc chậm hơn (nhiều SSTable), không join, modeling phức tạp (query-first design).
    \end{itemize}

    \paragraph{Neo4j (Graph Database)}
    \begin{itemize}[leftmargin=*, label={--}]
        \item \textbf{Mô hình:} Nodes (entities) + Relationships (edges) + Properties. Native graph storage.
        \item \textbf{Ưu điểm:} Traversal cực nhanh (follow pointers), query trực quan (Cypher), ACID transactions.
        \item \textbf{Architecture:} Index-free adjacency (mỗi node chứa pointer đến neighbors).
        \item \textbf{Use Case:} Social networks, Recommendation engines, Fraud detection, Knowledge graphs. \textit{VD: LinkedIn, Walmart, eBay.}
        \item \textbf{Trade-offs:} Scale khó hơn NoSQL khác, không tốt cho bulk data processing.
    \end{itemize}

    \columnbreak
    % ============================================================================
    % TIER 3: PROCESSING LAYER
    % ============================================================================
    \subsection{Batch Processing}

    \subsubsection{Apache Spark (Unified Analytics Engine)}
    \textit{Thay thế MapReduce với tốc độ cao hơn 100x (in-memory).}
    \begin{itemize}[leftmargin=*, label={--}]
        \item \textbf{Core Concept:} RDD (Resilient Distributed Dataset) - immutable, partitioned, parallel.
        \begin{itemize}
            \item \textit{Transformations:} Lazy (map, filter, join) - tạo DAG.
            \item \textit{Actions:} Eager (collect, count, save) - trigger execution.
        \end{itemize}
        \item \textbf{Components:}
        \begin{itemize}
            \item \textit{Spark SQL:} Query structured data (DataFrame/Dataset API).
            \item \textit{Spark Streaming:} Micro-batch streaming (DStream).
            \item \textit{MLlib:} Machine learning library (classification, clustering, etc.).
            \item \textit{GraphX:} Graph processing (PageRank, connected components).
        \end{itemize}
        \item \textbf{Ưu điểm:} In-memory caching, lazy evaluation, DAG optimization, unified API (batch + streaming).
        \item \textbf{Nhược điểm:} Tốn RAM, không true streaming (micro-batch), overhead cho job nhỏ.
        \item \textbf{Use Case:} ETL, ML training, interactive analytics, log processing. \textit{VD: Netflix, Uber, Airbnb.}
    \end{itemize}

    % --- PHẦN 4: XỬ LÝ LUỒNG (STREAMING) ---
    \subsection{Streaming Processing}
    \textit{Xử lý dữ liệu liên tục, độ trễ thấp (Real-time).}
    
    \subsubsection{Các chiến lược xử lý (Strategies)}
    \begin{itemize}[leftmargin=*, label={--}]
        \item \textbf{Thời gian (Time Domain):}
        \begin{itemize}
            \item \textit{Event Time:} Thời gian sự kiện xảy ra (quan trọng nhất).
            \item \textit{Processing Time:} Thời gian hệ thống nhận được dữ liệu.
            \item \textit{Watermark:} Cơ chế xử lý độ trễ (data đến muộn) trong Event Time.
        \end{itemize}
        \item \textbf{Cửa sổ (Windowing):}
        \begin{itemize}
            \item \textit{Tumbling:} Cố định, không chồng (vd: mỗi 5p).
            \item \textit{Hopping/Sliding:} Có chồng lấp (vd: 5p, trượt mỗi 1p).
            \item \textit{Session:} Dựa trên hoạt động người dùng (hết timeout thì đóng).
        \end{itemize}
        \item \textbf{Đảm bảo (Guarantees):}
        \begin{itemize}
            \item \textit{At-most-once:} Gửi 1 lần, chấp nhận mất (vd: Log).
            \item \textit{At-least-once:} Không mất, chấp nhận trùng lặp.
            \item \textit{Exactly-once:} Chính xác 1 lần (Khó nhất, cần Flink/Kafka).
        \end{itemize}
    \end{itemize}

    \columnbreak

    % ============================================================================
    % TIER 4: INTEGRATION & ORCHESTRATION
    % ============================================================================
    \subsection{Giao thức IoT (IoT Protocols)}
    \textit{Context:} Internet of Things - kết nối sensors, devices, machinery vào internet $\rightarrow$ số devices $>$ số người trên internet $\rightarrow$ massive streaming data generation.
    
    \subsubsection{MQTT (Message Queue Telemetry Transport)}
    \textit{Open standard (OASIS, ISO/IEC 20922) for Machine-to-Machine (M2M) communication.}
    
    \paragraph{Design Philosophy}\mbox{}\\
    Được thiết kế cho \textbf{constrained devices (thiết bị hạn chế)} trong môi trường mạng khó khăn:
    \begin{itemize}[leftmargin=*, label={--}]
        \item \textbf{Low bandwidth (băng thông thấp):} Minimized data packets (gói dữ liệu tối thiểu).
        \item \textbf{High latency (độ trễ cao):} Tối ưu cho mạng chậm.
        \item \textbf{Unreliable networks (mạng không ổn định):} Xử lý mất kết nối, chập chờn.
        \item \textbf{Low power usage:} Tiết kiệm pin cho IoT devices.
        \item \textbf{Real-time processing:} Hỗ trợ xử lý real-time cho streaming data.
    \end{itemize}

    \paragraph{Architecture: Publish-Subscribe Model}\mbox{}\\
    Khác với client-server truyền thống (client connect trực tiếp client), MQTT dùng \textbf{pub-sub model}.
    \begin{itemize}[leftmargin=*, label={--}]
        \item \textbf{Broker:} Central component nhận published messages và deliver đến subscribers phù hợp.
        \newline \textit{Flow:} Client gửi \texttt{CONNECT} $\rightarrow$ Broker trả \texttt{CONNACK}.
        \item \textbf{Publisher:} Client publish message đến broker với specific topic.
        \item \textbf{Subscriber:} Client listen incoming messages trên particular topics.
        \item \textbf{Advantage:} Decoupling (tách rời) - publisher không cần biết subscriber, scale dễ dàng.
    \end{itemize}

    \paragraph{Topics (Routing Mechanism)}\mbox{}\\
    \textbf{Structure:} Hierarchical strings với topic levels phân cách bởi \texttt{/}.
    \begin{center}
        \renewcommand{\arraystretch}{1.15}
        \begin{tabular}{@{} p{0.15\linewidth} | l | p{0.50\linewidth} @{}}
            \toprule
            \textbf{Type} & \textbf{Pattern} & \textbf{Matches \& Description} \\
            \midrule
            \textbf{Exact} & \texttt{area1/humidity} & Chỉ match chính xác topic này. \textit{Use:} Specific sensor. \\
            \addlinespace[2pt]
            \textbf{Single-level} & \texttt{area1/+} & \texttt{+} matches \textit{1} level bất kỳ.\newline $\checkmark$ \texttt{area1/humidity}, \texttt{area1/light}\newline $\times$ \texttt{area1/sensors/temp} \\
            \addlinespace[2pt]
            \textbf{Multi-level} & \texttt{area1/\#} & \texttt{\#} matches \textit{tất cả} levels.\newline $\checkmark$ \texttt{area1/humidity}, \texttt{area1/sensors/temp}\newline $\checkmark$ \texttt{area1/zone2/light} \\
            \addlinespace[2pt]
            \textbf{Root wildcard} & \texttt{\#} & Matches \textit{everything} in broker.\newline (Use with caution - high load) \\
            \bottomrule
        \end{tabular}
    \end{center}
    \textit{Smart Farming Example:} Publisher sends \texttt{area1/humidity:65\%} $\rightarrow$ Subscribers với patterns \texttt{area1/humidity}, \texttt{area1/+}, hoặc \texttt{area1/\#} đều nhận được.

    \columnbreak

    \paragraph{Quality of Service (QoS) Levels}\mbox{}\\
    Để xử lý network reliability khác nhau, MQTT định nghĩa 3 QoS levels:
    \begin{center}
        \renewcommand{\arraystretch}{1.15}
        \begin{tabular}{@{} c | l | p{0.55\linewidth} @{}}
            \toprule
            \textbf{Level} & \textbf{Guarantee} & \textbf{Mechanism \& Use Case} \\
            \midrule
            \textbf{0} & At most once & Delivered once, no confirmation. Fast, có thể mất message. \textit{Use:} Sensor readings không critical. \\
            \textbf{1} & At least once & Delivered ít nhất 1 lần, requires confirmation (ACK). Có thể duplicate. \textit{Use:} Important data. \\
            \textbf{2} & Exactly once & Four-step handshake. Chậm nhất nhưng không duplicate. \textit{Use:} Financial transactions, critical commands. \\
            \bottomrule
        \end{tabular}
    \end{center}
    \textit{Note:} Actual QoS = min(Publisher QoS, Subscriber QoS).

    \paragraph{Practical Application: Smart Farming}
    \begin{itemize}[leftmargin=*, label={--}]
        \item \textbf{Sensors (Publishers):}
        \begin{itemize}
            \item \textit{DHT11:} Temperature \& air humidity.
            \item \textit{BH1750:} Luminosity (độ sáng).
            \item \textit{DHT22:} Soil moisture (độ ẩm đất).
        \end{itemize}
        \item \textbf{Flow:} Sensors publish data đến broker với topics như \texttt{area1/moisture} $\rightarrow$ Management system subscribes topics $\rightarrow$ Real-time monitoring \& decision making.
        \item \textbf{Benefits:} Cost-effective, scalable, knowledge base creation cho farming management.
    \end{itemize}
    
    \subsubsection{MQTT vs HTTP Comparison}
    \begin{center}
        \renewcommand{\arraystretch}{1.2}
        \begin{tabular}{@{} l | p{0.40\linewidth} | p{0.40\linewidth} @{}}
            \toprule
            \textbf{Aspect} & \textbf{HTTP (HyperText Transfer)} & \textbf{MQTT (Message Queuing)} \\
            \midrule
            \textbf{Model} & Request-Response\newline (Client-Server) & Publish-Subscribe\newline (qua Broker) \\
            \addlinespace[2pt]
            \textbf{Connection} & Short-lived\newline (đóng sau request) & Persistent\newline (Keep-alive, lightweight) \\
            \addlinespace[2pt]
            \textbf{Header Size} & Large (KB range)\newline Cồng kềnh metadata & Very small (2 bytes)\newline Tiết kiệm bandwidth \\
            \addlinespace[2pt]
            \textbf{Power} & High consumption & Low power\newline (tối ưu battery devices) \\
            \addlinespace[2pt]
            \textbf{Network} & Reliable networks & Unreliable networks\newline (chập chờn, high latency) \\
            \addlinespace[2pt]
            \textbf{Use Cases} & • Web browsing\newline • REST APIs\newline • Large file transfers & • IoT sensors\newline • M2M communication\newline • Constrained devices \\
            \bottomrule
        \end{tabular}
    \end{center}
    \textit{Key Insight:} HTTP designed cho human-to-machine (web), MQTT designed cho machine-to-machine (IoT).

    % --- PHẦN 5: PIPELINES & ORCHESTRATION ---
    \subsection{Pipelines \& Orchestration}
    
    \subsubsection{Apache Kafka vs Airflow}
    \begin{center}
        \renewcommand{\arraystretch}{1.2} % Adjust row height for readability
        \begin{tabular}{@{} >{\raggedright\arraybackslash}p{0.48\linewidth} >{\raggedright\arraybackslash}p{0.48\linewidth} @{}}
            \toprule
            \textbf{Apache Kafka} & \textbf{Apache Airflow} \\
            \midrule
            
            \textbf{Loại:} Event Streaming Platform (Message Broker). & 
            \textbf{Loại:} Workflow Orchestration (Quản lý quy trình). \\
            \addlinespace[4pt] % Extra space between sections
            
            \textbf{Đặc trưng:}
            \begin{itemize}[leftmargin=10pt, nosep, label=\tiny$\bullet$]
                \item Log bền vững (Durable log).
                \item Decoupling (Tách rời).
                \item Replayable, High throughput.
            \end{itemize} & 
            \textbf{Đặc trưng:}
            \begin{itemize}[leftmargin=10pt, nosep, label=\tiny$\bullet$]
                \item Code-as-infra (Python DAGs).
                \item Quản lý dependency phức tạp.
                \item Backfill (chạy lại quá khứ).
            \end{itemize} \\
            \addlinespace[4pt]
            
            \textbf{Vai trò:} "Xương sống" vận chuyển dữ liệu \textit{Real-time}. & 
            \textbf{Vai trò:} "Nhạc trưởng" điều phối Job (\textit{Batch/ETL}). \\
            \bottomrule
        \end{tabular}
    \end{center}

    \subsubsection{CDC (Change Data Capture)}
    \textit{Theo dõi và đồng bộ thay đổi từ database nguồn sang đích.}
    \begin{itemize}[leftmargin=*, label={--}]
        \item \textbf{Mục đích:} Real-time data replication, sync giữa OLTP và OLAP, event-driven architecture.
        \item \textbf{Cơ chế:}
        \begin{itemize}
            \item \textit{Log-based CDC:} Đọc database transaction log (binlog MySQL, WAL PostgreSQL). \textbf{Tốt nhất} - không ảnh hưởng source.
            \item \textit{Trigger-based:} Trigger trên INSERT/UPDATE/DELETE. Ảnh hưởng performance.
            \item \textit{Timestamp/Version-based:} Poll dựa trên \texttt{updated\_at} column. Thiếu DELETE events.
        \end{itemize}
        \item \textbf{Tools:} Debezium (Kafka Connect), AWS DMS, Oracle GoldenGate, Airbyte.
        \item \textbf{Use Case:} Sync OLTP $\to$ DW, Microservices data sharing, Cache invalidation, Audit logs.
        \item \textbf{Pattern:} Source DB $\to$ CDC Tool $\to$ Kafka $\to$ Sink (DW/Cache/Search).
    \end{itemize}

    \subsubsection{ETL vs ELT}
    \begin{itemize}[leftmargin=*, label={--}]
        \item \textbf{ETL (Extract-Transform-Load):} Transform \textit{trước} khi vào kho. Schema-on-write. Dữ liệu sạch, bảo mật. (Truyền thống).
        \item \textbf{ELT (Extract-Load-Transform):} Load raw vào kho \textit{trước}, transform sau. Schema-on-read. Tận dụng sức mạnh Cloud DW (BigQuery, Snowflake). (Hiện đại).
    \end{itemize}

    % ============================================================================
    % TIER 5: ANALYTICS & WAREHOUSING
    % ============================================================================
    \subsection{Kho Dữ liệu (Data Warehousing)}

    \subsubsection{OLTP vs OLAP}
    \begin{center}
        \renewcommand{\arraystretch}{1.2}
        \begin{tabular}{@{} p{0.15\linewidth} | p{0.38\linewidth} | p{0.38\linewidth} @{}}
            \toprule
            & \textbf{OLTP (Transactional)} & \textbf{OLAP (Analytical)} \\
            \midrule
            \textbf{Mục tiêu} & Vận hành hàng ngày (Operational). & Ra quyết định (Decision support). \\
            \textbf{Dữ liệu} & Hiện hành, chi tiết, cập nhật liên tục. & Lịch sử, tổng hợp, đa chiều. \\
            \textbf{Truy vấn} & Đơn giản, trả về ít dòng (Lookup). & Phức tạp, join nhiều, quét bảng lớn. \\
            \textbf{Thiết kế} & Chuẩn hóa cao (3NF) để tránh dị thường. & Phi chuẩn hóa (Star/Snowflake) để đọc nhanh. \\
            \textbf{User} & NV, App, Khách hàng. & Manager, Data Analyst. \\
            \bottomrule
        \end{tabular}
    \end{center}

    \subsubsection{4 Đặc trưng Chính (Inmon)}
    \begin{enumerate}[leftmargin=*, label={\textbf{\arabic*.}}]
        \item \textbf{Hướng chủ đề (Subject-oriented):} Tổ chức theo chủ đề chính (Khách hàng, Sản phẩm) thay vì theo ứng dụng (App Bán hàng, App Kho).
        \item \textbf{Tích hợp (Integrated):} Dữ liệu từ nhiều nguồn được làm sạch, đồng nhất (đơn vị, format, encoding) trước khi nạp.
        \item \textbf{Bất biến (Non-volatile):} Dữ liệu đã vào DW thì (thường) không bị sửa/xóa, chỉ đọc.
        \item \textbf{Biến thiên theo thời gian (Time-variant):} Mọi dữ liệu đều gắn với mốc thời gian để phân tích xu hướng (Historical data).
    \end{enumerate}

    \subsubsection{Thách thức Xây dựng DW}
    \begin{itemize}[leftmargin=*, label={--}]
        \item \textbf{Data Quality:} "Garbage In, Garbage Out". Dữ liệu nguồn bẩn làm sai lệch báo cáo.
        \item \textbf{ETL Complexity:} Tích hợp các hệ thống cũ (Legacy) rất phức tạp.
        \item \textbf{Performance:} Truy vấn phân tích tốn tài nguyên, cần tối ưu index/partition.
        \item \textbf{User Acceptance:} Người dùng không hiểu hoặc không tin tưởng dữ liệu.
        \item \textbf{Cost:} Chi phí lưu trữ và duy trì hạ tầng cao.
    \end{itemize}
    
    \subsubsection{Mô hình hóa (Modeling)}
    \begin{itemize}[leftmargin=*, label={--}]
        \item \textbf{Star Schema:} Fact ở giữa, Dimension xung quanh. Phi chuẩn hóa dimension. \textit{Hiệu năng cao, dễ query.}
        \item \textbf{Snowflake Schema:} Chuẩn hóa dimension (tách nhỏ). \textit{Tiết kiệm không gian, join phức tạp.}
    \end{itemize}

    \subsubsection{DW vs DL vs Lakehouse}
    \begin{itemize}[leftmargin=*, label={--}]
        \item \textbf{Data Warehouse:} Dữ liệu có cấu trúc, cho BI/Reporting.
        \item \textbf{Data Lake:} Dữ liệu thô (Raw), đa dạng, giá rẻ, cho ML/DS.
        \item \textbf{Lakehouse:} Kết hợp (Lưu trữ rẻ của Lake + Quản lý/ACID của Warehouse).
    \end{itemize}

    \subsubsection{SCD (Slowly Changing Dimensions)}
    \textit{Tại sao cần?} Để đảm bảo báo cáo lịch sử chính xác. Nếu KH chuyển từ HCM ra HN năm 2024, doanh số năm 2020 vẫn phải tính cho HCM.
    \begin{center}
        \renewcommand{\arraystretch}{1.2}
        \begin{tabular}{@{} c | p{0.32\linewidth} | p{0.5\linewidth} @{}}
            \toprule
            \textbf{Type} & \textbf{Chiến lược} & \textbf{Đặc điểm \& Use Case} \\
            \midrule
            \textbf{0} & \textbf{Retain Original:} Giữ nguyên, không bao giờ sửa. & 
            Dữ liệu gốc là chân lý. (VD: Ngày sinh). \\
            \hline
            \textbf{1} & \textbf{Overwrite:} Ghi đè giá trị mới lên cũ. & 
            Không cần lịch sử. Sửa lỗi chính tả. \\
            \hline
            \textbf{2} & \textbf{Add Row:} Thêm dòng mới + \textit{Effective Date} + \textit{Current\_Flag}. & 
            \textbf{Chuẩn mực nhất}. Theo dõi toàn bộ lịch sử biến động. \\
            \hline
            \textbf{3} & \textbf{Add Column:} Thêm cột \textit{Previous\_Value}. & 
            Chỉ cần biết giá trị liền trước. (Ít dùng). \\
            \hline
            \textbf{4} & \textbf{Add History Table:} Tách bảng lịch sử riêng (Mini-Dimension). & 
            Tối ưu khi bảng chính quá lớn và chỉ một nhóm thuộc tính thay đổi nhanh. \\
            \hline
            \textbf{5} & \textbf{Hybrid (4 + 1):} Mini-dimension + tham chiếu "Current" ở bảng chính. & 
            Tối ưu truy vấn khi cần cả lịch sử chi tiết và giá trị hiện tại nhanh chóng. \\
            \hline
            \textbf{6} & \textbf{Hybrid (1 + 2 + 3):} Type 2 row + cột chứa giá trị hiện tại (Type 1). & 
            \textit{"Pure Type 6"}: Giúp truy vấn lịch sử nhưng vẫn group by theo giá trị hiện tại dễ dàng. \\
            \hline
            \textbf{7} & \textbf{Hybrid (Dual Keys):} Fact table chứa cả \textit{Surrogate Key} (lịch sử) và \textit{Natural Key} (hiện tại). & 
            Linh hoạt nhất: Join theo Surrogate để xem lịch sử, join theo Natural để xem hiện tại. \\
            \bottomrule
        \end{tabular}
            \textit{Các kỹ thuật xử lý dữ liệu thay đổi theo thời gian (0 $\to$ 7).}

    \end{center}

    % ============================================================================
    % TIER 6: DATA MANAGEMENT & OPERATIONAL
    % ============================================================================
    \subsection{Quản lý Dữ liệu}

    \subsubsection{Vấn đề Tích hợp (Data Integration Issues)}
    \begin{itemize}[leftmargin=*, label={--}]
        \item \textbf{Heterogeneous data sources:} Khác biệt về hệ quản trị cơ sở dữ liệu và định dạng tệp.
        \newline \textit{VD: MySQL, PostgreSQL, Oracle, MongoDB, CSV, JSON, XML, Parquet.}
        
        \item \textbf{Data Mapping:} Khác biệt về cấu trúc schema giữa các nguồn.
        \newline \textit{VD: Bảng `Employee' (Full\_Name, DOB) vs `Emp' (First\_Name, Last\_Name, Birth\_Date).}
        
        \item \textbf{Data Conflicts:} Xung đột về kiểu dữ liệu, giá trị, định dạng, đơn vị, độ chính xác.
        \newline \textit{Kiểu:} String vs Integer cho mã nhân viên. \textit{Định dạng:} DD/MM/YYYY vs MM/DD/YYYY. 
        \newline \textit{Đơn vị:} USD vs VND, km vs miles. \textit{Độ chính xác:} 2 vs 4 chữ số thập phân.
        
        \item \textbf{Data Redundancy:} Dữ liệu trùng lặp từ nhiều nguồn cần khử trùng (Deduplication).
        \newline \textit{VD: Cùng khách hàng xuất hiện trong CRM và ERP với ID khác nhau.}
        
        \item \textbf{Entity Resolution:} Xác định 2 bản ghi từ 2 nguồn khác nhau là cùng 1 thực thể.
        \newline \textit{VD: `Nguyen Van A' (DB1) và `A Nguyen' (DB2), `IBM' vs `International Business Machines'.}
        \newline \textit{Kỹ thuật:} Fuzzy matching, similarity scores (Levenshtein distance), Master Data Management (MDM).
        
        \item \textbf{Constraints Violation:} Vi phạm ràng buộc khi tích hợp dữ liệu.
        \newline \textit{Primary Key:} Trùng lặp khóa chính khi merge. \textit{Foreign Key:} Tham chiếu không tồn tại.
        \newline \textit{Semantic:} Giá trị không hợp lệ (tuổi âm, ngày trong tương lai).
        
        \item \textbf{Data Quality Issues:} Các vấn đề chất lượng dữ liệu trong quá trình tích hợp.
        \newline \textit{Accuracy:} Sai lệch so với thực tế. \textit{Completeness:} Thiếu trường bắt buộc (NULL).
        \newline \textit{Uniqueness:} Trùng lặp. \textit{Timeliness:} Dữ liệu cũ/lỗi thời. \textit{Consistency:} Mâu thuẫn giữa các nguồn.
        
        \item \textbf{Communication Heterogeneity:} Khác biệt về giao diện và giao thức truyền thông.
        \newline \textit{VD: REST API vs SOAP, HTTP vs FTP, Batch files vs Real-time streams, GraphQL vs SQL.}
    \end{itemize}

    \subsubsection{Chiều Chất lượng Dữ liệu (Data Quality Dimensions)}
    \textit{Các tiêu chí đánh giá chất lượng dữ liệu trong hệ thống thông tin.}
    
    \paragraph{6 Chiều Cốt lõi (Core Dimensions)}
    \begin{enumerate}[leftmargin=*, label={\textbf{\arabic*.}}]
        \item \textbf{Accuracy (Chính xác):} Mức độ dữ liệu phản ánh đúng đối tượng/sự kiện thực tế.
        \newline \textit{Định nghĩa:} Sự không chính xác có nghĩa là hệ thống biểu diễn một trạng thái thế giới thực khác với trạng thái đáng lẽ phải được biểu diễn.
        \newline \textit{VD:} Địa chỉ sai, số điện thoại cũ, thông tin lỗi thời.
        
        \item \textbf{Completeness (Đầy đủ):} Tỷ lệ dữ liệu được lưu trữ so với khả năng 100\% hoàn chỉnh.
        \newline \textit{Định nghĩa:} Khả năng của hệ thống biểu diễn mọi trạng thái có nghĩa của hệ thống thế giới thực.
        \newline \textit{VD:} NULL values, missing fields, incomplete records (thiếu email, số điện thoại).
        
        \item \textbf{Consistency (Nhất quán):} Sự vắng mặt của sự khác biệt khi so sánh hai hoặc nhiều biểu diễn của cùng một thứ.
        \newline \textit{Định nghĩa:} Sự không nhất quán có nghĩa là ánh xạ biểu diễn là một-nhiều (one-to-many).
        \newline \textit{VD:} Tổng doanh thu trong bảng Orders $\neq$ tổng trong Report, tên KH khác nhau giữa CRM và ERP.
        
        \item \textbf{Validity (Hợp lệ):} Dữ liệu hợp lệ nếu tuân thủ cú pháp của định nghĩa (format, type, range).
        \newline \textit{VD:} Email đúng format (có @), tuổi trong khoảng [0, 150], enum đúng giá trị cho phép.
        
        \item \textbf{Timeliness (Kịp thời):} Mức độ dữ liệu phản ánh thực tế từ mốc thời gian yêu cầu.
        \newline \textit{Định nghĩa:} Độ trễ giữa thay đổi trạng thái thế giới thực và sửa đổi tương ứng trong hệ thống.
        \newline \textit{VD:} Giá cổ phiếu cập nhật delay 10s, báo cáo tồn kho cách 1 ngày (stale data).
        
        \item \textbf{Uniqueness (Duy nhất):} Không có thứ nào được ghi lại nhiều hơn một lần dựa trên cách xác định thứ đó.
        \newline \textit{VD:} Không có duplicate records, một khách hàng chỉ có một ID duy nhất.
    \end{enumerate}
    
    \paragraph{Các Chiều Mở rộng (Extended Dimensions)}
    \begin{itemize}[leftmargin=*, label={--}]
        \item \textbf{Interpretability (Khả năng Diễn giải):} Liên quan đến tài liệu và metadata có sẵn để diễn giải chính xác ý nghĩa và thuộc tính của nguồn dữ liệu.
        \newline \textit{VD:} Data dictionary, schema documentation, column descriptions, business glossary.
        
        \item \textbf{Accessibility (Khả năng Truy cập):} Đo lường khả năng người dùng truy cập dữ liệu từ văn hóa, trạng thái/chức năng vật lý và công nghệ có sẵn của họ.
        \newline \textit{VD:} API có rate limit, quyền truy cập dựa trên role (RBAC), hỗ trợ đa ngôn ngữ.
        
        \item \textbf{Usability (Khả dụng):} Đo lường hiệu quả, hiệu suất, sự hài lòng mà người dùng cụ thể cảm nhận và sử dụng dữ liệu.
        \newline \textit{VD:} Dashboard dễ hiểu, query response time nhanh, format phù hợp với use case.
        
        \item \textbf{Trustworthiness (Độ Tin cậy):} Đo lường mức độ đáng tin cậy của tổ chức trong việc cung cấp nguồn dữ liệu.
        \newline \textit{VD:} Data lineage rõ ràng, audit logs đầy đủ, SLA đảm bảo, data provenance.
    \end{itemize}

    \subsubsection{Quản lý Thông tin (Information Management)}
    \textit{Quản lý dữ liệu như một tài sản chiến lược của doanh nghiệp.}
    
    \paragraph{6 Khía cạnh Quản lý Thông tin}
    \begin{enumerate}[leftmargin=*, label={\textbf{\arabic*.}}]
        \item \textbf{Information Collection (Thu thập):} Xác định và thu thập dữ liệu từ các nguồn khác nhau.
        \newline \textit{Hoạt động:} Data ingestion, ETL pipelines, API integration, web scraping, sensors/IoT.
        \newline \textit{VD:} Crawl web data, stream từ Kafka, batch import từ CSV, CDC từ transactional DB.
        
        \item \textbf{Information Organization (Tổ chức):} Cấu trúc hóa và phân loại dữ liệu để dễ quản lý và truy xuất.
        \newline \textit{Hoạt động:} Schema design, data modeling (Star/Snowflake), taxonomy, metadata management.
        \newline \textit{VD:} Thiết kế DW dimensions/facts, tạo data catalog, tag dữ liệu theo domain.
        
        \item \textbf{Information Storage (Lưu trữ):} Chọn và triển khai hệ thống lưu trữ phù hợp với đặc điểm dữ liệu.
        \newline \textit{Hoạt động:} Chọn DBMS (RDBMS, NoSQL, DW), partitioning, replication, backup strategy.
        \newline \textit{VD:} OLTP trên PostgreSQL, OLAP trên Snowflake, unstructured data trên S3/Data Lake.
        
        \item \textbf{Information Manipulation (Thao tác):} Thực hiện các thao tác CRUD và chuyển đổi dữ liệu.
        \newline \textit{Hoạt động:} INSERT/UPDATE/DELETE, data transformation, cleansing, enrichment, aggregation.
        \newline \textit{VD:} Chuẩn hóa địa chỉ, deduplicate records, merge datasets, derive calculated fields.
        
        \item \textbf{Information Processing (Xử lý):} Phân tích và tính toán để tạo insights từ dữ liệu thô.
        \newline \textit{Hoạt động:} Query execution, analytics, ML training, reporting, dashboarding, data mining.
        \newline \textit{VD:} SQL queries, Spark jobs, BI reports, predictive models, real-time analytics.
        
        \item \textbf{Information Protection (Bảo vệ):} Đảm bảo an toàn, riêng tư và tuân thủ quy định.
        \newline \textit{Hoạt động:} Access control (RBAC), encryption (at-rest/in-transit), audit logging, compliance (GDPR).
        \newline \textit{VD:} Mã hóa PII, masking sensitive data, role-based permissions, backup/disaster recovery.
    \end{enumerate}
    
    \textit{Tổng thể:} Information Management bao gồm Data Governance (quản trị), Data Quality, Master Data Management (MDM), Security, và Lifecycle Management. Mục tiêu cuối cùng là đảm bảo dữ liệu \textbf{tin cậy, an toàn, dễ truy cập} để tạo giá trị kinh doanh.

    \subsection{Distributed Systems Challenges}
    \textit{Khác với hệ thống đơn, hệ phân tán đối mặt với \textbf{partial failures} - một số phần hỏng trong khi phần khác hoạt động.}
    
    \subsubsection{8 Fallacies (Ngụy biện) của Distributed Computing}
    \textit{Những giả định sai lầm mà lập trình viên thường mắc phải (L. Peter Deutsch, Sun Microsystems).}
    \begin{enumerate}[leftmargin=*, label={\textbf{\arabic*.}}]
        \item \textbf{The Network is Reliable:} Mạng không đáng tin cậy - switches hỏng, cables ngắt, packets bị mất/reorder.
        \item \textbf{Latency is Zero:} Local call (ns/$\mu$s) $\neq$ Remote call (ms). Chain calls $\rightarrow$ latency tích lũy.
        \item \textbf{Bandwidth is Infinite:} Băng thông hữu hạn. Stamp coupling (truyền dữ liệu thừa) gây bottleneck.
        \item \textbf{The Network is Secure:} Attack surface tăng. Mọi endpoint phải được bảo mật.
        \item \textbf{Topology Never Changes:} Topology thay đổi liên tục (upgrades, failures, scaling) $\rightarrow$ timeout/failures.
        \item \textbf{Only One Administrator:} Nhiều admin quản lý các segment khác nhau (firewall, DB) $\rightarrow$ khó phối hợp.
        \item \textbf{Transport Cost is Zero:} Serialization, marshalling, network infra đều tốn chi phí.
        \item \textbf{Network is Homogeneous:} Mạng gồm nhiều vendor (routers, switches) $\rightarrow$ packet loss, anomalies.
    \end{enumerate}
    
    \subsubsection{Unreliability: Network \& Time}
    \begin{itemize}[leftmargin=*, label={--}]
        \item \textbf{Network Unreliability:}
        \begin{itemize}
            \item \textit{Timeouts:} Không có bounded time $\rightarrow$ phải dùng timeout. Ngắn quá: false positive. Dài quá: delay detection.
            \item \textit{Network Partition (Netsplit):} Nhóm nodes bị cô lập $\rightarrow$ "Split brain" (2 leaders cùng chấp nhận ghi xung đột).
        \end{itemize}
        \item \textbf{Time Unreliability:} "Time is an illusion" - không có global clock.
        \begin{itemize}
            \item \textit{Clock Drift:} Đồng hồ quartz drift do nhiệt độ. Ngay cả NTP sync vẫn có sai lệch.
            \item \textit{Process Pauses:} GC hoặc VM suspension $\rightarrow$ node pause lâu hơn lease timeout $\rightarrow$ bị khai tử nhưng vẫn nghĩ mình sống $\rightarrow$ data corruption.
            \item \textit{Ordering Issues:} Last Write Wins (LWW) dùng timestamp nguy hiểm - clock không sync $\rightarrow$ ghi đè giá trị mới bằng cũ.
        \end{itemize}
    \end{itemize}
    
    \subsubsection{Consistency \& Consensus Challenges}
    \begin{itemize}[leftmargin=*, label={--}]
        \item \textbf{CAP Theorem:} Chỉ đạt 2/3: \textbf{C}onsistency, \textbf{A}vailability, \textbf{P}artition Tolerance. Partition không tránh được $\rightarrow$ chọn CP hoặc AP.
        \newline $\rightarrow$ \textit{NoSQL thường chọn AP (Sẵn sàng + Chịu lỗi) thay vì CP.}
        \item \textbf{FLP Impossibility:} Hệ async không thể đảm bảo consensus termination nếu có 1 node crash $\rightarrow$ phải dùng timeout.
        \item \textbf{Two Generals' Problem:} Không thể đạt common knowledge (chắc chắn đồng ý) qua kênh unreliable - ACK cuối cùng có thể bị mất.
        \item \textbf{BASE:} \textbf{B}asically \textbf{A}vailable, \textbf{S}oft state, \textbf{E}ventual consistency (Nhất quán cuối cùng - chấp nhận dữ liệu cũ tạm thời).
    \end{itemize}
    
    \subsubsection{Failure Models}
    \begin{itemize}[leftmargin=*, label={--}]
        \item \textbf{Crash Faults:} Process dừng hẳn, không bao giờ quay lại (đơn giản nhất).
        \item \textbf{Omission Faults:} Process bỏ qua bước hoặc không gửi/nhận message (buffer overflow, congestion).
        \item \textbf{Byzantine Faults:} Process hành xử tùy ý/độc hại, gửi message sai (khó nhất, blockchain).
    \end{itemize}
    
    \subsubsection{Managing "Truth" in Distributed Systems}
    \begin{itemize}[leftmargin=*, label={--}]
        \item \textbf{Truth by Majority:} Không node nào tin được view của chính mình. \textit{Sự thật = Quorum quyết định.}
        \newline \textit{VD:} Node tưởng mình là leader, nhưng quorum khai tử (do GC pause) $\rightarrow$ node đó "đã chết".
        \item \textbf{Fencing Tokens:} Số monotonic để storage từ chối ghi từ node cầm lock đã hết hạn (zombie nodes).
    \end{itemize}
    
    \subsubsection{Thách thức Xử lý Dữ liệu Phân tán}
    \begin{itemize}[leftmargin=*, label={--}]
        \item \textbf{Data Skew (Lệch dữ liệu):} Một partition chứa quá nhiều dữ liệu.
        \newline $\rightarrow$ \textit{Hậu quả:} Straggler problem - job đợi node chậm nhất.
        \newline $\rightarrow$ \textit{Giải pháp:} Salting (thêm prefix ngẫu nhiên) để chia nhỏ hot key.
        \item \textbf{Shuffle:} Chuyển dữ liệu giữa nodes qua mạng (Map $\to$ Reduce).
        \newline $\rightarrow$ \textit{Tối ưu:} Broadcast Join (chép bảng nhỏ đến tất cả node) để tránh shuffle bảng lớn.
    \end{itemize}
\end{multicols}
\end{document}