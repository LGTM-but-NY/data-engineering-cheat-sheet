%! TEX program = pdflatex
\documentclass[landscape]{article}
\sloppy
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{graphicx}
\usepackage{hyperref}
\usepackage{geometry}
\usepackage{ulem}
\usepackage{multicol} % for multi-column layout
\usepackage{xcolor}
\usepackage{booktabs}
\usepackage{array}
\usepackage[inline]{enumitem} % to tighten list spacing
\usepackage{fancyhdr} % for header and footer customization

% --- VIETNAMESE SUPPORT PACKAGES ---
\usepackage[utf8]{inputenc}
\usepackage[T5]{fontenc}
\usepackage[vietnamese]{babel}
% -----------------------------------

% Tight margins for cheat sheet in landscape (A4 297mm x 210mm)
\geometry{a4paper, landscape, left=8mm, right=8mm, top=6mm, bottom=13mm}

\fancyfoot[C]{\footnotesize\thepage}

\title{Tổng hợp Kiến thức Môn Kỹ thuật Dữ liệu (Data Engineering)}
\author{Học viên Cao học KHMT Bách Khoa TP.HCM (HCMUT)}
\date{\today}

\begin{document}

\thispagestyle{fancy} % Apply fancy style to title page
\maketitle
\footnotesize % smaller font for dense content
% Zero / minimal spacing in itemize and enumerate lists
\setlist{itemsep=0pt,topsep=2pt,parsep=0pt,partopsep=0pt}
\begin{multicols}{3}
    \setlength{\columnsep}{8pt} % space between columns
    \setlength{\multicolsep}{2pt} % vertical space before/after multicols
    \raggedcolumns

    \section{Nguyên lý Phân tích \& Thiết kế CSDL}

    \subsection{Tổng quan Các giai đoạn Thiết kế}
    \begin{enumerate}[leftmargin=*,itemsep=2pt]
        \item \textbf{Mức Quan niệm (Conceptual):} \textit{Mục tiêu} — nắm bắt yêu cầu và ngữ nghĩa (độc lập với cài đặt); \textit{Mô hình/Công cụ} — ER/EER; \textit{Đầu ra} — lược đồ quan niệm (thực thể, thuộc tính, mối kết hợp, ràng buộc).
        \item \textbf{Mức Logic:} \textit{Mục tiêu} — ánh xạ từ mức quan niệm sang mô hình DBMS đích (ví dụ: quan hệ); \textit{Mô hình/Công cụ} — ánh xạ ER-sang-quan hệ, chuẩn hóa (FDs); \textit{Đầu ra} — lược đồ quan hệ (bảng, khóa, ràng buộc toàn vẹn).
        \item \textbf{Mức Vật lý:} \textit{Mục tiêu} — xác định cấu trúc lưu trữ và đường dẫn truy xuất để tối ưu hiệu năng; \textit{Mô hình/Công cụ} — phân tích tải, chỉ mục, tổ chức tập tin, băm; \textit{Đầu ra} — lược đồ trong (cấu trúc lưu trữ, chỉ mục, đường dẫn truy xuất).
    \end{enumerate}

    \subsection{Nguyên lý Thiết kế Mức Quan niệm}
    \begin{itemize}[leftmargin=*, label={--}]
        \item \textbf{Phân tích Yêu cầu:} Làm việc với người dùng/chuyên gia nghiệp vụ để nắm bắt yêu cầu dữ liệu và yêu cầu chức năng (thao tác/giao dịch).
        \item \textbf{Thành phần ER:} \textbf{Thực thể} (vd: NhanVien), \textbf{Thuộc tính} (đơn/phức hợp/đa trị/dẫn xuất), \textbf{Mối kết hợp} (sự liên kết giữa các thực thể).
        \item \textbf{Ràng buộc Cấu trúc:} Tỷ số bản số (1:1, 1:N, M:N) và ràng buộc tham gia (\textit{toàn phần} vs \textit{từng phần}).
        \item \textbf{Thực thể Yếu:} Được xác định thông qua \textbf{mối kết hợp xác định} với một thực thể \textbf{chủ} và một \textbf{khóa bộ phận}; thực thể yếu tham gia \textit{toàn phần} vào mối kết hợp xác định.
        \item \textbf{Tinh chỉnh Top-Down:} Tinh chỉnh lặp lại các thực thể tổng quát; áp dụng chuyên biệt hóa/tổng quát hóa (EER).
    \end{itemize}
    
    \subsection{Nguyên lý Thiết kế Mức Logic}
    \subsubsection{Cơ bản về Mô hình Quan hệ}
    \begin{itemize}[leftmargin=*, label={--}]
        \item \textbf{Cấu trúc:} Lược đồ quan hệ $R(A_1, \dots, A_n)$; các bộ (tuple) không có thứ tự và không cho phép trùng lặp trong mô hình hình thức.
        \item \textbf{Ràng buộc Toàn vẹn:} Ràng buộc miền giá trị (nguyên tố, có kiểu), ràng buộc khóa (siêu khóa/khóa ứng viên/khóa chính), toàn vẹn thực thể (khóa chính không NULL), toàn vẹn tham chiếu (giá trị khóa ngoại phải xuất hiện trong khóa chính được tham chiếu).
    \end{itemize}

    \paragraph{ER-to-Relational Mapping Rules}
    \begin{itemize}[leftmargin=*, label={--}]
        \item \textbf{Strong Entity:} Tạo bảng. PK = Entity PK.
        \item \textbf{Weak Entity:} Tạo bảng. PK = (Owner PK + Partial Key). FK to Owner.
        \item \textbf{1:N Relationship:} Đưa PK của bên "1" làm FK vào bảng bên "N".
        \item \textbf{M:N Relationship:} Tạo \textbf{bảng trung gian}. PK = (PK\_A + PK\_B). Cả hai đều là FK.
        \item \textbf{Multivalued Attribute:} Tạo \textbf{bảng mới}. PK = (Entity PK + Attribute Value).
        \item \textbf{N-ary (Ternary) Relationship:} Tạo \textbf{bảng mới}. PK = (PK\_A + PK\_B + PK\_C). Tất cả đều là FK.
    \end{itemize}

    \subsubsection{Lý thuyết Chuẩn hóa}
    \begin{itemize}[leftmargin=*, label={--}]
        \item \textbf{Mục tiêu:} Giảm thiểu dư thừa, tránh dị thường (Thêm, Xóa, Sửa).
        \item \textbf{Phụ thuộc Hàm (FD):} $X \rightarrow Y$ (Nếu $t_1[X]=t_2[X]$ thì $t_1[Y]=t_2[Y]$).
        \item \textbf{Các loại Key:}
        \begin{itemize}
            \item \textit{Superkey:} Xác định duy nhất một bộ.
            \item \textit{Candidate Key:} Superkey tối thiểu.
            \item \textit{Prime Attribute:} Thuộc tính nằm trong bất kỳ Candidate Key nào.
        \end{itemize}
    \end{itemize}

    \textbf{Các Dạng Chuẩn (Normal Forms)}
    \begin{center}
        \includegraphics[width=0.8\linewidth, height=3cm, keepaspectratio]{./images/normalization_pyramid.png} \\
        \footnotesize \textit{(Hierarchy: BCNF $\subset$ 3NF $\subset$ 2NF $\subset$ 1NF)}
    \end{center}

    \begin{description}[leftmargin=*, labelindent=0pt, font=\bfseries\color{blue!80!black}, nosep]
        
        \item[1NF (Atomic):] Miền giá trị nguyên tố.
        \newline $\hookrightarrow$ \textit{Vi phạm:} Thuộc tính đa trị, lồng nhau, lặp lại nhóm.

        \item[2NF (No Partial):] Là 1NF + Thuộc tính \textit{non-prime} phụ thuộc đầy đủ vào khóa.
        \newline $\hookrightarrow$ \textit{Vi phạm:} $\exists X \subsetneq Key$ sao cho $X \rightarrow NonPrime$.
        \newline \textit{(Chỉ xảy ra nếu Key là khóa phức hợp)}.

        \item[3NF (No Transitive):] Là 2NF + Không có phụ thuộc bắc cầu giữa các \textit{non-prime}.
        \newline $\rightarrow$ \textit{Định nghĩa:} Với mọi $X \rightarrow A$ (không tầm thường), phải thỏa:
        \begin{enumerate*}[label=(\alph*)]
            \item $X$ là Superkey \textbf{HOẶC}
            \item $A$ là Prime Attribute.
        \end{enumerate*}

        \item[BCNF (Strict):] Nghiêm ngặt hơn 3NF.
        \newline $\rightarrow$ \textit{Định nghĩa:} Với mọi $X \rightarrow A$, $X$ \textbf{bắt buộc là Superkey}.
        \newline \textit{(Khác biệt: BCNF không chấp nhận ngoại lệ "A là Prime" như 3NF)}.

    \end{description}

    \textbf{Tính chất Phân rã (Decomposition Properties)}
    \begin{enumerate}[leftmargin=*, label={\arabic*.}]
        \item \textbf{Kết nối bảo toàn thông tin (Lossless Join):} \textit{(Bắt buộc)}
        \newline Để phân rã $R$ thành $R_1, R_2$ không bị mất dữ liệu, điều kiện là:
        \newline $(R_1 \cap R_2) \rightarrow R_1$ \textbf{HOẶC} $(R_1 \cap R_2) \rightarrow R_2$.
        \newline \textit{(Giao của 2 bảng phải là khóa của ít nhất 1 bảng).}
        \item \textbf{Bảo toàn phụ thuộc (Dependency Preservation):}
        \newline Các FD ban đầu có thể được kiểm tra riêng lẻ trên từng $R_i$ mà không cần join lại. (BCNF có thể không bảo toàn phụ thuộc).
    \end{enumerate}

    \subsubsection{Phi chuẩn hóa (Denormalization)}
    \begin{itemize}[leftmargin=*, label={--}]
        \item \textbf{Mục tiêu:} Cải thiện hiệu suất đọc bằng cách đưa dư thừa vào lược đồ, ngược với chuẩn hóa.
        \item \textbf{Động lực:} Tránh Join tốn kém; giảm độ phức tạp truy vấn; tăng locality dữ liệu.
    \end{itemize}
    
    \textbf{Kỹ thuật Denormalization:}
    \begin{itemize}[leftmargin=*, label={--}]
        \item \textbf{Materialized Views:} Kết quả truy vấn được tính trước và lưu trữ; cập nhật khi dữ liệu thay đổi.
        \item \textbf{Precomputed Aggregates:} Lưu giá trị tổng hợp (COUNT, SUM) trong bản ghi để tránh tính lại.
        \newline \textit{VD: Lưu số email chưa đọc trong bảng User thay vì đếm mỗi lần.}
        \item \textbf{Document Databases:} Nhúng (embedding) dữ liệu liên quan trong một document thay vì tham chiếu.
        \newline \textit{VD: MongoDB nhúng thông tin Worker vào document Project.}
        \item \textbf{Star Schema (DW):} Dimension tables được denormalize (VD: Brand, Category trong dim\_product).
        \item \textbf{Microservices:} Sao chép (replicate) dữ liệu giữa các service để tách biệt và giảm phụ thuộc.
    \end{itemize}
    
    \textbf{Đánh đổi (Trade-offs):}
    \begin{itemize}[leftmargin=*, label={--}]
        \item \textbf{Write Overhead:} Mỗi cập nhật phải sửa tất cả bản sao dư thừa $\Rightarrow$ ghi chậm hơn, phức tạp hơn.
        \item \textbf{Data Inconsistency:} Rủi ro không nhất quán nếu một bản sao được cập nhật mà bản khác thì không.
        \item \textbf{Storage Cost:} Lưu trữ dữ liệu trùng lặp tốn bộ nhớ hơn.
    \end{itemize}
    \textit{Khi nào dùng:} OLAP/DW (đọc nhiều), NoSQL (thiếu join), microservices (tách biệt). \textit{Tránh:} OLTP cần ACID chặt.

    \subsubsection{Bẫy Thiết kế CSDL (Design Traps)}
    \begin{itemize}[leftmargin=*, label={--}]
        \item \textbf{Bẫy Kết nối trong ER:}
        \begin{center}
            \begin{tabular}{@{} c @{}}
                \includegraphics[width=1\linewidth]{./images/design_trap_fan.png} \\
                \footnotesize (Fan Trap) \\[6pt]
                \includegraphics[width=1\linewidth]{./images/design_trap_chasm.png} \\
                \footnotesize (Chasm Trap) \\
            \end{tabular}
        \end{center}
        \begin{itemize}
            \item \textit{Fan Trap:} Đường dẫn giữa các thực thể mơ hồ do nhiều quan hệ 1:N phân nhánh từ một thực thể. VD: NhanVien $\to$ PhongBan $\to$ ChiNhanh (không xác định được nhân viên làm ở chi nhánh nào). \textit{Giải pháp:} Thêm quan hệ trực tiếp NhanVien-ChiNhanh.
            \item \textit{Chasm Trap:} Đường dẫn không tồn tại do tham gia tùy chọn. VD: KhanhHang $\to$ TaiSan $\to$ ChiNhanh (nếu tài sản chưa niêm yết thì không liên kết được khách hàng với chi nhánh). \textit{Giải pháp:} Đổi sang tham gia bắt buộc hoặc thêm quan hệ trực tiếp.
        \end{itemize}
        \item \textbf{Dị thường Cập nhật (Update Anomalies):} Do thiết kế không chuẩn hóa:
        \begin{itemize}
            \item \textit{Insertion:} Không thể thêm phòng ban mới nếu chưa có nhân viên.
            \item \textit{Deletion:} Xóa nhân viên cuối cùng làm mất thông tin phòng ban.
            \item \textit{Modification:} Thay đổi tên phòng ban phải cập nhật nhiều bộ.
        \end{itemize}
        \item \textbf{Bộ giả (Spurious Tuples):} Kết nối các quan hệ phân rã sai (không qua PK/FK hợp lệ) tạo ra bản ghi ảo. \textit{Giải pháp:} Dùng phân rã bảo toàn thông tin (lossless join).
        \item \textbf{Bẫy NULL:} Quá nhiều thuộc tính NULL lãng phí bộ nhớ và gây khó khăn trong truy vấn tổng hợp.
        \item \textbf{Sai lầm phổ biến:} Dùng PK của thực thể này làm thuộc tính của thực thể khác thay vì mô hình hóa quan hệ; gán PK vào thuộc tính của quan hệ; dùng thuộc tính đơn trị khi cần đa trị.
        \item \textbf{Entity Trap (Kiến trúc):} Thiết kế component 1-1 với bảng DB (VD: CustomerManager cho bảng Customer) thay vì theo workflow nghiệp vụ $\to$ vi phạm tách biệt dữ liệu trong microservices.
    \end{itemize}
    \textit{Thực hành tốt:} Dùng BCNF/3NF; phân rã bảo toàn thông tin; đảm bảo đường dẫn ER rõ ràng; thiết kế theo hành vi nghiệp vụ, không theo thực thể.

    \subsection{Nguyên lý Thiết kế Mức Vật lý}
    \begin{itemize}[leftmargin=*, label={--}]
        \item \textbf{Kiến trúc Lưu trữ:} Dữ liệu bền vững trên đĩa/SSD trong các \textbf{khối (block)} kích thước cố định.
        \item \textbf{Phân tích Tải (Job Mix):} Xác định các quan hệ/tập tin thường truy cập, điều kiện chọn (bằng/khác/khoảng), và tần suất cập nhật so với truy vấn.
        \item \textbf{Cấu trúc Chỉ mục:} Chỉ mục có thứ tự (B+-Trees) và chỉ mục băm; chỉ mục \textbf{chính/phân cụm} (quy định thứ tự vật lý; tối đa một trên mỗi tập tin) so với chỉ mục \textbf{phụ}.
        \item \textbf{Tối ưu hóa Truy vấn:} Dựa trên chi phí (thống kê) và các quy tắc kinh nghiệm (đẩy phép chọn/chiếu xuống sớm) để chọn kế hoạch hiệu quả.
    \end{itemize}
    \subsection{Các bước vẽ ERD}
    \begin{enumerate}[leftmargin=*, label={\textbf{\arabic*.}}]
        \item \textbf{Xác định Thực thể (Entities):} 
        \newline Tìm các \textit{danh từ} (Nouns) quan trọng trong yêu cầu (Vd: Employee, Student). Tránh nhầm lẫn thuộc tính là thực thể.
        
        \item \textbf{Xác định Mối kết hợp (Relationships):} 
        \newline Tìm các \textit{động từ} (Verbs) kết nối các thực thể (Vd: Works\_for, Teaches).
        
        \item \textbf{Xác định Thuộc tính (Attributes):} 
        \newline Xác định thông tin chi tiết cho mỗi thực thể. Xác định thuộc tính đa trị, dẫn xuất, phức hợp.
        
        \item \textbf{Xác định Khóa chính (Primary Keys):} 
        \newline Chọn thuộc tính định danh duy nhất cho mỗi thực thể và gạch chân nó.
        
        \item \textbf{Xác định Bản số (Cardinality Ratio):} 
        \newline Phân tích số lượng tham gia: 1:1, 1:N, hay M:N.
        
        \item \textbf{Xác định Ràng buộc tham gia (Participation):} 
        \newline Có bắt buộc không? (Total - Nét đôi) hay Tùy chọn? (Partial - Nét đơn).
        \newline \textit{Hỏi: `Thực thể A có thể tồn tại mà không cần B không?'}
        
        \item \textbf{Vẽ phác thảo \& Tinh chỉnh:} 
        \newline Vẽ sơ đồ, loại bỏ các thuộc tính dư thừa. Chuyển quan hệ M:N thành thực thể liên kết nếu cần thiết.
    \end{enumerate}
    \subsection{Chen Notation: ER \& EER}
    % Bảng cho Thực thể & Thuộc tính - Tiết kiệm không gian hơn liệt kê
    \subsubsection{Entities \& Attributes}
    \textit{Khi nào dùng:} \textbf{Thực thể} cho đối tượng độc lập (NhanVien, SanPham, KhanhHang); \textbf{Thực thể yếu} cho đối tượng phụ thuộc (NguoiPhuThuoccủa nhân viên, ChiTietDonHang); \textbf{Khóa} là định danh duy nhất (MSNV, CCCD); \textbf{Đa trị} cho thuộc tính nhiều giá trị (số điện thoại, email); \textbf{Dẫn xuất} cho giá trị tính toán (tuổi từ ngày sinh, tổng tiền).
    \begin{center}
        \begin{tabular}{@{} c c @{}}
            % Hàng 1: Thực thể & Thực thể yếu
            \includegraphics[width=0.5\linewidth, height=1.2cm, keepaspectratio]{./images/chen_entity.png}      &
            \includegraphics[width=0.5\linewidth, height=1.2cm, keepaspectratio]{./images/chen_weak_entity.png}                                \\
            \footnotesize (Thực thể)                                                                             & \footnotesize (Thực thể yếu) \\[2pt]

            % Hàng 2: Thuộc tính & Khóa
            \includegraphics[width=0.5\linewidth, height=1.2cm, keepaspectratio]{./images/chen_attribute.png}   &
            \includegraphics[width=0.5\linewidth, height=1.2cm, keepaspectratio]{./images/chen_key.png}                                        \\
            \footnotesize (Thuộc tính)                                                                           & \footnotesize (Khóa)         \\[2pt]

            % Hàng 3: Đa trị & Dẫn xuất
            \includegraphics[width=0.5\linewidth, height=1.2cm, keepaspectratio]{./images/chen_multivalued.png} &
            \includegraphics[width=0.5\linewidth, height=1.2cm, keepaspectratio]{./images/chen_derived.png}                                    \\
            \footnotesize (Đa trị)                                                                               & \footnotesize (Dẫn xuất)     \\
        \end{tabular}
    \end{center}

    \subsubsection{Relationships}
    \textit{Khi nào dùng:} \textbf{Quan hệ thường} cho liên kết độc lập (NhanVien \textit{làm việc cho} PhongBan, KhanhHang \textit{mua} SanPham); \textbf{Quan hệ xác định} khi thực thể yếu phụ thuộc vào thực thể chủ (NguoiPhuThuoc \textit{thuộc về} NhanVien với khóa bộ phận là tên người phụ thuộc).
    \begin{center}
        % Dùng minipage để căn chỉnh nếu ảnh có tỷ lệ khác nhau
        \includegraphics[width=0.8\linewidth]{./images/chen_relationships_summary.png} \\
        \footnotesize \textit{Bao gồm: Quan hệ (Hình thoi), Quan hệ xác định (Thoi đôi)}
    \end{center}

    \columnbreak
    
    \subsubsection{Ràng buộc (Constraints)}
    \textit{Khi nào dùng:} Xác định quy tắc nghiệp vụ giữa các thực thể.
    \begin{itemize}[leftmargin=*, label={}]
        \item \textbf{Bản số (Cardinality):} 1:1 (NhanVien \textit{quản lý} PhongBan - mỗi phòng có 1 trưởng), 1:N (PhongBan \textit{có} NhanVien - nhiều nhân viên/phòng), M:N (NhanVien \textit{tham gia} DUAN - nhiều-nhiều).
        \item \textbf{Tham gia (Participation):}
              \begin{center}
                  \includegraphics[width=0.85\linewidth]{./images/chen_participation.png} \\
                  \footnotesize (Partial Participation (Từng phần): Nét đơn \linebreak Total Participation (Toàn phần): Nét đôi)
              \end{center}
        \item \textbf{Min-Max (min, max):} Ghi cặp số trên cạnh. Ví dụ: NhanVien $(1,1)$ \textit{làm việc cho} $(0,N)$ PhongBan nghĩa là mỗi nhân viên bắt buộc làm việc cho đúng 1 phòng ban, mỗi phòng ban có thể có 0 đến nhiều nhân viên. $(0,1)$: tùy chọn, tối đa 1; $(1,N)$: bắt buộc, có thể nhiều. (An extension of Participation và Cardinality)
    \end{itemize}

    \subsubsection{EER Chuyên biệt hóa \& Tổng quát hóa}
    \textit{Khi nào dùng:} \textbf{Disjoint} khi lớp con không chồng lấp (NhanVien là KỸ SƯ hoặc QUẢN LÝ, không đồng thời); \textbf{Overlapping} khi có thể thuộc nhiều lớp (NGƯỜI là SINH VIÊN và/hoặc NHÂN VIÊN); \textbf{Union} khi lớp con kế thừa từ nhiều lớp cha (CHỦ SỞ HỮU có thể là NGƯỜI hoặc CÔNG TY hoặc NGÂN HÀNG). \textbf{Total} khi mọi thực thể cha phải thuộc ít nhất 1 lớp con; \textbf{Partial} khi không bắt buộc.
    \begin{center}
        \begin{tabular}{@{} c @{}}
            \includegraphics[width=1\linewidth]{./images/chen_eer_disjoint_overlap.png} \\
            \footnotesize (Disjoint \& Overlapping)                                       \\[2pt]
            \includegraphics[width=1\linewidth]{./images/chen_eer_union.png}            \\
            \footnotesize (Union)                                                         \\
        \end{tabular} \\[2pt]
        \footnotesize \textit{Ký hiệu: Hình tròn (d: disjoint, o: overlapping, U: union),\linebreak Nét đôi (Total), Nét đơn (Partial).}
    \end{center}

    \columnbreak

    \subsubsection{Ternary Relationships \& EER Counting}
    \paragraph{Mối kết hợp Tam nguyên (Ternary Relationships)}
    \begin{itemize}[leftmargin=*, label={--}]
        \item \textbf{Định nghĩa:} Mối kết hợp giữa 3 thực thể (A, B, C) cùng lúc.
        \item \textbf{Quy tắc đọc bản số (Look-Across):} Ký hiệu bản số gần thực thể C cho biết số instances của C liên kết với \textit{một cặp} (A, B).
        \newline \textit{VD:} Supplier-Project-Device: Bản số gần Device (ví dụ: N) nghĩa là một cặp (Supplier, Project) có thể cung cấp nhiều Device.
    \end{itemize}
    
    \paragraph{EER Counting Rules (Đếm thực thể)}
    \begin{itemize}[leftmargin=*, label={--}]
        \item \textbf{Disjoint (d):} Các lớp con không giao nhau.
        \newline $|Superclass| = |Subclass_1| + |Subclass_2| + ... + |Subclass_n|$
        \item \textbf{Overlapping (o):} Các lớp con có thể giao nhau.
        \newline $|Superclass| < |Subclass_1| + |Subclass_2| + ...$ (do có phần giao)
        \newline Áp dụng công thức: $|A \cup B| = |A| + |B| - |A \cap B|$
        \item \textbf{Union (U):} Lớp con là tập con của hợp các lớp cha.
        \newline $|Subclass| \leq |Parent_1 \cup Parent_2 \cup ...|$
    \end{itemize}

    \columnbreak

    % ===========================================================================
    % SECTION QUERY PROCESSING & OPTIMIZATION
    % ===========================================================================
    \section{Xử lý \& Tối ưu hóa Truy vấn}

    \textit{Quy trình từ câu lệnh SQL $\rightarrow$ Kết quả. Trọng tâm: Tính toán chi phí I/O (số block truy cập) để chọn chiến lược tối ưu.}

    % ----------------------------------------------------------------------------
    % 1. CÁC GIAI ĐOẠN CHÍNH
    % ----------------------------------------------------------------------------
    \subsection{Ba Giai đoạn Chính (Overview)}
    \begin{enumerate}[leftmargin=*, label={\textbf{\arabic*.}}]
        \item \textbf{Parsing \& Translation:} Kiểm tra cú pháp/ngữ nghĩa $\rightarrow$ Tạo cây đại số quan hệ (Canonical Tree).
        \item \textbf{Optimization (Quan trọng nhất):} Sử dụng thống kê (Catalog) để ước lượng chi phí $\rightarrow$ Chọn Execution Plan rẻ nhất (ít I/O nhất).
        \item \textbf{Evaluation:} Thực thi kế hoạch (dùng Pipelining hoặc Materialization).
    \end{enumerate}

    % ============================================================================
    % PHASE 1: PARSING AND TRANSLATION
    % ============================================================================
    \subsection{Phase 1: Parsing \& Translation}

    \subsubsection{Syntax \& Verification}
    \begin{itemize}[leftmargin=*, label={--}]
        \item \textbf{Syntax Checking:} Parser validates SQL syntax against language grammar.
        \item \textbf{Semantic Verification:} Verify relation names, attribute names, data types exist in database schema.
        \item \textbf{Authorization:} Check user has necessary privileges (SELECT, INSERT, UPDATE, DELETE) on referenced relations.
    \end{itemize}

    \subsubsection{Internal Representation}
    \begin{itemize}[leftmargin=*, label={--}]
        \item \textbf{Parse Tree:} Construct hierarchical syntax tree representing query structure.
        \item \textbf{Relational Algebra Translation:} Convert SQL to relational-algebra expression.
        \newline \textit{Example:} \texttt{SELECT name FROM instructor WHERE salary > 80000}
        \newline $\rightarrow$ $\pi_{name}(\sigma_{salary > 80000}(instructor))$
        \item \textbf{Query Blocks:} Decompose complex SQL into basic units (\texttt{SELECT-FROM-WHERE} expressions) that map to algebraic operators.
        \newline \textit{Nested Subqueries:} Each subquery becomes separate query block. Correlated subqueries require special handling.
        \item \textbf{View Expansion:} If query references views, replace view names with their defining relational-algebra expressions.
        \newline \textit{Recursive Process:} Views may reference other views $\rightarrow$ expand until only base relations remain.
    \end{itemize}

    \subsubsection{Query Tree (Initial Canonical Form)}
    \begin{itemize}[leftmargin=*, label={--}]
        \item \textbf{Structure:} Tree representation where:
        \begin{itemize}
            \item \textit{Leaf nodes:} Base relations (tables).
            \item \textit{Internal nodes:} Relational operations (select $\sigma$, project $\pi$, join $\bowtie$, etc.).
            \item \textit{Execution flow:} Bottom-up evaluation - leaf data flows up through operations to root.
        \end{itemize}
        \item \textbf{Canonical Form:} Initial tree follows SQL structure directly:
        \begin{itemize}
            \item Cartesian products appear when multiple relations in FROM without explicit join conditions.
            \item Selections appear high in tree (near root) reflecting WHERE clause position.
            \item Projections at root reflecting SELECT clause.
        \end{itemize}
        \item \textbf{Problem:} Canonical tree often inefficient $\rightarrow$ requires optimization transformation.
    \end{itemize}

    % ============================================================================
    % PHASE 2: QUERY OPTIMIZATION
    % ============================================================================
    \subsection{Phase 2: Tối ưu hóa Truy vấn (Query Optimization)}

    \subsubsection{Tổng quan Quy trình Tối ưu hóa}
    After parsing, the optimizer transforms the canonical query tree into an efficient execution plan through two complementary approaches:
    \begin{itemize}[leftmargin=*, label={--}]
        \item \textbf{Heuristic Optimization:} Apply algebraic transformation rules to restructure tree (reduce search space).
        \item \textbf{Cost-Based Optimization:} Enumerate candidate plans, estimate costs using statistics, choose optimal plan.
    \end{itemize}

    % ----------------------------------------------------------------------------
    % 2. HEURISTIC OPTIMIZATION (TỐI ƯU HÓA DỰA TRÊN LUẬT)
    % ----------------------------------------------------------------------------
    \subsubsection{Tối ưu hóa Heuristic (Dựa trên luật)}
    \textit{Mục tiêu: Thu gọn kích thước dữ liệu trung gian càng sớm càng tốt.}

    \paragraph{Các Quy tắc Cốt lõi}
    \begin{enumerate}[leftmargin=*, label={\textbf{\arabic*.}}]
        \item \textbf{Perform Selections Early ($\sigma$ down):} Đẩy phép CHỌN xuống thấp nhất có thể.
        \newline \textit{Lý do:} Giảm số dòng ($r$) trước khi thực hiện Join (phép toán tốn kém nhất).
        \item \textbf{Perform Projections Early ($\pi$ down):} Đẩy phép CHIẾU xuống thấp nhất.
        \newline \textit{Lý do:} Giảm kích thước mỗi dòng (tuple size), tăng $bfr$ (blocking factor).
        \item \textbf{Tránh tích Đề-các ($\times$):} Luôn kết hợp $\times$ với $\sigma$ để thành Join ($\bowtie$).
    \end{enumerate}

    \paragraph{Transformation Rules}
    \begin{itemize}[leftmargin=*, label={--}]
        \item \textbf{Cascading of Selections:} $\sigma_{c1 \land c2}(R) = \sigma_{c1}(\sigma_{c2}(R))$.
        \newline \textit{Application:} Break conjunctive conditions to move parts down different branches.
        \item \textbf{Commutativity:} $\sigma_{c1}(R \bowtie S) = (\sigma_{c1}(R)) \bowtie S$ (if $c1$ only involves $R$).
        \newline \textit{Application:} Push selections down past joins.
        \item \textbf{Associativity:} $(R \bowtie S) \bowtie T = R \bowtie (S \bowtie T)$.
        \newline \textit{Application:} Reorder join sequence so most restrictive joins (highest selectivity) occur first.
    \end{itemize}

    \paragraph{Heuristic Algorithm (6 steps)}
    \begin{enumerate}[leftmargin=*, label={\textbf{\arabic*.}}]
        \item \textbf{Break up Selections:} Use cascading rule to split conjunctive select conditions.
        \item \textbf{Move Selections Down:} Push $\sigma$ down as far as possible (using commutativity).
        \item \textbf{Reorder Leaf Nodes:} Rearrange leaf nodes (relations) - relation with most restrictive selection (lowest selectivity) first.
        \item \textbf{Form Joins:} Combine Cartesian products with subsequent selections into Join operations.
        \item \textbf{Move Projections Down:} Break projection lists, only keep attributes needed for query result or subsequent operations.
        \item \textbf{Identify Subtrees:} Group operations that can be executed by single algorithm (e.g., single access method).
    \end{enumerate}

    \paragraph{Trade-offs \& Limitations}
    \begin{itemize}[leftmargin=*, label={--}]
        \item \textbf{Not Always Optimal:} Heuristics reduce optimization cost but don't guarantee finding optimal plan.
        \newline \textit{Example:} "Selection early" usually good, but if selection needs to scan large relation while join has efficient index, joining first may be cheaper.
        \item \textbf{Hybrid Approaches:} Commercial optimizers combine both.
        \newline \textit{System R:} Heuristics (only consider left-deep trees) + cost-based (within those constraints).
        \newline \textit{Oracle:} Heuristics rank access paths + cost-based chooses join methods.
    \end{itemize}

    \paragraph{Subquery vs Join Optimization}
    \begin{itemize}[leftmargin=*, label={--}]
        \item \textbf{Subquery Unnesting:} Optimizers generally convert \textbf{Nested Subqueries} (especially correlated) into \textbf{Joins}.
        \item \textbf{Preference Order:} \texttt{JOIN} > \texttt{Correlated Subquery} > \texttt{Cartesian Product} (worst).
        \item \textbf{Why?} Joins allow optimizer to choose efficient algorithms (Hash/Merge Join), whereas correlated subqueries force "Nested Loop" behavior (inner query runs once per outer row).
    \end{itemize}

    % ----------------------------------------------------------------------------
    % COST-BASED OPTIMIZATION FOUNDATIONS
    % ----------------------------------------------------------------------------
    \subsubsection{Cost-Based Optimization: Foundations}

    After heuristic optimization, system generates multiple candidate execution plans and estimates cost for each using statistical information from database catalog.

    \paragraph{Cost Metrics}
    \begin{itemize}[leftmargin=*, label={--}]
        \item \textbf{Primary Metric - Disk I/O:} Number of block transfers + number of disk seeks.
        \newline \textit{Reason:} For large disk-resident databases, I/O cost dominates CPU cost.
        \item \textbf{Secondary Metrics:} CPU time (for in-memory operations), network communication cost (distributed systems).
        \item \textbf{Response Time vs Throughput:} Systems may optimize for fast first-result (pipelining) or total execution time (materialization).
    \end{itemize}

    \paragraph{Cost Function Notation}
    \textit{Ước tính tài nguyên (disk I/O) để xử lý truy vấn: số block transfers ($b$) và số disk seeks ($S$).}
    \begin{itemize}[leftmargin=*, label={--}]
        \item $b$ (hoặc $b_r$): Tổng số blocks trong file.
        \item $r$ (hoặc $n_r$): Tổng số records (tuples) trong relation.
        \item $s$ (hoặc $s_A$): \textbf{Selection cardinality} - số records trung bình thỏa điều kiện.
        \item $bfr$: Blocking factor (số records trên mỗi block).\\ $bfr = \lfloor Block Size (bytes) / Record Size (bytes) \rfloor$.
        \item $x$ (hoặc $h_i$): Số levels trong index (chiều cao B+-tree).
        \item $t_S$: Average time cho disk seek.
        \item $t_T$: Average time để transfer một block.
        \item \textbf{Công thức tổng:} Cost = $b \times t_T + S \times t_S$ (transfer time + seek time).
    \end{itemize}

    \paragraph{Statistical Information (Catalog Metadata)}
    \begin{itemize}[leftmargin=*, label={--}]
        \item \textbf{Relation Statistics:} $n_r$ (number of tuples), $b_r$ (number of blocks), $l_r$ (tuple size in bytes).
        \item \textbf{Attribute Statistics:} $V(A,r)$ (number of distinct values for attribute $A$), $min(A,r)$ and $max(A,r)$ (value range).
        \item \textbf{Index Statistics:} Index type, height ($h_i$), number of leaf blocks, clustering vs non-clustering.
        \item \textbf{Histograms:} Store distribution of attribute values to improve selectivity estimates.
        \newline \textit{Equi-width:} Divide value range into equal-sized buckets, count tuples in each.
        \newline \textit{Equi-depth:} Buckets contain approximately equal number of tuples.
        \newline \textit{Use:} Handle skewed data distributions (e.g., most employees earn 30K-50K, few earn >100K).
    \end{itemize}

    % ----------------------------------------------------------------------------
    % INDEX STRUCTURES (Supporting Access Path Selection)
    % ----------------------------------------------------------------------------
    \subsection{Cơ bản về Chỉ mục (Index Structures)}

    \textit{Indexes are critical data structures that enable efficient access paths for query execution. Understanding index characteristics is essential for cost estimation and access path selection.}

    \subsubsection{Chỉ mục là gì?}
    \begin{itemize}[leftmargin=*, label={--}]
        \item \textbf{Mục đích:} Tăng tốc độ truy xuất dữ liệu bằng cách tạo đường dẫn phụ trợ đến các bản ghi.
        \item \textbf{Khóa tìm kiếm:} (Các) thuộc tính dùng để tìm bản ghi; không nhất thiết là khóa chính; có thể là khóa phức hợp (nhiều cột).
        \item \textbf{Đánh đổi:} Đọc nhanh hơn so với ghi chậm hơn (chi phí bảo trì chỉ mục khi INSERT/UPDATE/DELETE).
    \end{itemize}

    \subsubsection{Các loại Chỉ mục Cơ bản}
    \begin{enumerate}[leftmargin=*, label={\textbf{\arabic*.}}]
        \item \textbf{Primary Index:} Trên trường \textbf{Khóa (Unique)} + File \textbf{đã sắp xếp}. (Thường là Sparse).
        \item \textbf{Clustering Index:} Trên trường \textbf{Không Khóa (Non-Unique)} + File \textbf{đã sắp xếp}. (Sparse - 1 entry cho mỗi giá trị riêng biệt).
        \item \textbf{Secondary Index:} Trên bất kỳ trường nào + File \textbf{không sắp xếp} (hoặc sắp xếp theo trường khác). (Luôn là Dense).
    \end{enumerate}

    \subsubsection{Phân loại \& Chiến lược Lưu trữ}
    \begin{itemize}[leftmargin=*, label={--}]
        \item \textbf{Tổ chức Tập tin (File Organization):}
        \begin{itemize}[leftmargin=*, label={-}]
            \item \textbf{Heap / Unsorted:} Bản ghi được lưu theo thứ tự chèn; không hỗ trợ sparse primary index vì không có thứ tự vật lý theo khoá.
            \item \textbf{Sorted / Ordered (Clustered):} File sắp xếp theo một khoá (ví dụ Pnumber). Primary / Clustering index có thể là \textbf{Sparse} (1 entry ~ 1 block).
            \item \textbf{Hash File:} Băm theo khoá thành bucket; hiệu quả cho truy vấn bằng (=). Khi khoá là unique, chỉ mục hoặc cấu trúc thư mục băm thường biểu diễn một mục cho mỗi bản ghi hoặc mỗi bucket tùy triển khai (thường coi như \textbf{dense} nếu chỉ mục trên khoá chính và file không có thứ tự).
        \end{itemize}
        \item \textbf{Dense Index (Chỉ mục Đặc):} 
        \begin{itemize}
            \item Có một index entry cho \textbf{mỗi record} trong data file.
            \item \textbf{Sử dụng khi:} File dữ liệu \textbf{không} được sắp xếp theo trường đánh index (Secondary Index).
            \item \textbf{Size:} Số Index Entries $n_i = r$ (số dòng dữ liệu).
        \end{itemize}
        \item \textbf{Sparse Index (Chỉ mục Thưa):}
        \begin{itemize}
            \item Chỉ có index entry đại diện cho \textbf{mỗi block} (hoặc mỗi nhóm).
            \item \textbf{Sử dụng khi:} File dữ liệu \textbf{đã được sắp xếp} theo trường đánh index (Primary/Clustering Index).
            \item \textbf{Size:} Số Index Entries $n_i = b$ (số block dữ liệu).
            \item \textit{Ví dụ (Câu 13 - F1.1):} 70.000 records, bfr=17, sắp xếp theo SSN. Index trên SSN là Sparse.
            \newline $\Rightarrow$ Số entries = $70.000 / 17 \approx 4.118$.
        \end{itemize}
        \item \textbf{Ghi chú thực tế \& Ví dụ minh hoạ:}
        \begin{itemize}[leftmargin=*, label={-}]
            \item \textbf{Thông số bài toán mẫu:} 50.000 dự án, bfr = 5 records/block $\Rightarrow$ $b = \lceil 50{,}000/5 \rceil = 10{,}000$ blocks.
            \item \textbf{Trường hợp Hash file theo Pnumber (khóa duy nhất):} Chỉ mục trên Pnumber sẽ biểu diễn một entry cho mỗi bản ghi (hoặc directory/bucket tương đương) $\Rightarrow$ \textbf{Dense} với 50.000 entries.
            \item \textbf{Trường hợp File sắp xếp theo Pnumber với Primary (clustered) index:} Chỉ mục \textbf{Sparse} với ~10.000 entries (một entry cho mỗi block) $\Rightarrow$.
            \item \textbf{Trường hợp Secondary index trên thuộc tính không duy nhất (ví dụ Dno hoặc Pname):} Thường là \textbf{Dense}. Nếu Dno có 20 giá trị phân bố đều $\Rightarrow$ mỗi Dno ~2.500 bản ghi; nhưng số entries của index = 50.000 (một entry per record), không phải 2.500.
        \end{itemize}
    \end{itemize}

    \subsubsection{Công thức Số lượng Index Entries}
    \textit{Xác định số hàng trong file chỉ mục (không phải chi phí truy cập).}
    \begin{itemize}[leftmargin=*, label={--}]
        \item \textbf{Primary Index (Sparse):} Số Index Entries = Số \textbf{Blocks} trong Data File.
        \newline $\text{Entries} = b = \lceil r / bfr \rceil$
        \newline \textit{Lý do:} Mỗi block có 1 entry (anchor record/block anchor).
        \item \textbf{Clustering Index (Sparse):} Số Index Entries = Số \textbf{Distinct Values} của clustering field.
        \newline $\text{Entries} = \text{NDV (Number of Distinct Values)}$
        \newline \textit{Lý do:} Mỗi giá trị duy nhất có 1 entry trỏ đến block đầu tiên chứa giá trị đó.
        \item \textbf{Secondary Index (Dense):} Số Index Entries = Số \textbf{Records} trong Data File.
        \newline $\text{Entries} = r$
        \newline \textit{Lý do:} Mỗi record có 1 entry (dense index).
    \end{itemize}

    \columnbreak
    % ----------------------------------------------------------------------------
    % B-TREES & B+-TREES (TRỌNG TÂM THI)
    % ----------------------------------------------------------------------------
    \subsubsection{B-Trees \& B+-Trees}


    \paragraph{So sánh}\mbox{}\\
    \textit{Câu hỏi thường gặp: Tại sao B+-Tree là chuẩn công nghiệp thay vì B-Tree?}
    \begin{center}
        \renewcommand{\arraystretch}{1.2}
        \begin{tabular}{|p{0.45\linewidth}|p{0.45\linewidth}|}
            \hline
            \textbf{B-Tree} & \textbf{B+-Tree} (Chuẩn DBMS) \\
            \hline
            \textbf{Data Pointers:} Lưu ở \textbf{tất cả} các node (Internal + Leaf). & \textbf{Data Pointers:} Chỉ lưu ở \textbf{Leaf Node}. Internal node chỉ chứa key để điều hướng. \\
            \hline
            \textbf{Search:} Có thể dừng ở Internal node nếu tìm thấy key. & \textbf{Search:} Luôn phải đi xuống tận Leaf node để lấy dữ liệu. \\
            \hline
            \textbf{Fan-out:} Thấp hơn (do tốn không gian lưu Data ptr). Cây cao hơn $\rightarrow$ Nhiều I/O hơn. & \textbf{Fan-out:} \textbf{Cao hơn} (Internal node nhẹ). Cây thấp hơn ($h$ nhỏ) $\rightarrow$ Ít I/O hơn. \\
            \hline
            \textbf{Range Query:} Khó khăn (phải duyệt cây kiểu trung thứ tự - In-order traversal). & \textbf{Range Query:} \textbf{Rất nhanh} (các Leaf node liên kết với nhau thành Linked List). \\
            \hline
        \end{tabular}
    \end{center}

    \paragraph{Các tính chất cốt lõi}
    \begin{itemize}[leftmargin=*, label={--}]
        \item \textbf{Balanced Tree:} Mọi đường đi từ gốc đến lá đều có độ dài bằng nhau ($h$).
        \item \textbf{Root Constraint:} Node gốc luôn chiếm \textbf{đúng 1} disk block.
        \item \textbf{Node Capacity:} Mỗi node là 1 disk block (thường là 4KB).
        \item \textbf{Fill Factor:} Các node (trừ root) phải đầy ít nhất 50\% ($\lceil p/2 \rceil$). Nếu ít hơn $\rightarrow$ Underflow (Gộp node).
    \end{itemize}

    \paragraph{Công thức tính Fan-out (Order $p$) [Cần nhớ để tính]}
    \textit{Ký hiệu: Block size $B$, Tree Pointer $P$, Key size $V$, Data Pointer $P_r$.}


    \begin{itemize}[leftmargin=*, label={$\bullet$}]
        \item \textbf{B+-Tree Internal Node (Tìm $p$):}
        \newline Node chứa $p$ con trỏ cây và $(p-1)$ khóa. (Không chứa data pointer).
        \newline \textbf{Công thức:} $p \times P + (p-1) \times V \le B$
        
        \item \textbf{B+-Tree Leaf Node (Tìm $p_{leaf}$):}
        \newline Node chứa $p_{leaf}$ cặp (Data Pointer + Key) và 1 Next Pointer.
        \newline \textbf{Công thức:} $p_{leaf} \times (P_r + V) + P \le B$
        
        \item \textit{Lưu ý cho B-Tree thường:} Internal node B-Tree có chứa Data Pointer, công thức sẽ là: $p \times P + (p-1) \times (V + P_r) \le B$.
    \end{itemize}

    \paragraph{Ví dụ Tính toán Sức chứa (Capacity Example)}\mbox{}\\
    \textit{Đề bài:} Block size $B=512$ bytes; Key size $V=9$; Data pointer $P_r=7$; Tree pointer $P=6$.

    \textit{Bước 1: Tính Fan-out (Order $p$)}
    \begin{itemize}[leftmargin=*, label={--}]
        \item \textbf{Nút trong B-Tree (B-Tree Internal):} Chứa cả Data Pointer.
        \newline $(p \times 6) + ((p-1) \times (7+9)) \le 512 \Rightarrow 22p \le 528 \Rightarrow \mathbf{p = 23}$.

        \item \textbf{Nút trong B+-Tree (B+-Tree Internal):} Chỉ chứa Key.
        \newline $(p \times 6) + ((p-1) \times 9) \le 512 \Rightarrow 15p \le 521 \Rightarrow \mathbf{p = 34}$.
        \newline \textit{Kết luận:} B+-Tree có fan-out cao hơn 48\% $\rightarrow$ cây ngắn hơn.

        \item \textbf{Nút lá B+-Tree (Leaf):}
        \newline $(p_{leaf} \times (7+9)) + 6 \le 512 \Rightarrow 16 \times p_{leaf} \le 506 \Rightarrow \mathbf{p_{leaf} = 31}$.
    \end{itemize}

    \textit{Bước 2: Ước lượng Tổng sức chứa (Giả sử cây cao 3 mức, đầy 69\%)}
    \begin{itemize}[leftmargin=*, label={--}]
        \item \textbf{B-Tree:} Tổng entry $\approx \mathbf{4.095}$. (Do $p$ nhỏ).
        \item \textbf{B+-Tree:} Tổng entry $\approx \mathbf{255.507}$. (Do $p$ lớn, số lượng lá tăng theo lũy thừa).
        \newline $\rightarrow$ \textbf{Hiệu quả:} B+-Tree lưu được gấp ~60 lần dữ liệu với cùng chiều cao cây.
    \end{itemize}

    \paragraph{Thao tác Cập nhật (Update Operations)}\mbox{}\\
    \textit{Cơ chế duy trì tính cân bằng của cây.}
    \begin{itemize}[leftmargin=*, label={--}]
        \item \textbf{Splitting (Khi Insert):} Nếu node bị đầy ($> B$), tách thành 2 node. Key ở giữa (middle key) được đẩy lên (promote) node cha.
        \newline $\rightarrow$ Có thể làm tăng chiều cao cây ($h+1$) nếu lan truyền đến Root.
        \item \textbf{Merging (Khi Delete):} Nếu node bị rỗng ($< 50\%$), mượn key từ anh em hoặc gộp 2 node lại.
        \newline $\rightarrow$ Có thể làm giảm chiều cao cây ($h-1$).
    \end{itemize}

    \paragraph{Implementation \& Optimizations}
    \begin{itemize}[leftmargin=*, label={--}]
        \item \textbf{Write-Ahead Log (WAL):} B-Trees overwrite pages on disk. Crash during multi-page update (split) $\rightarrow$ corruption.
        \newline $\rightarrow$ WAL writes modifications before updating tree pages $\rightarrow$ durability \& atomicity.
        \item \textbf{Concurrency (Latches):} Multiple threads access index concurrently $\rightarrow$ use latches (lightweight locks).
        \newline \textit{Latch Crabbing:} Lock parent $\rightarrow$ lock child $\rightarrow$ release parent $\rightarrow$ high concurrency.
        \item \textbf{Bulk Loading:} Inserting records one-by-one $\rightarrow$ random I/O $\rightarrow$ inefficient.
        \newline $\rightarrow$ Bulk load: Sort data $\rightarrow$ build tree bottom-up (sequential writes) $\rightarrow$ create parent nodes as needed.
        \item \textbf{Flash Storage (SSD):} Random reads fast, random writes expensive (erase-modify-write cycles).
        \newline $\rightarrow$ LSM-Tree (Log-Structured Merge-Tree) preferred for write-heavy workloads, but B-Trees remain general-purpose standard.
        \item \textbf{Prefix Compression:} Internal nodes only store prefix of key (enough to distinguish subtrees) instead of full key $\rightarrow$ increases fan-out.
        \item \textbf{Right-Only Appends:} With auto-incrementing keys, allocate new node when rightmost leaf full instead of split $\rightarrow$ avoids half-empty pages.
    \end{itemize}

    \subsubsection{Advanced Index Types}
    \begin{itemize}[leftmargin=*, label={--}]
        \item \textbf{Composite Indexes:} Multi-column keys (e.g., (City, LastName)); support leftmost prefix queries (City), (City, LastName); order columns by selectivity.
        \item \textbf{Function-Based Indexes:} Indexes on expressions (e.g., \texttt{LOWER(email)}); queries must use the exact function to utilize the index.
        \begin{itemize}
            \item \textit{Problem:} Standard index on \texttt{Name} is \textbf{useless} for \texttt{WHERE lower(Name) = '...'}.
            \item \textit{Solution:} \texttt{CREATE INDEX idx\_lower ON Employee (lower(Name));}
            \item \textit{Key Concept:} The index stores the \textit{result} of the function, allowing the DB to search directly on the computed values.
        \end{itemize}
    \end{itemize}

    \subsubsection{Chỉ mục Băm \& Bitmap}

    \paragraph{Chỉ mục Băm (Hash Indexes)}
    \begin{itemize}[leftmargin=*, label={--}]
        \item \textbf{Sử dụng:} Tìm kiếm chính xác cực nhanh (truy vấn điểm); không hỗ trợ khoảng.
        \item \textbf{Xử lý đụng độ:} Dùng danh sách liên kết (chaining) với bucket tràn.
        \item \textbf{Biến thể động:} Băm mở rộng/tuyến tính (Extendible/Linear hashing) tăng trưởng dần mà không cần xây lại toàn bộ.
    \end{itemize}

    \paragraph{Chỉ mục Bitmap}
    \textit{Tối ưu cho thuộc tính có độ chọn lọc thấp (ít giá trị riêng biệt).}
    \begin{itemize}[leftmargin=*, label={--}]
        \item \textbf{Cấu trúc:} Đánh số thứ tự bản ghi (0, 1, 2, ...); mỗi giá trị riêng biệt có một bitmap; bit $i=1$ nếu bản ghi $i$ có giá trị đó.
        \item \textbf{Ví dụ (bảng 5 dòng):}
            \begin{itemize}
                \item \texttt{gender='m'}: 10010 \quad \texttt{gender='f'}: 01101
                \item \texttt{income='L1'}: 11000 \quad \texttt{income='L2'}: 00100
            \end{itemize}
        \item \textbf{Truy vấn: gender='f' AND income='L2'}
        \item[] $01101 \; \text{AND} \; 00100 = 00100 \quad \Rightarrow \quad \text{bản ghi 2}$
        \item \textbf{Ưu điểm:} Gọn nhẹ (1 triệu dòng = 125 KB mỗi bitmap); thao tác bitwise nhanh; hiệu quả cho bộ lọc nhiều điều kiện; hỗ trợ COUNT qua đếm bit.
    \end{itemize}

    \paragraph{Chiến lược chọn Index (Heuristics)}
    \begin{itemize}[leftmargin=*, nosep]
        \item \textbf{Truy vấn khoảng ($>, <$, BETWEEN):} Bắt buộc dùng \textbf{B+ Tree}. (Hash index vô dụng).
        \item \textbf{Truy vấn chính xác ($=$):} \textbf{Hash Index} tốt nhất ($O(1)$), sau đó đến B+ Tree.
        \item \textbf{Update nhiều:} Hạn chế tạo quá nhiều Index (vì tốn chi phí cập nhật cây).
        \item \textbf{Thuộc tính độ chọn lọc thấp (Giới tính, True/False):} Dùng \textbf{Bitmap Index}.
    \end{itemize}

    % ----------------------------------------------------------------------------
    % SELECTION COST FUNCTIONS
    % ----------------------------------------------------------------------------
    \subsection{Hàm Chi phí \& Kỹ thuật Chỉ mục}

    % --- PHẦN BỔ SUNG QUAN TRỌNG TỪ ĐỀ THI ---
    \subsubsection{Index Properties \& Calculations}
    \begin{itemize}[leftmargin=*, nosep]
        \item \textbf{Dense Index:} Mỗi record có 1 index entry (dùng cho Secondary Index hoặc Primary Index trên file chưa sắp xếp). 
        \item \textbf{Sparse Index:} Mỗi block dữ liệu có 1 index entry (chỉ dùng cho Primary/Clustering Index trên file \textbf{đã sắp xếp}).
        \item \textbf{Số lượng Index Entries ($n_i$):}
        \begin{itemize}
            \item Sparse: $n_i = b$ (số data blocks).
            \item Dense: $n_i = r$ (số records).
        \end{itemize}
        \item \textbf{Số block của file Index ($b_i$):} $b_i = \lceil n_i / bfr_i \rceil$.
        \item \textbf{Index Levels ($x$):} $x = \lceil \log_{fan\_out} (b_i) \rceil$.
    \end{itemize}

    \subsubsection{Selection Cost Functions ($\sigma$)}
    \textit{Ký hiệu: $b$: data blocks, $r$: records, $x$: index levels, $s$: selection cardinality (số dòng thỏa điều kiện).}

    \paragraph{S1: Linear Search (File Scan)}\mbox{}\\
    Quét toàn bộ file (Heap file hoặc file không có index phù hợp).
    \begin{itemize}[leftmargin=*, label={--}, nosep]
        \item \textbf{Tìm Unique (Key):} $b/2$ (Trung bình).
        \item \textbf{Tìm Non-Unique/Range:} $b$ (Phải quét hết).
        \item \textbf{Khi nào dùng?} File nhỏ hoặc Selectivity thấp ($s$ lớn, >15-20\% số dòng).
    \end{itemize}

    \paragraph{S2: Binary Search (Sorted File)}\mbox{}\\
    Chỉ áp dụng nếu file đã sắp xếp theo trường tìm kiếm ($A$).
    \newline $\mathbf{C_{S2} = \lceil \log_2 b \rceil + \lceil s/bfr \rceil - 1}$
    \newline \textit{Lưu ý:} Ít dùng trong DB thực tế, thường dùng Primary Index thay thế.

    \paragraph{S3a: Primary Index (Unique Key) [Quan trọng]}\mbox{}\\
    File sắp xếp theo Key + B+-tree.
    \newline $\mathbf{C_{S3a} = x + 1}$
    \newline \textit{Exam Tip:} Nếu đề cho chiều cao cây (height) = $h$, thì $x=h$. Chi phí = Traversing Tree + 1 I/O lấy data.

    \paragraph{S3b: Hash Index (Equality Only)}\mbox{}\\
    \textbf{Chỉ dùng cho so sánh bằng ($=$).}
    \newline $\mathbf{C_{S3b} \approx 1}$.
    \newline \textit{\textbf{Cảnh báo Exam (Q9 - F1.1):}} Hash index \textbf{KHÔNG} hỗ trợ Range Query ($>, <, \geq$). Nếu query là `WHERE Dno > 10`, Hash Index vô dụng $\rightarrow$ Dùng B+-tree hoặc Scan.

    \paragraph{S5: Clustering Index (Non-Unique, Sorted File)}\mbox{}\\
    File sắp xếp theo trường tìm kiếm (không phải Key). Records nằm liền nhau.
    \newline $\mathbf{C_{S5} = x + \lceil s/bfr \rceil}$
    \newline \textit{Hiệu quả:} Tốt nhất cho Range Query hoặc Non-Unique Equality.

    \paragraph{S6a: Secondary Index (Equality) [Hay gặp nhất]}\mbox{}\\
    File \textbf{không} sắp xếp theo trường này.
    \newline $\mathbf{C_{S6a} = x + s}$ (hoặc $x + s + 1$ nếu tính cả block đầu).
    \newline \textit{Worst case:} Mỗi record nằm ở 1 block khác nhau $\rightarrow$ $s$ lần Random I/O.
    \newline \textit{So sánh (Q16 - F1.1):} Nếu truy vấn trả về 1 dòng ($s=1$) $\rightarrow$ Cost = $x+1$. Rất rẻ so với Linear Scan ($b$).

    \paragraph{S6b: Secondary Index (Range Query)}\mbox{}\\
    Dùng B+-tree trên trường phụ.
    \newline $\mathbf{C_{S6b} = x + (\text{leaf blocks}/2) + s}$
    \newline \textit{Exam Trap:} Nếu Range rộng (lấy > 30\% dữ liệu), Optimizer sẽ bỏ qua Index và chọn Linear Scan (S1) vì Random I/O quá đắt.

    % ----------------------------------------------------------------------------
    % SUMMARY TABLE (Fit for Exam Quick Look)
    % ----------------------------------------------------------------------------
    \subsubsection{Bảng Tra Cứu Nhanh}
    \begin{center}
        \renewcommand{\arraystretch}{1.15}
        \begin{tabular}{@{} l | l | l @{}}
            \toprule
            \textbf{Algorithm} & \textbf{Mô tả} & \textbf{Block Accesses} \\
            \midrule
            \textbf{S1} & Linear Search & $b$ \\
            \textbf{S2} & Binary Search & $\lceil \log_2 b \rceil + \lceil s/bfr \rceil - 1$ \\
            \textbf{S3a} & Primary Index (Unique) & $x + 1$ \\
            \textbf{S5} & Clustering Index (Equality) & $x + \lceil s/bfr \rceil$ \\
            \textbf{S6a} & Secondary Index (Equality) & $x + s + 1$ \\
            \textbf{S6b} & Secondary Index (Range) & $x + (b_{I1}/2) + (r/2)$ \\
            \bottomrule
        \end{tabular}
    \end{center}

    \subsubsection{Hàm Chi phí cho Phép Kết (JOIN Operations)}

    \paragraph{Ký hiệu (Notation)}
    \begin{itemize}[leftmargin=*, nosep]
        \item $b_r, b_s$: Số block của quan hệ $R$ và $S$.
        \item $n_r, n_s$: Số dòng (tuples) của quan hệ $R$ và $S$.
        \item $n_B$: Số block bộ đệm (memory buffer) khả dụng.
        \item \textbf{Nguyên tắc vàng:} Luôn chọn quan hệ nhỏ hơn (ít block hơn) làm vòng lặp ngoài (Outer Loop) để tối ưu hóa bộ đệm.
    \end{itemize}

    \paragraph{J1: Block Nested-Loop Join (Quét toàn bộ)}\mbox{}\\
    Dùng khi không có Index nào phù hợp. Đọc từng block của $R$ (ngoài), quét toàn bộ $S$ (trong).
    \begin{itemize}[leftmargin=*, label={--}]
        \item \textbf{Trường hợp Tệ nhất (Worst Case - 3 buffers):}
        \newline $\mathbf{Cost = b_r + (b_r \times b_s)}$ block transfers.
        \newline \textit{Giải thích:} Đọc mỗi block $R$ 1 lần, với mỗi block $R$ phải đọc lại toàn bộ $S$.
        
        \item \textbf{Trường hợp Có Buffer ($n_B > 3$):} 
        \newline $\mathbf{Cost = b_r + \lceil b_r / (n_B - 2) \rceil \times b_s}$
        \newline \textit{Exam Tip (Đề Tham Khảo Câu 2.2):} Hệ số $\lceil b_r / (n_B - 2) \rceil$ là số lần phải quét lại bảng $S$. Nếu $n_B$ càng lớn, chi phí càng giảm về gần $b_r + b_s$.
    \end{itemize}

    \paragraph{J2: Indexed Nested-Loop Join (Index trên bảng TRONG)}\mbox{}\\
    Bảng ngoài ($R$) quét tuần tự, bảng trong ($S$) dùng Index để tìm khớp.
    \newline \textbf{Điều kiện:} Bảng $S$ phải có Index trên thuộc tính Join.
    \begin{itemize}[leftmargin=*, label={--}]
        \item \textbf{Công thức Tổng quát:}
        \newline $\mathbf{Cost = b_r + n_r \times (\text{Cost per Probe})}$
        \newline \textit{Lưu ý:} Phụ thuộc vào số dòng ($n_r$) của bảng ngoài, không phải số block ($b_r$). Do đó, bảng ngoài nên có ít dòng.
        
        \item \textbf{Chi tiết Cost per Probe:}
        \begin{itemize}
            \item \textit{Primary Index (S):} $x + 1$ (Rất rẻ).
            \item \textit{Secondary Index (S):} $x + s$ (Đắt hơn nếu $s$ lớn).
            \item \textit{Hash Index (S):} $\approx 1$ (Rất rẻ cho Equi-Join).
        \end{itemize}
        
        \item \textbf{So sánh với J1 (Câu 11 - F1.1):} Optimizer thường chuyển Cross-Join (J1) thành Theta-Join/Equi-Join (J2) để tận dụng Index, giảm chi phí từ $b_r \times b_s$ xuống tuyến tính theo $n_r$.
    \end{itemize}

    \paragraph{J3: Sort-Merge Join (Dữ liệu đã sắp xếp)}\mbox{}\\
    Hiệu quả nhất nếu cả hai bảng đã được sắp xếp theo thuộc tính Join.
    \begin{itemize}[leftmargin=*, label={--}]
        \item \textbf{Chi phí (Đã sắp xếp):} $\mathbf{b_r + b_s}$. (Đọc mỗi bảng 1 lần).
        \item \textbf{Chi phí (Chưa sắp xếp):} Cost(Sort $R$) + Cost(Sort $S$) + $b_r + b_s$.
        \item \textbf{Khi nào dùng?} Khi kết quả cần sắp xếp (ORDER BY) hoặc dữ liệu đã có sẵn thứ tự (Clustered Index).
    \end{itemize}

    \paragraph{J4: Hash Join (In-Memory Partitioning)}\mbox{}\\
    Chỉ dùng cho Equi-Join ($=$). Partition bảng $R$ và $S$ vào các bucket băm.
    \begin{itemize}[leftmargin=*, label={--}]
        \item \textbf{Chi phí (Standard):} $\mathbf{3(b_r + b_s)}$.
        \newline \textit{Giải thích:} 1. Đọc $R, S$ để partition (ghi ra đĩa) $\rightarrow$ 2. Đọc lại partition để join. Tổng cộng đọc + ghi + đọc = 3 lần.
        \item \textbf{Điều kiện:} Partition của bảng nhỏ phải vừa đủ bộ nhớ (Memory).
    \end{itemize}

    % ----------------------------------------------------------------------------
    % VÍ DỤ TÍNH TOÁN THỰC TẾ (MÔ PHỎNG ĐỀ THI)
    % ----------------------------------------------------------------------------
    \subsubsection{Ví dụ Tính Toán: EMPLOYEE $\bowtie$ DEPARTMENT}
    \textit{Thông số:} 
    \begin{itemize}[nosep]
        \item \textbf{EMP (E):} $n_E = 10{,}000$, $b_E = 2{,}000$. (Bảng lớn)
        \item \textbf{DEPT (D):} $n_D = 125$, $b_D = 13$. (Bảng nhỏ)
        \item \textbf{Index:} Primary Key trên $D.Dnumber$ ($x=1$). Foreign Key trên $E.Dno$ (Secondary, $x=2$).
    \end{itemize}

    \paragraph{Kịch bản 1: Block Nested Loop (Không dùng Index)}
    \begin{itemize}[leftmargin=*, label={--}]
        \item \textit{D là Outer (Tối ưu):} $b_D + (b_D \times b_E) = 13 + (13 \times 2{,}000) = \mathbf{26{,}013}$.
        \item \textit{E là Outer (Tệ):} $b_E + (b_E \times b_D) = 2{,}000 + (2{,}000 \times 13) = 28{,}000$.
        \newline $\rightarrow$ Chọn bảng nhỏ làm Outer tiết kiệm được một chút, nhưng vẫn rất đắt.
    \end{itemize}

    \paragraph{Kịch bản 2: Indexed Nested Loop (Tận dụng Index)}
    \begin{itemize}[leftmargin=*, label={--}]
        \item \textit{Dùng Primary Index trên D (E là Outer):}
        \newline Quét $E$ ($b_E$) + Tra cứu Index $D$ cho mỗi dòng $E$ ($n_E \times (x+1)$).
        \newline $2{,}000 + 10{,}000 \times (1 + 1) = \mathbf{22{,}000}$ blocks. (Vẫn đắt do $n_E$ quá lớn).
        
        \item \textit{Dùng Secondary Index trên E (D là Outer - \textbf{BEST J2}):}
        \newline Quét $D$ ($b_D$) + Tra cứu Index $E$ cho mỗi dòng $D$ ($n_D \times \text{Cost}(E)$).
        \newline Cost tìm $E$ cho 1 $Dno$: Index ($x=2$) + Data ($s=80$ block ngẫu nhiên) = 82.
        \newline Tổng: $13 + 125 \times 82 = 13 + 10{,}250 = \mathbf{10{,}263}$ blocks.
        \newline $\rightarrow$ \textbf{Kết luận:} Dùng bảng nhỏ (D) làm Outer + Index trên bảng lớn (E) hiệu quả gấp đôi cách ngược lại.
    \end{itemize}

    \paragraph{Kịch bản 3: Hash Join vs Sort-Merge}
    \begin{itemize}[leftmargin=*, label={--}]
        \item \textit{Sort-Merge (Chưa sort):} Cần sort $E$ ($2000 \log 2000$) rất đắt. Không chọn trừ khi đã sort sẵn.
        \item \textit{Hash Join:} $3 \times (2{,}000 + 13) = \mathbf{6{,}039}$ blocks.
        \newline $\rightarrow$ \textbf{Hash Join} chiến thắng tuyệt đối nếu bộ nhớ đủ chứa 13 block của $D$.
    \end{itemize}
    % ----------------------------------------------------------------------------
    % TỐI ƯU HÓA THỨ TỰ KẾT NỐI
    % ----------------------------------------------------------------------------
    \subsubsection{Tối ưu hóa Thứ tự Phép Kết (Join Order Optimization)}
    \textit{Mục tiêu: Tìm kế hoạch thực thi có chi phí thấp nhất trong số $n!$ thứ tự kết nối có thể.}

    \paragraph{Quy hoạch Động (Phương pháp System R)}\mbox{}\\
    Thuật toán chuẩn được hầu hết các bộ tối ưu hóa (optimizers) sử dụng.
    \begin{itemize}[leftmargin=*, label={--}]
        \item \textbf{Bước 1:} Tìm kế hoạch tốt nhất để truy cập từng quan hệ đơn lẻ (Quét chỉ mục vs Quét toàn bộ).
        \item \textbf{Bước 2:} Tìm kế hoạch tốt nhất để kết nối các cặp quan hệ ($R \bowtie S$).
        \item \textbf{Bước 3:} Tìm kế hoạch tốt nhất để kết nối 3 quan hệ sử dụng kết quả từ Bước 2.
        \item \textbf{Nguyên lý Tối ưu (Principle of Optimality):} Một kế hoạch tối ưu cho $(R \bowtie S \bowtie T)$ bắt buộc phải chứa một kế hoạch tối ưu cho phép kết con $(R \bowtie S)$.
    \end{itemize}

    \paragraph{Cây Nghiêng Trái (Left-Deep Trees) [Khái niệm Quan trọng]}\mbox{}\\
    Các bộ tối ưu hóa thường giới hạn không gian tìm kiếm vào các \textbf{Left-Deep Trees}.
    \begin{itemize}[leftmargin=*, label={--}]
        \item \textbf{Cấu trúc:} Nút con bên \textit{phải} của bất kỳ nút kết nối (join node) nào luôn là một \textbf{Bảng Cơ sở} (Base Table) (không phải là kết quả trung gian).
        \item \textbf{Tại sao lại là Left-Deep? (Câu hỏi thi):}
        \begin{itemize}
            \item \textbf{Tận dụng Chỉ mục:} Vì quan hệ trong (bên phải) là một bảng cơ sở, ta có thể sử dụng các \textbf{Chỉ mục (Indexes)} hiện có cho thuật toán Nested-Loop Joins.
            \item \textbf{Pipelining (Đường ống):} Cho phép thực hiện pipelining hiệu quả (dữ liệu đi lên từ phía trái, thăm dò/đối chiếu với phía phải).
            \item \textbf{Không gian Tìm kiếm:} Giảm độ phức tạp từ $O(4^n)$ (Cây rậm - Bushy) xuống $O(n!)$.
        \end{itemize}
        \item \textbf{Đánh đổi:} Có thể bỏ lỡ kế hoạch tối ưu tuyệt đối (ví dụ: nếu một cây Bushy thực sự rẻ hơn), nhưng quá trình tối ưu hóa nhanh hơn nhiều.
    \end{itemize}

    % ----------------------------------------------------------------------------
    % ĐÁNH GIÁ TRUY VẤN (QUERY EVALUATION)
    % ----------------------------------------------------------------------------
    \subsection{Phase 3: Query Evaluation (Thời gian chạy/Runtime)}

    \subsubsection{Mô hình Iterator (Mô hình Volcano)}
    Giao diện chuẩn cho tất cả các toán tử (Select, Join, Sort).
    \begin{itemize}[leftmargin=*, nosep]
        \item \textbf{open():} Khởi tạo trạng thái (ví dụ: cấp phát bộ đệm).
        \item \textbf{next():} Trả về \textbf{từng bộ (tuple)} (hoặc một lô) tại một thời điểm.
        \item \textbf{close():} Giải phóng tài nguyên.
        \item \textit{Lợi ích:} Cho phép Pipelining (các toán tử kéo dữ liệu theo nhu cầu).
    \end{itemize}

    \subsubsection{Materialization vs. Pipelining [So sánh trong Đề thi]}

    \paragraph{1. Materialization (Vật chất hóa/Lưu trữ tạm)}\mbox{}\\
    Ghi kết quả của mỗi phép toán vào một \textbf{Bảng Tạm (Temporary Table)} trên đĩa trước khi bắt đầu phép toán tiếp theo.
    \begin{itemize}[leftmargin=*, label={--}]
        \item \textbf{Ưu điểm:} Đơn giản; Checkpoint/Khởi động lại dễ dàng hơn; Tiết kiệm bộ nhớ.
        \item \textbf{Nhược điểm:} \textbf{Chi phí I/O cao} (Ghi tạm + Đọc tạm); Độ trễ cao (phải đợi kết quả đầy đủ).
        \item \textbf{Khi nào dùng?} Khi kết quả trung gian quá lớn so với bộ nhớ hoặc cần được sắp xếp.
    \end{itemize}

    \paragraph{2. Pipelining (Xử lý tức thì/Trên đường truyền)}\mbox{}\\
    Truyền các bộ dữ liệu từ nút con sang nút cha ngay lập tức thông qua bộ đệm bộ nhớ.
    \begin{itemize}[leftmargin=*, label={--}]
        \item \textbf{Ưu điểm:} \textbf{Không có Disk I/O} cho kết quả trung gian; Độ trễ thấp (hàng đầu tiên xuất hiện ngay lập tức).
        \item \textbf{Nhược điểm:} Yêu cầu nhiều bộ nhớ hoạt động hơn (các bộ đệm).
        \item \textbf{Pipeline Breakers (Các toán tử gây chặn):} Các phép toán \textbf{không thể} pipeline vì chúng cần \textit{toàn bộ} đầu vào trước khi tạo ra hàng kết quả đầu tiên.
        \begin{itemize}
            \item \textbf{Sort (Sắp xếp):} Phải đọc tất cả các hàng để tìm hàng nhỏ nhất.
            \item \textbf{Aggregate (GROUP BY):} Phải đọc tất cả các hàng trong một nhóm để tính tổng/đếm.
            \item \textbf{Hash Join (Giai đoạn Build):} Phải xây dựng bảng băm đầy đủ trước khi thăm dò (probing).
        \end{itemize}
    \end{itemize}

    \subsubsection{Bảng Tra Cứu Nhanh Kế hoạch Đánh giá}
    \begin{center}
        \renewcommand{\arraystretch}{1.2}
        \begin{tabular}{@{} p{0.21\linewidth} | p{0.35\linewidth} | p{0.35\linewidth} @{}}
            \hline
            \textbf{Đặc điểm} & \textbf{Materialization} & \textbf{Pipelining} \\
            \hline
            \textbf{Chi phí I/O} & Cao (Ghi bảng tạm) & Thấp (Chỉ dùng bộ nhớ) \\
            \hline
            \textbf{Độ trễ (Latency)} & Cao (Đợi tất cả) & Thấp (Hàng đầu tiên nhanh) \\
            \hline
            \textbf{Bộ nhớ} & Thấp (Từng phép toán một) & Cao (Các phép toán đồng thời) \\
            \hline
            \textbf{Trường hợp dùng} & Sắp xếp phức tạp / Big Data & Truy vấn thời gian thực \\
            \hline
        \end{tabular}
    \end{center}

    % ============================================================================
    % SECTION: Big Data & Data Engineering
    % ============================================================================
    \section{Big Data \& Data Engineering}

    % ============================================================================
    % TIER 1: FOUNDATIONAL CONCEPTS
    % ============================================================================
    \subsection{Đặc trưng Big Data (The Vs)}
    \begin{itemize}[leftmargin=*, label={--}]
        \item \textbf{5V Cốt lõi (Core):}
        \begin{itemize}
            \item \textbf{Volume:} Dung lượng khổng lồ (TB, PB, ZB).
            \item \textbf{Velocity:} Tốc độ sinh ra \& xử lý (Batch $\to$ Streaming).
            \item \textbf{Variety:} Đa dạng định dạng (Structured, JSON, Video, Log).
            \item \textbf{Veracity:} Độ tin cậy, tính xác thực (Messy/Noisy data).
            \item \textbf{Value:} Giá trị chuyển hóa thành lợi ích kinh doanh.
        \end{itemize}
        
        \item \textbf{Các V Mở rộng (Extended):}
        \begin{itemize}
            \item \textbf{Variability:} Tính biến thiên (Ý nghĩa dữ liệu thay đổi theo ngữ cảnh/thời gian).
            \item \textbf{Validity:} Tính hợp lệ (Dữ liệu có đúng định dạng/chuẩn để dùng không).
            \item \textbf{Vulnerability:} Tính bảo mật (Dễ bị tấn công/rò rỉ).
            \item \textbf{Volatility:} Độ bay hơi (Thời gian lưu trữ trước khi xóa/lưu trữ lâu dài).
            \item \textbf{Visualization:} Khả năng trực quan hóa (Để con người hiểu được).
        \end{itemize}
    \end{itemize}

    \columnbreak

    \subsection{Paradigm: Batch vs Streaming}
    \textit{Hai mô hình xử lý dữ liệu cơ bản trong Big Data.}
    \begin{center}
        \renewcommand{\arraystretch}{1.2}
        \begin{tabular}{@{} p{0.15\linewidth} | p{0.38\linewidth} | p{0.38\linewidth} @{}}
            \toprule
            & \textbf{Batch Processing} & \textbf{Streaming Processing} \\
            \midrule
            \textbf{Đặc trưng} & Xử lý dữ liệu tĩnh, lượng lớn theo lô. & Xử lý dữ liệu động, liên tục theo thời gian thực. \\
            \textbf{Độ trễ} & Cao (minutes - hours). & Thấp (seconds - milliseconds). \\
            \textbf{Công cụ} & Hadoop MapReduce, Apache Spark (Batch mode). & Apache Flink, Spark Streaming, Kafka Streams. \\
            \textbf{Use Case} & ETL, báo cáo cuối ngày, ML training. & Real-time analytics, fraud detection, monitoring. \\
            \textbf{Ưu điểm} & Xử lý hiệu quả khối lượng lớn, đơn giản. & Phản hồi nhanh, phát hiện sự kiện ngay lập tức. \\
            \textbf{Nhược điểm} & Không real-time, lãng phí khi data nhỏ. & Phức tạp, khó debug, cần xử lý out-of-order. \\
            \bottomrule
        \end{tabular}
    \end{center}
    \textbf{Kiến trúc Lai (Hybrid):}
    \begin{itemize}[leftmargin=*, label={--}]
        \item \textbf{Lambda Architecture:} Batch layer (chính xác) + Speed layer (real-time) + Serving layer. Phức tạp, duy trì 2 code base.
        \item \textbf{Kappa Architecture:} Chỉ dùng Streaming (đơn giản hóa). Mọi dữ liệu qua stream processor, replay từ Kafka khi cần.
    \end{itemize}

    \subsection{Partitioning \& Replication}
    
    \subsubsection{Sao chép (Replication)}
    \textit{Mục đích: High Availability (HA) và giảm độ trễ đọc.}
    \begin{itemize}[leftmargin=*, label={--}]
        \item \textbf{Single-Leader (Master-Slave):} Mọi ghi vào Leader, Leader chép sang Followers. \textit{Dễ nhất quán, nhưng Leader là nút cổ chai.}
        \item \textbf{Multi-Leader:} Nhiều node chấp nhận ghi. \textit{Tốt cho đa trung tâm dữ liệu, nhưng khó xử lý xung đột.}
        \item \textbf{Leaderless (Dynamo-style):} Ghi/Đọc gửi tới nhiều node. Dùng cơ chế \textbf{Quorum} để xác nhận:
        \newline $w + r > n$ (Write nodes + Read nodes > Total replicas) $\rightarrow$ Đảm bảo đọc thấy dữ liệu mới nhất.
    \end{itemize}

    \subsubsection{Phân mảnh (Partitioning/Sharding)}
    \textit{Mục đích: Scalability (Mở rộng dung lượng/băng thông).}
    \begin{itemize}[leftmargin=*, label={--}]
        \item \textbf{Key Range Partitioning:} Chia theo khoảng khóa (A-C, D-F). 
        \newline $\rightarrow$ \textit{Ưu:} Query theo khoảng (Range scan) hiệu quả. 
        \newline $\rightarrow$ \textit{Nhược:} Dễ bị \textit{Hotspot} (nếu user dồn vào vần A).
        \item \textbf{Hash Partitioning:} Băm khóa để chia đều ($hash(key) \% N$).
        \newline $\rightarrow$ \textit{Ưu:} Phân phối đều, tránh Hotspot.
        \newline $\rightarrow$ \textit{Nhược:} Mất khả năng Range Query (phải quét tất cả).
    \end{itemize}

    \columnbreak

    \subsection{Định dạng Lưu trữ (File Formats)}
    \textit{Lựa chọn định dạng ảnh hưởng trực tiếp đến hiệu năng đọc/ghi.}
    
    \subsubsection{Row-based vs. Column-based}
    \begin{itemize}[leftmargin=*, label={--}]
        \item \textbf{Row-oriented (CSV, Avro):}
        \begin{itemize}
            \item Lưu trữ tuần tự từng dòng.
            \item \textit{Ưu điểm:} Ghi nhanh (append), tốt khi truy xuất toàn bộ thông tin của 1 entity (OLTP).
            \item \textit{Nhược điểm:} Chậm khi tính toán tổng hợp (SUM, AVG) vì phải đọc cả dữ liệu không cần thiết.
        \end{itemize}
        \item \textbf{Column-oriented (Parquet, ORC):}
        \begin{itemize}
            \item Lưu trữ riêng biệt từng cột.
            \item \textit{Ưu điểm:} Nén cực tốt (do dữ liệu cùng kiểu), tối ưu cho OLAP (chỉ đọc cột cần thiết).
            \item \textit{Nhược điểm:} Ghi chậm, update tốn kém.
        \end{itemize}
    \end{itemize}

    \subsubsection{So sánh Avro, Parquet, ORC}
    \begin{center}
    \renewcommand{\arraystretch}{1.1}
    \begin{tabular}{@{} l l l @{}}
        \toprule
        \textbf{Đặc điểm} & \textbf{Avro} & \textbf{Parquet} \\
        \midrule
        \textbf{Mô hình} & Row-based & Column-based \\
        \textbf{Schema} & JSON (lưu trong file) & Binary (footer) \\
        \textbf{Tối ưu cho} & Ghi nhiều (Write heavy) & Đọc nhiều (Read heavy) \\
        \textbf{Schema Evo} & Rất tốt (Thêm/bớt field) & Hạn chế \\
        \textbf{Ecosystem} & Kafka, Hadoop & Spark, Impala, Presto \\
        \bottomrule
    \end{tabular}
    \end{center}

    % ============================================================================
    % TIER 2: STORAGE LAYER
    % ============================================================================
    \subsection{Hadoop Ecosystem}
    \textit{Open-source framework for distributed storage and processing.}
    \begin{enumerate}[leftmargin=*, label={\textbf{\arabic*.}}]
        \item \textbf{HDFS (Storage):} Distributed file system.
        \begin{itemize}
            \item \textit{NameNode:} Manages metadata (block locations).
            \item \textit{DataNode:} Stores actual data blocks.
            \item \textit{Mechanism:} Splits files into blocks (128MB), replicates (x3) for fault tolerance.
        \end{itemize}
        \item \textbf{YARN (Resource Management):} "Operating system" of the cluster.
        \begin{itemize}
            \item Distributes resources (RAM, CPU) to applications.
            \item Allows multiple engines (Spark, MapReduce) to run on the same cluster.
        \end{itemize}
        \item \textbf{MapReduce (Processing):} Batch processing model - divide and conquer on a distributed cluster.
        \begin{itemize}
            \item \textit{Map:} Chia nhỏ \& Gán nhãn. Input $\rightarrow$ Split $\rightarrow$ \texttt{<Key, Value>}.
            \item \textit{Shuffle:} Xáo trộn \& Gom nhóm. Chuyển dữ liệu qua mạng, gom cùng Key.
            \item \textit{Reduce:} Tổng hợp. Xử lý danh sách Value của mỗi Key.
        \end{itemize}
    \end{enumerate}

    \columnbreak

    \subsection{Công nghệ NoSQL (Storage Tech)}
    \textit{Các mô hình NoSQL cho use case khác nhau.}

    \paragraph{MongoDB (Document Store)}
    \begin{itemize}[leftmargin=*, label={--}]
        \item \textbf{Mô hình:} Schema-on-read, lưu trữ JSON/BSON documents. Collections thay vì tables.
        \item \textbf{Ưu điểm:} Linh hoạt schema (mỗi doc có cấu trúc khác nhau), dễ scale horizontal (sharding), query mạnh (aggregation pipeline).
        \item \textbf{Architecture:} Replica Sets (HA), Sharding (scale-out), WiredTiger storage engine.
        \item \textbf{Use Case:} CMS, Mobile apps, Catalog, Real-time analytics. \textit{VD: Forbes, eBay, Uber.}
        \item \textbf{Trade-offs:} Không ACID cross-document (trước v4.0), chiếm RAM nhiều.
    \end{itemize}

    \paragraph{Redis (Key-Value Store)}
    \begin{itemize}[leftmargin=*, label={--}]
        \item \textbf{Mô hình:} In-memory key-value, data structures (String, Hash, List, Set, Sorted Set).
        \item \textbf{Ưu điểm:} Cực nhanh ($<1$ms latency), atomic operations, support pub/sub, Lua scripting.
        \item \textbf{Persistence:} RDB (snapshot) hoặc AOF (append-only log). Có thể dùng cả 2.
        \item \textbf{Use Case:} Caching (session, query result), Message Queue (Celery), Leaderboard, Rate limiting. \textit{VD: Twitter, GitHub, Stack Overflow.}
        \item \textbf{Trade-offs:} Giới hạn RAM, single-threaded (1 core), không có query phức tạp.
    \end{itemize}

    \paragraph{Cassandra (Wide-Column Store)}
    \begin{itemize}[leftmargin=*, label={--}]
        \item \textbf{Mô hình:} Wide-column, mỗi row có thể có số cột khác nhau. Organize theo Column Family.
        \item \textbf{Ưu điểm:} Ghi cực nhanh (LSM Tree), linear scalability, masterless (P2P), multi-datacenter replication.
        \item \textbf{Architecture:} Consistent hashing (ring), tunable consistency (quorum), compaction strategies.
        \item \textbf{Use Case:} Time-series data, IoT sensor logs, Event logging, Messaging. \textit{VD: Netflix, Apple, Instagram.}
        \item \textbf{Trade-offs:} Đọc chậm hơn (nhiều SSTable), không join, modeling phức tạp (query-first design).
    \end{itemize}

    \paragraph{Neo4j (Graph Database)}
    \begin{itemize}[leftmargin=*, label={--}]
        \item \textbf{Mô hình:} Nodes (entities) + Relationships (edges) + Properties. Native graph storage.
        \item \textbf{Ưu điểm:} Traversal cực nhanh (follow pointers), query trực quan (Cypher), ACID transactions.
        \item \textbf{Architecture:} Index-free adjacency (mỗi node chứa pointer đến neighbors).
        \item \textbf{Use Case:} Social networks, Recommendation engines, Fraud detection, Knowledge graphs. \textit{VD: LinkedIn, Walmart, eBay.}
        \item \textbf{Trade-offs:} Scale khó hơn NoSQL khác, không tốt cho bulk data processing.
    \end{itemize}

    % ============================================================================
    % TIER 3: PROCESSING LAYER
    % ============================================================================
    \subsection{Batch Processing}

    \subsubsection{Apache Spark (Unified Analytics Engine)}
    \textit{Thay thế MapReduce với tốc độ cao hơn 100x (in-memory).}
    \begin{itemize}[leftmargin=*, label={--}]
        \item \textbf{Core Concept:} RDD (Resilient Distributed Dataset) - immutable, partitioned, parallel.
        \begin{itemize}
            \item \textit{Transformations:} Lazy (map, filter, join) - tạo DAG.
            \item \textit{Actions:} Eager (collect, count, save) - trigger execution.
        \end{itemize}
        \item \textbf{Components:}
        \begin{itemize}
            \item \textit{Spark SQL:} Query structured data (DataFrame/Dataset API).
            \item \textit{Spark Streaming:} Micro-batch streaming (DStream).
            \item \textit{MLlib:} Machine learning library (classification, clustering, etc.).
            \item \textit{GraphX:} Graph processing (PageRank, connected components).
        \end{itemize}
        \item \textbf{Ưu điểm:} In-memory caching, lazy evaluation, DAG optimization, unified API (batch + streaming).
        \item \textbf{Nhược điểm:} Tốn RAM, không true streaming (micro-batch), overhead cho job nhỏ.
        \item \textbf{Use Case:} ETL, ML training, interactive analytics, log processing. \textit{VD: Netflix, Uber, Airbnb.}
    \end{itemize}

    \subsubsection{Big Data Warehousing / SQL-on-Hadoop}
    \textit{Các công cụ SQL Analytics cho Big Data - phân biệt với NoSQL operational stores.}
    \begin{itemize}[leftmargin=*, label={--}]
        \item \textbf{Apache Hive:} SQL-on-Hadoop, metadata layer trên HDFS. Batch-oriented, high latency.
        \item \textbf{Google BigQuery:} Serverless, columnar storage (Dremel), auto-scaling, pay-per-query.
        \item \textbf{AWS Redshift:} Managed columnar DW, massively parallel processing (MPP).
        \item \textbf{Snowflake:} Cloud-native DW, tách biệt storage/compute, near-zero admin.
        \item \textbf{Presto/Trino:} Distributed SQL query engine, federated queries across data sources.
    \end{itemize}
    \textit{Phân biệt:} Các công cụ trên dùng cho \textbf{Analytics/OLAP}, khác với NoSQL (MongoDB, Cassandra) dùng cho \textbf{Operational/OLTP}.


    \columnbreak
    % --- PHẦN 4: XỬ LÝ LUỒNG (STREAMING) ---
    \subsection{Streaming Processing}
    \textit{Xử lý dữ liệu liên tục, độ trễ thấp (Real-time).}
    
    \subsubsection{Các chiến lược xử lý (Strategies)}
    \begin{itemize}[leftmargin=*, label={--}]
        \item \textbf{Thời gian (Time Domain):}
        \begin{itemize}
            \item \textit{Event Time:} Thời gian sự kiện xảy ra (quan trọng nhất).
            \item \textit{Processing Time:} Thời gian hệ thống nhận được dữ liệu.
            \item \textit{Watermark:} Cơ chế xử lý độ trễ (data đến muộn) trong Event Time.
        \end{itemize}
        \item \textbf{Cửa sổ (Windowing):}
        \begin{itemize}
            \item \textit{Tumbling:} Cố định, không chồng (vd: mỗi 5p).
            \item \textit{Hopping/Sliding:} Có chồng lấp (vd: 5p, trượt mỗi 1p).
            \item \textit{Session:} Dựa trên hoạt động người dùng (hết timeout thì đóng).
        \end{itemize}
        \item \textbf{Đảm bảo (Guarantees):}
        \begin{itemize}
            \item \textit{At-most-once:} Gửi 1 lần, chấp nhận mất (vd: Log).
            \item \textit{At-least-once:} Không mất, chấp nhận trùng lặp.
            \item \textit{Exactly-once:} Chính xác 1 lần (Khó nhất, cần Flink/Kafka).
        \end{itemize}
    \end{itemize}

    % ============================================================================
    % TIER 4: INTEGRATION & ORCHESTRATION
    % ============================================================================
    \subsection{Giao thức IoT (IoT Protocols)}
    \subsubsection{MQTT (Message Queue Telemetry Transport)}

    \paragraph{Design Philosophy}\mbox{}\\
    Được thiết kế cho \textbf{constrained devices (thiết bị hạn chế)} trong môi trường mạng khó khăn:
    \begin{itemize}[leftmargin=*, label={--}]
        \item \textbf{Low bandwidth (băng thông thấp):} Minimized data packets (gói dữ liệu tối thiểu).
        \item \textbf{High latency (độ trễ cao):} Tối ưu cho mạng chậm.
        \item \textbf{Unreliable networks (mạng không ổn định):} Xử lý mất kết nối, chập chờn.
        \item \textbf{Low power usage:} Tiết kiệm pin cho IoT devices.
        \item \textbf{Real-time processing:} Hỗ trợ xử lý real-time cho streaming data.
    \end{itemize}

    \paragraph{Architecture: Publish-Subscribe Model}\mbox{}\\
    Khác với client-server truyền thống (client connect trực tiếp client), MQTT dùng \textbf{pub-sub model}.
    \begin{itemize}[leftmargin=*, label={--}]
        \item \textbf{Broker:} Central component nhận published messages và deliver đến subscribers phù hợp.
        \newline \textit{Flow:} Client gửi \texttt{CONNECT} $\rightarrow$ Broker trả \texttt{CONNACK}.
        \item \textbf{Publisher:} Client publish message đến broker với specific topic.
        \item \textbf{Subscriber:} Client listen incoming messages trên particular topics.
        \item \textbf{Advantage:} Decoupling (tách rời) - publisher không cần biết subscriber, scale dễ dàng.
    \end{itemize}

    \columnbreak

    \paragraph{Topics (Routing Mechanism)}\mbox{}\\
    \textbf{Structure:} Hierarchical strings với topic levels phân cách bởi \texttt{/}.
    \begin{center}
        \renewcommand{\arraystretch}{1.15}
        \begin{tabular}{@{} p{0.15\linewidth} | l | p{0.50\linewidth} @{}}
            \toprule
            \textbf{Type} & \textbf{Pattern} & \textbf{Matches \& Description} \\
            \midrule
            \textbf{Exact} & \texttt{area1/humidity} & Chỉ match chính xác topic này. \textit{Use:} Specific sensor. \\
            \addlinespace[2pt]
            \textbf{Single-level} & \texttt{area1/+} & \texttt{+} matches \textit{1} level bất kỳ.\newline $\checkmark$ \texttt{area1/humidity}, \texttt{area1/light}\newline $\times$ \texttt{area1/sensors/temp} \\
            \addlinespace[2pt]
            \textbf{Multi-level} & \texttt{area1/\#} & \texttt{\#} matches \textit{tất cả} levels.\newline $\checkmark$ \texttt{area1/humidity}, \texttt{area1/sensors/temp}\newline $\checkmark$ \texttt{area1/zone2/light} \\
            \addlinespace[2pt]
            \textbf{Root wildcard} & \texttt{\#} & Matches \textit{everything} in broker.\newline (Use with caution - high load) \\
            \bottomrule
        \end{tabular}
    \end{center}
    \textit{Smart Farming Example:} Publisher sends \texttt{area1/humidity:65\%} $\rightarrow$ Subscribers với patterns \texttt{area1/humidity}, \texttt{area1/+}, hoặc \texttt{area1/\#} đều nhận được.

    \paragraph{Quality of Service (QoS) Levels}\mbox{}\\
    Để xử lý network reliability khác nhau, MQTT định nghĩa 3 QoS levels:
    \begin{center}
        \renewcommand{\arraystretch}{1.15}
        \begin{tabular}{@{} c | l | p{0.55\linewidth} @{}}
            \toprule
            \textbf{Level} & \textbf{Guarantee} & \textbf{Mechanism \& Use Case} \\
            \midrule
            \textbf{0} & At most once & Delivered once, no confirmation. Fast, có thể mất message. \textit{Use:} Sensor readings không critical. \\
            \textbf{1} & At least once & Delivered ít nhất 1 lần, requires confirmation (ACK). Có thể duplicate. \textit{Use:} Important data. \\
            \textbf{2} & Exactly once & Four-step handshake. Chậm nhất nhưng không duplicate. \textit{Use:} Financial transactions, critical commands. \\
            \bottomrule
        \end{tabular}
    \end{center}
    \textit{Note:} Actual QoS = min(Publisher QoS, Subscriber QoS).

    \paragraph{Practical Application: Smart Farming}
    \begin{itemize}[leftmargin=*, label={--}]
        \item \textbf{Sensors (Publishers):}
        \begin{itemize}
            \item \textit{DHT11:} Temperature \& air humidity.
            \item \textit{BH1750:} Luminosity (độ sáng).
            \item \textit{DHT22:} Soil moisture (độ ẩm đất).
        \end{itemize}
        \item \textbf{Flow:} Sensors publish data đến broker với topics như \texttt{area1/moisture} $\rightarrow$ Management system subscribes topics $\rightarrow$ Real-time monitoring \& decision making.
        \item \textbf{Benefits:} Cost-effective, scalable, knowledge base creation cho farming management.
    \end{itemize}

    \columnbreak
    
    \subsubsection{MQTT vs HTTP Comparison}
    \begin{center}
        \renewcommand{\arraystretch}{1.2}
        \begin{tabular}{p{0.2\linewidth} | p{0.3\linewidth} | p{0.40\linewidth} @{}}
            \toprule
            \textbf{Aspect} & \textbf{HTTP} & \textbf{MQTT} \\
            \midrule
            \textbf{Model} & Request-Response\newline (Client-Server) & Publish-Subscribe\newline (qua Broker) \\
            \addlinespace[2pt]
            \textbf{Connection} & Short-lived\newline (đóng sau request) & Persistent\newline (Keep-alive, lightweight) \\
            \addlinespace[2pt]
            \textbf{Header Size} & Large (KB range)\newline Cồng kềnh metadata & Very small (2 bytes)\newline Tiết kiệm bandwidth \\
            \addlinespace[2pt]
            \textbf{Power} & High consumption & Low power\newline (tối ưu battery devices) \\
            \addlinespace[2pt]
            \textbf{Network} & Reliable networks & Unreliable networks\newline (chập chờn, high latency) \\
            \addlinespace[2pt]
            \textbf{Use Cases} & • Web browsing\newline • REST APIs\newline • Large file transfers & • IoT sensors\newline • M2M communication\newline • Constrained devices \\
            \bottomrule
        \end{tabular}
    \end{center}
    \textit{Key Insight:} HTTP designed cho human-to-machine (web), MQTT designed cho machine-to-machine (IoT).

    % --- PHẦN 5: PIPELINES & ORCHESTRATION ---
    \subsection{Pipelines \& Orchestration}
    
    \subsubsection{Apache Kafka vs Airflow}
    \begin{center}
        \renewcommand{\arraystretch}{1.2} % Adjust row height for readability
        \begin{tabular}{@{} >{\raggedright\arraybackslash}p{0.48\linewidth} >{\raggedright\arraybackslash}p{0.48\linewidth} @{}}
            \toprule
            \textbf{Apache Kafka} & \textbf{Apache Airflow} \\
            \midrule
            
            \textbf{Loại:} Event Streaming Platform (Message Broker). & 
            \textbf{Loại:} Workflow Orchestration (Quản lý quy trình). \\
            \addlinespace[4pt] % Extra space between sections
            
            \textbf{Đặc trưng:}
            \begin{itemize}[leftmargin=10pt, nosep, label=\tiny$\bullet$]
                \item Log bền vững (Durable log).
                \item Decoupling (Tách rời).
                \item Replayable, High throughput.
            \end{itemize} & 
            \textbf{Đặc trưng:}
            \begin{itemize}[leftmargin=10pt, nosep, label=\tiny$\bullet$]
                \item Code-as-infra (Python DAGs).
                \item Quản lý dependency phức tạp.
                \item Backfill (chạy lại quá khứ).
            \end{itemize} \\
            \addlinespace[4pt]
            
            \textbf{Vai trò:} "Xương sống" vận chuyển dữ liệu \textit{Real-time}. & 
            \textbf{Vai trò:} "Nhạc trưởng" điều phối Job (\textit{Batch/ETL}). \\
            \bottomrule
        \end{tabular}
    \end{center}

    \subsubsection{CDC (Change Data Capture)}
    \textit{Theo dõi và đồng bộ thay đổi từ database nguồn sang đích.}
    \begin{itemize}[leftmargin=*, label={--}]
        \item \textbf{Mục đích:} Real-time data replication, sync giữa OLTP và OLAP, event-driven architecture.
        \item \textbf{Cơ chế:}
        \begin{itemize}
            \item \textit{Log-based CDC:} Đọc database transaction log (binlog MySQL, WAL PostgreSQL). \textbf{Tốt nhất} - không ảnh hưởng source.
            \item \textit{Trigger-based:} Trigger trên INSERT/UPDATE/DELETE. Ảnh hưởng performance.
            \item \textit{Timestamp/Version-based:} Poll dựa trên \texttt{updated\_at} column. Thiếu DELETE events.
        \end{itemize}
        \item \textbf{Tools:} Debezium (Kafka Connect), AWS DMS, Oracle GoldenGate, Airbyte.
        \item \textbf{Use Case:} Sync OLTP $\to$ DW, Microservices data sharing, Cache invalidation, Audit logs.
        \item \textbf{Pattern:} Source DB $\to$ CDC Tool $\to$ Kafka $\to$ Sink (DW/Cache/Search).
    \end{itemize}

    \subsubsection{ETL vs ELT}
    \begin{itemize}[leftmargin=*, label={--}]
        \item \textbf{ETL (Extract-Transform-Load):} Transform \textit{trước} khi vào kho. Schema-on-write. Dữ liệu sạch, bảo mật. (Truyền thống).
        \item \textbf{ELT (Extract-Load-Transform):} Load raw vào kho \textit{trước}, transform sau. Schema-on-read. Tận dụng sức mạnh Cloud DW (BigQuery, Snowflake). (Hiện đại).
        \item \textbf{Bản chất chung:} Cả \textbf{ETL} và \textbf{ELT} đều là các quá trình hỗ trợ \textbf{tích hợp dữ liệu} (data integration): trích xuất dữ liệu từ nguồn, đưa vào đích (DW/Sink) và chuẩn hoá/chuẩn bị dữ liệu cho phân tích hoặc hệ thống downstream.
        \item \textbf{Ngữ cảnh sử dụng:}
            \begin{itemize}[leftmargin=*, label={--}]
                \item \textbf{ELT:} Hiệu quả với dữ liệu phức tạp hoặc khối lượng rất lớn (Big Data), khi kho dữ liệu/Cloud DW có khả năng xử lý transform ở quy mô (ví dụ: BigQuery, Snowflake).
                \item \textbf{ETL:} Phù hợp với các ngữ cảnh cơ sở dữ liệu truyền thống hoặc khi cần chuyển đổi, làm sạch kỹ lưỡng trước khi nạp vào kho (ví dụ do yêu cầu bảo mật, chuẩn hoá dữ liệu, hoặc tài nguyên xử lý hạn chế ở đích).
            \end{itemize}
        \item \textbf{Lưu ý:} Quan điểm đúng nhất thường là \textit{không} chọn tuyệt đối ETL hay ELT — cả hai đều có ưu, nhược điểm riêng và việc lựa chọn phụ thuộc vào ngữ cảnh ứng dụng cụ thể (yêu cầu hiệu năng, kích thước dữ liệu, khả năng xử lý của DW, chính sách bảo mật, v.v.).
    \end{itemize}

    \paragraph{Common ETL Logic Patterns}\mbox{}\\
    \textit{Các pattern phổ biến khi thiết kế ETL flow (cho luận văn/essay).}
    \begin{itemize}[leftmargin=*, label={--}]
        \item \textbf{Soft Deletes:} Nếu source có cờ \texttt{is\_deleted}, lọc bỏ trong Extract, hoặc load vào DW với \texttt{Status = 'Inactive'} trong dimension (không xóa row khỏi Fact table).
        \item \textbf{Date Derivation:} Luôn mở rộng cột \texttt{Date} đơn giản thành \textbf{Date Dimension} đầy đủ (Day, Week, Month, Quarter, Year, HolidayFlag).
        \item \textbf{Calculated Measures:} Tính toán như \texttt{Revenue = Price * Quantity} trong giai đoạn \textbf{Transform}, lưu vào Fact table để aggregation nhanh.
        \item \textbf{SCD for Price Changes:} Khi \texttt{Item\_price} thay đổi, dùng \textbf{Type 2 SCD} trong dimension hoặc snapshot fact table để lưu lịch sử giá.
    \end{itemize}

    \columnbreak

    % ============================================================================
    % TIER 5: ANALYTICS & WAREHOUSING
    % ============================================================================
    \subsection{Kho Dữ liệu (Data Warehousing)}

    \subsubsection{OLTP vs OLAP}
    \begin{center}
        \renewcommand{\arraystretch}{1.2}
        \begin{tabular}{@{} p{0.15\linewidth} | p{0.38\linewidth} | p{0.38\linewidth} @{}}
            \toprule
            & \textbf{OLTP (Transactional)} & \textbf{OLAP (Analytical)} \\
            \midrule
            \textbf{Mục tiêu} & Vận hành hàng ngày (Operational). & Ra quyết định (Decision support). \\
            \textbf{Dữ liệu} & Hiện hành, chi tiết, cập nhật liên tục. & Lịch sử, tổng hợp, đa chiều. \\
            \textbf{Truy vấn} & Đơn giản, trả về ít dòng (Lookup). & Phức tạp, join nhiều, quét bảng lớn. \\
            \textbf{Thiết kế} & Chuẩn hóa cao (3NF) để tránh dị thường. & Phi chuẩn hóa (Star/Snowflake) để đọc nhanh. \\
            \textbf{User} & NV, App, Khách hàng. & Manager, Data Analyst. \\
            \bottomrule
        \end{tabular}
    \end{center}

    \paragraph{OLAP Data Cube Operations}
    \textit{Thao tác trên khối dữ liệu đa chiều (Dimensions: Product, Time, Location, ...).}
    \begin{itemize}[leftmargin=*, label={--}]
        \item \textbf{Slice:} Cố định 1 dimension, xem ma trận 2D còn lại.
        \newline \textit{VD:} Slice Year=2024 $\rightarrow$ Xem doanh thu theo (City, Product) cho năm 2024.
        \item \textbf{Dice:} Chọn sub-cube với nhiều điều kiện trên nhiều dimensions.
        \newline \textit{VD:} Dice (Year $\in$ [2023,2024], City $\in$ [HCM, HN]) $\rightarrow$ Sub-cube 2x2.
        \item \textbf{Roll-up (Drill-up):} Tổng hợp lên mức cao hơn (chi tiết $\to$ tổng quát).
        \newline \textit{VD:} Roll-up từ City $\to$ Region $\to$ Country.
        \item \textbf{Drill-down:} Phân rã xuống mức chi tiết hơn (tổng quát $\to$ chi tiết).
        \newline \textit{VD:} Drill-down từ Year $\to$ Quarter $\to$ Month $\to$ Day.
        \item \textbf{Pivot (Rotate):} Xoay trục để thay đổi góc nhìn.
        \newline \textit{VD:} Đổi trục X từ Product sang Time.
    \end{itemize}

    \subsubsection{4 Đặc trưng Chính (Inmon)}
    \textit{Top-down, mục đích hỗ trợ ra quyết định cho quản lý}
    \begin{enumerate}[leftmargin=*, label={\textbf{\arabic*.}}]
        \item \textbf{Hướng chủ đề (Subject-oriented):} Tổ chức theo chủ đề chính (Khách hàng, Sản phẩm) thay vì theo ứng dụng (App Bán hàng, App Kho).
        \item \textbf{Tích hợp (Integrated):} Dữ liệu từ nhiều nguồn được làm sạch, đồng nhất (đơn vị, format, encoding) trước khi nạp.
        \item \textbf{Bất biến (Non-volatile):} Dữ liệu đã vào DW thì (thường) không bị sửa/xóa, chỉ đọc.
        \item \textbf{Biến thiên theo thời gian (Time-variant):} Mọi dữ liệu đều gắn với mốc thời gian để phân tích xu hướng (Historical data).
    \end{enumerate}

    \subsubsection{Thách thức Xây dựng DW}
    \begin{itemize}[leftmargin=*, label={--}]
        \item \textbf{Data Quality:} "Garbage In, Garbage Out". Dữ liệu nguồn bẩn làm sai lệch báo cáo.
        \item \textbf{ETL Complexity:} Tích hợp các hệ thống cũ (Legacy) rất phức tạp.
        \item \textbf{Performance:} Truy vấn phân tích tốn tài nguyên, cần tối ưu index/partition.
        \item \textbf{User Acceptance:} Người dùng không hiểu hoặc không tin tưởng dữ liệu.
        \item \textbf{Cost:} Chi phí lưu trữ và duy trì hạ tầng cao.
    \end{itemize}
    
    \subsubsection{Mô hình hóa (Modeling)}
    \begin{itemize}[leftmargin=*, label={--}]
        \item \textbf{Star Schema:} Fact ở giữa, Dimension xung quanh. Phi chuẩn hóa dimension. \textit{Hiệu năng cao, dễ query.}
        \item \textbf{Snowflake Schema:} Chuẩn hóa dimension (tách nhỏ). \textit{Tiết kiệm không gian, join phức tạp.}
    \end{itemize}

    \paragraph{Fact Table Additivity}\mbox{}\\
    \textit{Phân loại measures theo khả năng aggregation.}
    \begin{center}
    \scriptsize
    \renewcommand{\arraystretch}{1.2}
    \begin{tabular}{@{} p{0.12\linewidth} | p{0.24\linewidth} | p{0.24\linewidth} | p{0.24\linewidth} @{}}
        \toprule
        \textbf{Type} & \textbf{Definition} & \textbf{Example} & \textbf{Rule} \\
        \midrule
        \textbf{Additive} & SUM qua \textbf{tất cả} dimensions. & Sales\_Amount, Quantity & SUM over Time? Yes. \\
        \textbf{Semi-Add} & SUM qua \textbf{một số} dims, \textbf{trừ} Time. & Account\_Balance, Inventory & SUM over Time? \textbf{No}. \\
        \textbf{Non-Add} & \textbf{Không} thể SUM qua bất kỳ dim. & Unit\_Price, Margin\_Rate & Dùng AVG, MIN, MAX. \\
        \bottomrule
    \end{tabular}
    \end{center}

    \subsubsection{Kimball's 4-Step Dimensional Modeling}
    \textit{Phương pháp thiết kế DW theo Kimball (bottom-up, theo chủ đề nghiệp vụ).}
    \begin{enumerate}[leftmargin=*, label={\textbf{\arabic*.}}]
        \item \textbf{Select the Business Process:} Chọn quy trình nghiệp vụ cần phân tích.
        \newline \textit{VD:} Orders, Billing, Inventory, Shipments.
        \item \textbf{Declare the Grain:} Xác định mức chi tiết của mỗi row trong fact table.
        \newline \textit{VD:} One row per order line item, one row per transaction.
        \newline \textbf{Lưu ý:} Phải xác định grain \textbf{TRƯỚC} khi chọn dimensions/facts.
        \item \textbf{Identify the Dimensions:} Xác định các chiều phân tích (Who, What, Where, When).
        \newline \textit{VD:} dim\_customer, dim\_product, dim\_store, dim\_date.
        \item \textbf{Identify the Facts:} Xác định các measures/metrics (Số liệu đo lường).
        \newline \textit{VD:} quantity\_sold, revenue, discount\_amount, cost.
    \end{enumerate}

    \subsubsection{Schema Evolution Trade-offs}
    \textit{Khi yêu cầu thay đổi, có 2 chiến lược phổ biến để mở rộng schema DW.}
    \begin{itemize}[leftmargin=*, label={--}]
        \item \textbf{Strategy 1: Extend Star Schema (Add Columns to Dimension)}
        \begin{itemize}
            \item \textit{Pros:} Queries đơn giản hơn (không join mới), backward compatible.
            \item \textit{Cons:} Dimension table trở nên rất rộng (wide/fat dimension), tiềm ẩn redundancy và anomalies.
        \end{itemize}
        \item \textbf{Strategy 2: Convert to Snowflake (Normalize New Attributes)}
        \begin{itemize}
            \item \textit{Pros:} Tiết kiệm storage, cấu trúc rõ ràng hơn cho dữ liệu phân cấp (VD: Region $\to$ City).
            \item \textit{Cons:} Breaking Change - queries cũ cần sửa (thêm join mới), ETL phức tạp hơn (quản lý keys giữa các bảng normalized).
        \end{itemize}
    \end{itemize}

    \subsubsection{DW vs DL vs Lakehouse}
    \begin{itemize}[leftmargin=*, label={--}]
        \item \textbf{Data Warehouse:} Dữ liệu có cấu trúc, cho BI/Reporting.
        \item \textbf{Data Lake:} Dữ liệu thô (Raw), đa dạng, giá rẻ, cho ML/DS.
        \item \textbf{Lakehouse:} Kết hợp (Lưu trữ rẻ của Lake + Quản lý/ACID của Warehouse).
    \end{itemize}

    \subsubsection{SCD (Slowly Changing Dimensions)}
    \textit{Tại sao cần?} Để đảm bảo báo cáo lịch sử chính xác. Nếu KH chuyển từ HCM ra HN năm 2024, doanh số năm 2020 vẫn phải tính cho HCM.
    \begin{center}
        \renewcommand{\arraystretch}{1.2}
        \begin{tabular}{@{} c | p{0.32\linewidth} | p{0.5\linewidth} @{}}
            \toprule
            \textbf{Type} & \textbf{Chiến lược} & \textbf{Đặc điểm \& Use Case} \\
            \midrule
            \textbf{0} & \textbf{Retain Original:} Giữ nguyên, không bao giờ sửa. & 
            Dữ liệu gốc là chân lý. (VD: Ngày sinh). \\
            \hline
            \textbf{1} & \textbf{Overwrite:} Ghi đè giá trị mới lên cũ. & 
            Không cần lịch sử. Sửa lỗi chính tả. \\
            \hline
            \textbf{2} & \textbf{Add Row:} Add new row + \textit{Effective Date} + \textit{Current\_Flag}. & 
            \textbf{Most standard}. Track complete history of changes. \\
            \hline
            \textbf{3} & \textbf{Add Column:} Thêm cột \textit{Previous\_Value}. & 
            Chỉ cần biết giá trị liền trước. (Ít dùng). \\
            \hline
            \textbf{4} & \textbf{Add History Table:} Tách bảng lịch sử riêng (Mini-Dimension). & 
            Tối ưu khi bảng chính quá lớn và chỉ một nhóm thuộc tính thay đổi nhanh. \\
            \hline
            \textbf{5} & \textbf{Hybrid (4 + 1):} Mini-dimension + "Current" reference in main table. & 
            Optimize queries when need both detailed history and current value quickly. \\
            \hline
            \textbf{6} & \textbf{Hybrid (1 + 2 + 3):} Type 2 row + column containing current value (Type 1). & 
            \textit{"Pure Type 6"}: Helps query history while still easily group by current value. \\
            \hline
            \textbf{7} & \textbf{Hybrid (Dual Keys):} Fact table contains both \textit{Surrogate Key} (history) and \textit{Natural Key} (current). & 
            Most flexible: Join by Surrogate to view history, join by Natural to view current. \\
            \bottomrule
        \end{tabular}
            \textit{Các kỹ thuật xử lý dữ liệu thay đổi theo thời gian (0 $\to$ 7).}

    \end{center}

    \columnbreak

    % ============================================================================
    % TIER 6: DATA MANAGEMENT & OPERATIONAL
    % ============================================================================
    \subsection{Quản lý Dữ liệu}

    \subsubsection{Vấn đề Tích hợp (Data Integration Issues)}
    \begin{itemize}[leftmargin=*, label={--}]
        \item \textbf{Heterogeneous data sources:} Khác biệt về hệ quản trị cơ sở dữ liệu và định dạng tệp.
        \newline \textit{VD: MySQL, PostgreSQL, Oracle, MongoDB, CSV, JSON, XML, Parquet.}
        
        \item \textbf{Data Mapping:} Khác biệt về cấu trúc schema giữa các nguồn.
        \newline \textit{VD: Bảng `Employee' (Full\_Name, DOB) vs `Emp' (First\_Name, Last\_Name, Birth\_Date).}
        
        \item \textbf{Data Conflicts:} Conflicts in data type, value, format, unit, precision.
        \newline \textit{Type:} String vs Integer for employee code. \textit{Format:} DD/MM/YYYY vs MM/DD/YYYY. 
        \newline \textit{Unit:} USD vs VND, km vs miles. \textit{Precision:} 2 vs 4 decimal places.
        
        \item \textbf{Data Redundancy:} Dữ liệu trùng lặp từ nhiều nguồn cần khử trùng (Deduplication).
        \newline \textit{VD: Cùng khách hàng xuất hiện trong CRM và ERP với ID khác nhau.}
        
        \item \textbf{Entity Resolution:} Xác định 2 bản ghi từ 2 nguồn khác nhau là cùng 1 thực thể.
        \newline \textit{VD: `Nguyen Van A' (DB1) và `A Nguyen' (DB2), `IBM' vs `International Business Machines'.}
        \newline \textit{Kỹ thuật:} Fuzzy matching, similarity scores (Levenshtein distance), Master Data Management (MDM).
        
        \item \textbf{Constraints Violation:} Constraint violations during data integration.
        \newline \textit{Primary Key:} Duplicate primary keys during merge. \textit{Foreign Key:} References don't exist.
        \newline \textit{Semantic:} Invalid values (negative age, future dates).
        
        \item \textbf{Data Quality Issues:} Data quality problems during integration process.
        \newline \textit{Accuracy:} Deviates from reality. \textit{Completeness:} Missing required fields (NULL).
        \newline \textit{Uniqueness:} Duplicates. \textit{Timeliness:} Stale/outdated data. \textit{Consistency:} Conflicts between sources.
        
        \item \textbf{Communication Heterogeneity:} Khác biệt về giao diện và giao thức truyền thông.
        \newline \textit{VD: REST API vs SOAP, HTTP vs FTP, Batch files vs Real-time streams, GraphQL vs SQL.}
    \end{itemize}

    \subsubsection{Data Quality Dimensions}
    \textit{Các tiêu chí đánh giá chất lượng dữ liệu trong hệ thống thông tin.}
    
    \paragraph{6 Core Dimensions}
    \begin{enumerate}[leftmargin=*, label={\textbf{\arabic*.}}]
        \item \textbf{Accuracy (Chính xác):} Mức độ dữ liệu phản ánh đúng đối tượng/sự kiện thực tế.
        \newline \textit{Định nghĩa:} Sự không chính xác có nghĩa là hệ thống biểu diễn một trạng thái thế giới thực khác với trạng thái đáng lẽ phải được biểu diễn.
        \newline \textit{VD:} Địa chỉ sai, số điện thoại cũ, thông tin lỗi thời.
        
        \item \textbf{Completeness (Đầy đủ):} Tỷ lệ dữ liệu được lưu trữ so với khả năng 100\% hoàn chỉnh.
        \newline \textit{Định nghĩa:} Khả năng của hệ thống biểu diễn mọi trạng thái có nghĩa của hệ thống thế giới thực.
        \newline \textit{VD:} NULL values, missing fields, incomplete records (missing email, phone number).
        
        \item \textbf{Consistency (Nhất quán):} Sự vắng mặt của sự khác biệt khi so sánh hai hoặc nhiều biểu diễn của cùng một thứ.
        \newline \textit{Định nghĩa:} Sự không nhất quán có nghĩa là ánh xạ biểu diễn là một-nhiều (one-to-many).
        \newline \textit{VD:} Tổng doanh thu trong bảng Orders $\neq$ tổng trong Report, tên KH khác nhau giữa CRM và ERP.
        
        \item \textbf{Validity (Hợp lệ):} Dữ liệu hợp lệ nếu tuân thủ cú pháp của định nghĩa (format, type, range).
        \newline \textit{VD:} Email correct format (has @), age in range [0, 150], enum has allowed values.
        
        \item \textbf{Timeliness (Kịp thời):} Mức độ dữ liệu phản ánh thực tế từ mốc thời gian yêu cầu.
        \newline \textit{Định nghĩa:} Độ trễ giữa thay đổi trạng thái thế giới thực và sửa đổi tương ứng trong hệ thống.
        \newline \textit{VD:} Giá cổ phiếu cập nhật delay 10s, báo cáo tồn kho cách 1 ngày (stale data).
        
        \item \textbf{Uniqueness (Duy nhất):} Không có thứ nào được ghi lại nhiều hơn một lần dựa trên cách xác định thứ đó.
        \newline \textit{VD:} Không có duplicate records, một khách hàng chỉ có một ID duy nhất.
    \end{enumerate}

    \subsubsection{Quản lý Thông tin}
    \textit{Quản lý dữ liệu như một tài sản chiến lược của doanh nghiệp.}
    
    \paragraph{6 Khía cạnh Quản lý Thông tin}
    \begin{enumerate}[leftmargin=*, label={\textbf{\arabic*.}}]
        \item \textbf{Information Collection (Thu thập):} Xác định và thu thập dữ liệu từ các nguồn khác nhau.
        \newline \textit{Hoạt động:} Data ingestion, ETL pipelines, API integration, web scraping, sensors/IoT.
        \newline \textit{VD:} Crawl web data, stream from Kafka, batch import from CSV, CDC from transactional DB.
        
        \item \textbf{Information Organization (Tổ chức):} Cấu trúc hóa và phân loại dữ liệu để dễ quản lý và truy xuất.
        \newline \textit{Hoạt động:} Schema design, data modeling (Star/Snowflake), taxonomy, metadata management.
        \newline \textit{VD:} Design DW dimensions/facts, create data catalog, tag data by domain.
        
        \item \textbf{Information Storage (Lưu trữ):} Chọn và triển khai hệ thống lưu trữ phù hợp với đặc điểm dữ liệu.
        \newline \textit{Hoạt động:} Choose DBMS (RDBMS, NoSQL, DW), partitioning, replication, backup strategy.
        \newline \textit{VD:} OLTP on PostgreSQL, OLAP on Snowflake, unstructured data on S3/Data Lake.
        
        \item \textbf{Information Manipulation (Thao tác):} Thực hiện các thao tác CRUD và chuyển đổi dữ liệu.
        \newline \textit{Hoạt động:} INSERT/UPDATE/DELETE, data transformation, cleansing, enrichment, aggregation.
        \newline \textit{VD:} Chuẩn hóa địa chỉ, deduplicate records, merge datasets, derive calculated fields.
        
        \item \textbf{Information Processing (Xử lý):} Phân tích và tính toán để tạo insights từ dữ liệu thô.
        \newline \textit{Hoạt động:} Query execution, analytics, ML training, reporting, dashboarding, data mining.
        \newline \textit{VD:} SQL queries, Spark jobs, BI reports, predictive models, real-time analytics.
        
        \item \textbf{Information Protection (Bảo vệ):} Đảm bảo an toàn, riêng tư và tuân thủ quy định.
        \newline \textit{Hoạt động:} Access control (RBAC), encryption (at-rest/in-transit), audit logging, compliance (GDPR).
        \newline \textit{VD:} Mã hóa PII, masking sensitive data, role-based permissions, backup/disaster recovery.
    \end{enumerate}
    
    \textit{Tổng thể:} Information Management bao gồm Data Governance (quản trị), Data Quality, Master Data Management (MDM), Security, và Lifecycle Management. Mục tiêu cuối cùng là đảm bảo dữ liệu \textbf{tin cậy, an toàn, dễ truy cập} để tạo giá trị kinh doanh.

    \subsection{Distributed Systems Challenges}
    \textit{Khác với hệ thống đơn, hệ phân tán đối mặt với \textbf{partial failures} - một số phần hỏng trong khi phần khác hoạt động.}
    
    \subsubsection{8 Fallacies (Ngụy biện) của Distributed Computing}
    \textit{Những giả định sai lầm mà lập trình viên thường mắc phải (L. Peter Deutsch, Sun Microsystems).}
    \begin{enumerate}[leftmargin=*, label={\textbf{\arabic*.}}]
        \item \textbf{The Network is Reliable:} Mạng không đáng tin cậy - switches hỏng, cables ngắt, packets bị mất/reorder.
        \item \textbf{Latency is Zero:} Local call (ns/$\mu$s) $\neq$ Remote call (ms). Chain calls $\rightarrow$ latency tích lũy.
        \item \textbf{Bandwidth is Infinite:} Băng thông hữu hạn. Stamp coupling (truyền dữ liệu thừa) gây bottleneck.
        \item \textbf{The Network is Secure:} Attack surface tăng. Mọi endpoint phải được bảo mật.
        \item \textbf{Topology Never Changes:} Topology thay đổi liên tục (upgrades, failures, scaling) $\rightarrow$ timeout/failures.
        \item \textbf{Only One Administrator:} Nhiều admin quản lý các segment khác nhau (firewall, DB) $\rightarrow$ khó phối hợp.
        \item \textbf{Transport Cost is Zero:} Serialization, marshalling, network infra đều tốn chi phí.
        \item \textbf{Network is Homogeneous:} Mạng gồm nhiều vendor (routers, switches) $\rightarrow$ packet loss, anomalies.
    \end{enumerate}
    
    \subsubsection{Tính không đáng tin cậy: Mạng \& Thời gian}
    \begin{itemize}[leftmargin=*, label={--}]
        \item \textbf{Mạng không đáng tin cậy:}
        \begin{itemize}
            \item \textit{Timeouts:} Không có thời gian cố định cho các thao tác mạng $\rightarrow$ phải sử dụng timeout. Nếu chọn quá ngắn: báo false positive (nhầm là node chết). Nếu quá dài: phát hiện lỗi chậm.
            \item \textit{Network Partition (Netsplit):} Một nhóm node bị cô lập $\rightarrow$ "Split brain" (hai leader cùng chấp nhận các ghi xung đột).
        \end{itemize}
        \item \textbf{Thời gian không đáng tin cậy:} "Time is an illusion" -- không tồn tại đồng hồ toàn cục.
        \begin{itemize}
            \item \textit{Clock Drift:} Đồng hồ thạch anh (quartz) bị trôi do thay đổi nhiệt độ; ngay cả đồng bộ bằng NTP cũng có thể có sai lệch.
            \item \textit{Process Pauses:} GC hoặc tạm dừng VM $\rightarrow$ node bị pause lâu hơn lease timeout $\rightarrow$ bị khai tử nhưng vẫn nghĩ mình còn sống $\rightarrow$ có thể gây hỏng dữ liệu.
            \item \textit{Ordering Issues:} Dùng timestamp cho Last-Write-Wins (LWW) nguy hiểm -- đồng hồ không đồng bộ $\rightarrow$ ghi mới có thể bị ghi đè bởi giá trị cũ.
        \end{itemize}
    \end{itemize}
    
    \subsubsection{Consistency \& Consensus Challenges}
    \begin{itemize}[leftmargin=*, label={--}]
        \item \textbf{CAP Theorem:} Can only achieve 2/3: \textbf{C}onsistency, \textbf{A}vailability, \textbf{P}artition Tolerance. Partitions unavoidable $\rightarrow$ choose CP or AP.
        \newline $\rightarrow$ \textit{NoSQL thường chọn AP (Sẵn sàng + Chịu lỗi) thay vì CP.}
        \item \textbf{FLP Impossibility:} Async system cannot guarantee consensus termination if 1 node crashes $\rightarrow$ must use timeout.
        \item \textbf{Two Generals' Problem:} Không thể đạt common knowledge (chắc chắn đồng ý) qua kênh unreliable - ACK cuối cùng có thể bị mất.
        \item \textbf{BASE:} \textbf{B}asically \textbf{A}vailable, \textbf{S}oft state, \textbf{E}ventual consistency (Nhất quán cuối cùng - chấp nhận dữ liệu cũ tạm thời).
    \end{itemize}
    
    \subsubsection{Failure Models}
    \begin{itemize}[leftmargin=*, label={--}]
        \item \textbf{Crash Faults:} Process stops completely, never returns (simplest).
        \item \textbf{Omission Faults:} Process skips steps or doesn't send/receive messages (buffer overflow, congestion).
        \item \textbf{Byzantine Faults:} Process behaves arbitrarily/maliciously, sends wrong messages (hardest, blockchain).
    \end{itemize}
    
    \subsubsection{Managing "Truth" in Distributed Systems}
    \begin{itemize}[leftmargin=*, label={--}]
        \item \textbf{Truth by Majority:} Không node nào tin được view của chính mình. \textit{Sự thật = Quorum quyết định.}
        \newline \textit{VD:} Node tưởng mình là leader, nhưng quorum khai tử (do GC pause) $\rightarrow$ node đó "đã chết".
        \item \textbf{Fencing Tokens:} Monotonic number for storage to reject writes from nodes holding expired locks (zombie nodes).
    \end{itemize}
    
    \subsubsection{Thách thức Xử lý Dữ liệu Phân tán}
    \begin{itemize}[leftmargin=*, label={--}]
        \item \textbf{Data Skew (Lệch dữ liệu):} One partition contains too much data.
        \newline $\rightarrow$ \textit{Consequence:} Straggler problem - job waits for slowest node.
        \newline $\rightarrow$ \textit{Solution:} Salting (add random prefix) to split hot key.
        \item \textbf{Shuffle:} Transfer data between nodes over network (Map $\to$ Reduce).
        \newline $\rightarrow$ \textit{Optimization:} Broadcast Join (copy small table to all nodes) to avoid shuffling large table.
    \end{itemize}

    \section{Appendix: Tự luận}
    \subsection{Thiết kế Kho Dữ Liệu (Star Schema)}
    \begin{itemize}[leftmargin=*, label={--}]
        \item \textbf{Ví dụ chi tiết (Câu 35 -- HK2 2022-2023 F1.1):}
        \begin{itemize}[leftmargin=*, label={--}]
            \item \textbf{Nguồn (OLTP):}\\
            \texttt{ORDER(order\_id, date, customer\_name, customer\_address, customer\_phone, store\_name, store\_address, store\_district, store\_city, staff\_id, staff\_name, is\_deleted)},\\
            \texttt{ORDER\_LINE(order\_id, SKU, item\_price, item\_quantity, promotion\_id, promotion\_name, promotion\_type, promotion\_value)},\\
            \texttt{PRODUCT(SKU, item\_description, item\_category, item\_class, item\_brand, item\_cost)}.
            \item \textbf{Yêu cầu:} Báo cáo \textbf{Total Revenue, Total Quantity, Total Cost} theo Date (day/week/month/year) và các chiều: Customer, Store, Staff, Product, Promotion.
        \end{itemize}

        \item \textbf{Giải chi tiết (Kimball 4 bước):}
        \begin{enumerate}[leftmargin=*, label={\textbf{\arabic*.}}]
            \item \textbf{Business Process:} Sales.
            \item \textbf{Declare the Grain:} One row per \texttt{ORDER\_LINE} (mức sản phẩm trong đơn) -- cần vì đo lường theo SKU.
            \item \textbf{Identify Dimensions:}
            \begin{itemize}
                \item \textbf{Dim\_Date:} date\_key, date, day, week, month, year.
                \item \textbf{Dim\_Customer:} customer\_key, customer\_name, customer\_address, customer\_phone.
                \item \textbf{Dim\_Store:} store\_key, store\_name, store\_address, store\_district, store\_city.
                \item \textbf{Dim\_Staff:} staff\_key, staff\_id, staff\_name.
                \item \textbf{Dim\_Product:} item\_key, SKU, item\_description, item\_category, item\_class, item\_brand, item\_cost.
                \item \textbf{Dim\_Promotion:} promotion\_key, promotion\_id, promotion\_name, promotion\_type, promotion\_value.
            \end{itemize}
            \item \textbf{Identify Facts:} \textbf{FACT\_SALES} với FKs (date\_key, customer\_key, store\_key, staff\_key, item\_key, promotion\_key) và measures:
            \begin{itemize}
                \item total\_quantity = item\_quantity
                \item total\_revenue = item\_price * item\_quantity
                \item total\_cost = item\_cost * item\_quantity
            \end{itemize}
        \end{enumerate}

        \item \textbf{Kết quả (mô tả cấu trúc):}
        \begin{itemize}[leftmargin=*, label={--}]
            \item \textbf{FACT\_SALES:}
            \begin{center}
                \scriptsize
                \renewcommand{\arraystretch}{1.05}
                \begin{tabular}{@{} l | l | p{0.48\linewidth} @{}}
                    \toprule
                    \textbf{Cột} & \textbf{Loại} & \textbf{Mô tả} \\
                    \midrule
                    date\_key & FK & Liên kết đến \texttt{Dim\_Date} \\
                    store\_key & FK & Liên kết đến \texttt{Dim\_Store} \\
                    staff\_key & FK & Liên kết đến \texttt{Dim\_Staff} \\
                    customer\_key & FK & Liên kết đến \texttt{Dim\_Customer} \\
                    promotion\_key & FK & Liên kết đến \texttt{Dim\_Promotion} \\
                    item\_key & FK & Liên kết đến \texttt{Dim\_Product} \\
                    total\_quantity & Measure & Tổng số lượng bán (SUM) \\
                    total\_revenue & Measure & Tổng doanh thu (SUM of item\_price * qty) \\
                    total\_cost & Measure & Tổng chi phí (SUM of item\_cost * qty) \\
                    \bottomrule
                \end{tabular}
            \end{center}
        \end{itemize}

        \item \textbf{ETL Note:}
        \begin{itemize}
            \item Lọc \texttt{ORDER.is\_deleted = false} khi extract để loại đơn bị hủy.
            \item Tạo \texttt{Surrogate Keys} (e.g., \texttt{customer\_key}) thay vì dùng PK nguồn để quản lý lịch sử và xử lý duplicate.
            \item Lấy \texttt{item\_cost} từ \texttt{PRODUCT} để tính \texttt{total\_cost = item\_cost * item\_quantity} trên bước transform/load.
        \end{itemize}

        \item \textbf{Note:} Trong bài thi, trình bày theo (1) chọn process => (2) khai báo grain (nhấn mạnh "one row per ORDER\_LINE") => (3) liệt kê dimensions + attributes => (4) nêu measures và công thức tính => (5) lưu ý filter \texttt{is\_deleted}.
    \end{itemize}

    \subsection{Kiến trúc \& Công nghệ}
    \includegraphics[width=1\linewidth, keepaspectratio]{./images/3_tier_arch_dwh.png}
    \footnotesize \textit{Minh họa kiến trúc 3-Tier cho Data Warehouse.}
    \begin{itemize}[leftmargin=*, label={--}]
        \item \textbf{Mẫu giải: Thiết kế Hệ thống DWH cho Sales}
        \begin{itemize}[leftmargin=*, label={--}]
            \item \textbf{Kiến trúc (3-Tier):}
            \begin{itemize}
                \item \textbf{Source Layer:} Hệ thống OLTP (MySQL/Postgres) chứa \texttt{ORDER, ORDER\_LINE, PRODUCT}.
                \item \textbf{Staging Area:} Lưu trữ dữ liệu thô (Parquet trên HDFS/S3) để làm sạch và chuyển đổi.
                \item \textbf{Data Warehouse Layer:} Apache Hive (HDFS) hoặc BigQuery chứa các bảng Dim/Fact theo Star Schema.
                \item \textbf{Serving / Data Mart (tùy chọn):} Views / Materialized Views để phục vụ BI (PowerBI/Tableau).
            \end{itemize}


            \item \textbf{Công nghệ đề xuất:}
            \begin{center}
                \renewcommand{\arraystretch}{1.05}
                \begin{tabular}{@{} p{0.22\linewidth} | p{0.26\linewidth} | p{0.44\linewidth} @{}}
                    \toprule
                    \textbf{Thành phần} & \textbf{Công nghệ} & \textbf{Lý do / Ghi chú} \\
                    \midrule
                    Source & MySQL / PostgreSQL & RDBMS OLTP phổ biến, ACID đảm bảo tính nhất quán. \\
                    ETL/ELT & Apache Spark/Kafka & Xử lý Batch \& Streaming, in-memory, dễ scale. \\
                    Orchestration & Apache Airflow & Lên lịch, quản lý workflow, retry, monitoring. \\
                    Storage (DWH) & Apache Hive (HDFS) / BigQuery & Hive phù hợp on-prem/Hadoop; BigQuery phù hợp cloud/serverless. \\
                    Presentation & PowerBI / Tableau & Kết nối trực tiếp tới DWH cho dashboard báo cáo. \\
                    \bottomrule
                \end{tabular}
            \end{center}

            \item \textbf{Quy trình tích hợp dữ liệu (ETL/ELT):}
            \begin{enumerate}[leftmargin=*, label={\textbf{\arabic*.}}]
                \item \textbf{Extract:}
                \begin{itemize}
                    \item Tần suất: Daily (Incremental), ví dụ: trích xuất các \texttt{ORDER} của ngày hôm qua.
                    \item Chỉ lấy \texttt{ORDER.is\_deleted = false} để không tính các đơn hủy.
                    \item Công cụ: Spark đọc từ MySQL/Postgres và ghi Parquet tới Staging (HDFS/S3).
                \end{itemize}

                \item \textbf{Transform:}
                \begin{itemize}
                    \item Làm sạch: Chuẩn hoá ngày, loại bỏ NULL/invalid, validate dữ liệu.
                    \item Tính toán measures: \texttt{revenue = item\_price * item\_quantity}, \texttt{cost = item\_cost * item\_quantity}.
                    \item Tra cứu \& ánh xạ Surrogate Keys: map \texttt{customer\_id} -> \texttt{customer\_key} v.v.
                    \item Xử lý SCD (Type 1/Type 2) cho dimension khi cần.
                \end{itemize}

                \item \textbf{Load:}
                \begin{itemize}
                    \item Ghi Fact/Dimensions vào Hive (hoặc load vào BigQuery) theo Star Schema.
                    \item Chiến lược nạp: Fact incremental, Dimension upsert / SCD policy.
                    \item Toàn bộ workflow được điều phối bởi Airflow (schedule, dependencies, retries).
                \end{itemize}
            \end{enumerate}

            \item \textbf{Mô tả tóm tắt (dùng để trả lời câu tự luận / vẽ hình):}
            \begin{quote}
                Hệ thống sử dụng kiến trúc \textbf{3-Tier}. Dữ liệu bán hàng từ MySQL được trích xuất hàng ngày bằng Apache Spark, lưu tạm tại HDFS (Staging) dưới dạng Parquet. Spark thực hiện làm sạch, tính toán doanh thu/chi phí và ánh xạ Surrogate Keys, sau đó nạp vào Apache Hive (Data Warehouse) theo Star Schema. Toàn bộ quy trình được điều phối bởi Apache Airflow và dashboard được hiển thị qua PowerBI/Tableau.
            \end{quote}

            \item \textbf{Ghi chú:}
            \begin{itemize}
                \item Nêu rõ tần suất (daily), policy lọc (is\_deleted), SCD policy, và nơi lưu Staging (HDFS/S3).
                \item Nếu đề cho phép Cloud, thay Hive bằng BigQuery và nhấn mạnh ưu điểm serverless/fast queries.
            \end{itemize}
        \end{itemize}
    \end{itemize}

    \subsection{Lý thuyết Big Data}
    \begin{itemize}[leftmargin=*, label={--}]
        \item \textbf{CAP vs ACID:}
            \begin{itemize}[leftmargin=*, label={--}]
                \item \textbf{CAP:}
                \begin{enumerate}[leftmargin=*, label={\textbf{\arabic*.}}]
                    \item \textbf{C — Consistency:} Replica consistency — tất cả bản sao nhìn thấy cùng dữ liệu tại cùng mốc.
                    \item \textbf{A — Availability:} Mọi nút đang hoạt động trả lời yêu cầu (không im lặng).
                    \item \textbf{P — Partition Tolerance:} Hệ thống tiếp tục hoạt động dù network partition.
                \end{enumerate}

                \item \textbf{Khác biệt chính so với ACID:}
                \begin{itemize}[leftmargin=*, label={--}]
                    \item \textbf{Phạm vi:} CAP = hệ thống phân tán; ACID = giao tác (transaction).
                    \item \textbf{Ý nghĩa của "C":} CAP-C = Replica consistency; ACID-C = Logical integrity/constraints.
                    \item \textbf{NOTE:} Viết 3 định nghĩa C/A/P, nêu scope và khác biệt của "C"; ví dụ: Cassandra/Dynamo (CAP trade-offs), Postgres/MySQL (ACID).
                \end{itemize}
            \end{itemize}
    \end{itemize}


    \section{Appendix: Trắc Nghiệm}

    \subsection{Thiết kế CSDL (ERD \& Normalization)}
    \begin{description}[leftmargin=*, font=\bfseries\color{red!70!black}, itemsep=4pt]
        \item[Q: Đặc tính BẮT BUỘC khi phân rã lược đồ?] $\rightarrow$ \textbf{Bảo toàn thông tin (Lossless Join).}
        \newline \textit{Bẫy:} "Bảo toàn phụ thuộc" chỉ là \textit{mong muốn}, không bắt buộc.
        
        \item[Q: Fan Trap xảy ra khi nào?] $\rightarrow$ Một thực thể liên kết 1:N với 2 thực thể khác tạo ra đường dẫn mơ hồ.
        \newline \textit{VD:} NhanVien $(N) \leftarrow (1)$ PhongBan $(1) \to (N)$ DuAn. Không biết NV nào làm DA nào.
        \newline \textit{Bẫy:} Nhầm với \textbf{Chasm Trap} (thiếu đường dẫn do partial participation).
        
        \item[Q: Dimension trong Star Schema có chuẩn hóa không?] $\rightarrow$ \textbf{KHÔNG.} Dimension thường denormalized để giảm JOIN.
        \newline \textit{Bẫy:} Nếu Dimension được chuẩn hóa $\to$ đó là \textbf{Snowflake Schema}.
        
        \item[Q: Chọn DBMS ở giai đoạn nào?] $\rightarrow$ \textbf{Trước/Bắt đầu Thiết kế Logic} (vì logic design phụ thuộc mô hình DBMS).
        
        \item[Q: Lược đồ ý niệm (Conceptual Schema) đặc điểm?] $\rightarrow$ \textbf{Độc lập công nghệ}, dễ đọc hiểu, dùng cho cả SQL và NoSQL.
        \newline \textit{Bẫy:} "Khó đọc, cần tài liệu mô tả" là SAI.
        
        \item[Q: Category (Union) khác Specialization/Generalization?] $\rightarrow$ Category \textbf{KHÔNG kế thừa tất cả} thuộc tính từ các superclass. Chỉ \textbf{đại diện} cho một trong các superclass.
        \newline \textit{VD:} Person UNION Company $\to$ Owner (chỉ là Person HOẶC Company, không phải cả hai).
        
        \item[Q: Ánh xạ (E)ERD sang Relational đảm bảo gì?] $\rightarrow$ Đảm bảo: \textbf{Primary Key, Foreign Key, Participation, Cardinality}.
        \newline \textit{Lưu ý:} Tất cả ràng buộc từ ERD được chuyển sang SQL constraints.
        
        \item[Q: Weak Entity được ánh xạ thế nào?] $\rightarrow$ Tạo bảng riêng với \textbf{composite PK = (Owner FK + Partial Key)}.
        \newline \textit{Bẫy:} Nghĩ weak entity không cần bảng riêng.
        
        \item[Q: Kiểu thực thể Shared Subclass?] $\rightarrow$ Kế thừa \textbf{TẤT CẢ} thuộc tính và mối liên kết từ \textbf{NHIỀU} superclass.
        \newline \textit{VD:} Student\_Employee kế thừa từ cả Student VÀ Employee.

        \item[Q: Lỗi kỳ dị dữ liệu (Anomaly) gồm?] $\rightarrow$ \textbf{Insertion, Update, Deletion Anomaly}.
        \newline \textit{VD:} Không thể thêm Department mới nếu chưa có Employee (Insertion).
        
        \item[Q: Tìm Candidate Key?] $\rightarrow$ Tập thuộc tính nhỏ nhất xác định tất cả thuộc tính khác (không thể bỏ bớt).
        \newline \textit{Công thức:} Tính closure $X^+$, nếu $X^+ = $ All Attributes $\to$ X là superkey.
    \end{description}

    \subsection{Chỉ mục (Indexing \& Physical Design)}
    \begin{description}[leftmargin=*, font=\bfseries\color{red!70!black}, itemsep=4pt]
        \item[Q: Số lượng Index Entries của Clustering Index?] $\rightarrow$ Bằng số \textbf{Distinct Values} của trường đánh index.
        \newline \textit{Bẫy:} Nhầm thành "Số Records" (Secondary) hoặc "Số Blocks" (Primary).
        
        \item[Q: Root của B-Tree chiếm bao nhiêu block?] $\rightarrow$ Chính xác \textbf{1 Disk Block}.
        \newline \textit{Bẫy:} Khi root đầy $\to$ split và tăng height, nhưng root mới vẫn chỉ 1 block.
        
        \item[Q: Tại sao B+-Tree tốt cho Range Query?] $\rightarrow$ Vì leaf nodes được liên kết (Linked List). Chỉ cần tìm điểm đầu và quét ngang.
        \newline \textit{Bẫy:} Chọn "Vì chiều cao thấp hơn". Đúng nhưng không phải lý do chính.
        
        \item[Q: \texttt{IS NOT NULL} có dùng Index không?] $\rightarrow$ Thường \textbf{KHÔNG}. B-Tree tiêu chuẩn không index NULL $\to$ Full Table Scan.

        \item[Q: Chi phí truy cập B+-Tree: 3 hay 4 blocks? (Height=3)] $\rightarrow$ \textbf{4 Blocks} (Nếu Unclustered).
        \newline \textit{TH 3 blocks:} \textbf{Clustered Index} (Data nằm ngay tại Leaf).
        \newline \textit{TH 4 blocks:} \textbf{Unclustered/Secondary Index} (Leaf chứa Pointer $\to$ tốn thêm 1 I/O để đọc Data Block).
        \newline \textit{Mẹo:} Nếu đề không nói rõ, thường giả định là \textbf{Secondary Index} (Unclustered) $\to$ chọn \textbf{4}.
        
        \item[Q: Primary Index số entry?] $\rightarrow$ Bằng \textbf{số blocks} của data file (1 entry/block đầu tiên).
        \newline \textit{Công thức:} $\lceil \frac{\text{Số Records}}{\text{bfr (blocking factor)}} \rceil$.
        
        \item[Q: Secondary Index trên Key Field là Dense hay Sparse?] $\rightarrow$ Luôn \textbf{DENSE} (mỗi record 1 entry).
        \newline \textit{Bẫy:} "Có thể sparse" là SAI. Secondary trên key phải dense.
        
        \item[Q: Multilevel Index dùng cho loại nào?] $\rightarrow$ Có thể dùng cho \textbf{TẤT CẢ} (Primary, Clustering, Secondary).
        \newline \textit{Mục đích:} Giảm số block accesses khi index quá lớn.
        
        \item[Q: Hash Index tốt cho query nào?] $\rightarrow$ \textbf{Equality (=)} tuyệt vời. \textbf{Range (<, >, BETWEEN)} tệ (phải full scan).
        \newline \textit{Khi nào dùng:} WHERE code = 10 $\to$ Hash. WHERE code > 10 $\to$ B+-Tree.
        
        \item[Q: Bitmap Index tốt khi nào?] $\rightarrow$ Trường có \textbf{cardinality thấp} (ít giá trị distinct).
        \newline \textit{VD:} Gender (M/F), Status (Active/Inactive). \textit{Tệ cho:} SSN, Email.
        
        \item[Q: Index trên \texttt{lower(Name)}?] $\rightarrow$ Tạo \textbf{Function-Based Index}: \texttt{CREATE INDEX idx ON T(lower(Name))}.
        \newline \textit{Lưu ý:} Index thường \texttt{(Name)} không dùng được cho \texttt{WHERE lower(Name)=...}.
        
        \item[Q: Composite Index (A, B) hỗ trợ query nào?] $\rightarrow$ \textbf{WHERE A=... [AND B=...]} OK. \textbf{WHERE B=...} KHÔNG dùng được.
        \newline \textit{Nguyên tắc:} Phải có điều kiện trên \textbf{cột đầu tiên} mới dùng được index.
        
        \item[Q: Unspanned vs Spanned storage?] $\rightarrow$ \textbf{Unspanned:} 1 record không nằm trên >1 block (dễ quản lý, lãng phí không gian).
        \newline \textbf{Spanned:} Record có thể nằm trên nhiều block (tiết kiệm không gian, phức tạp hơn).
        
        \item[Q: Thiết kế Physical cần chú ý gì?] $\rightarrow$ Kiểu dữ liệu, kích thước, ràng buộc, index, partitioning.
        \newline \textit{Bẫy:} "Dùng String cho Date" $\to$ SAI (nên dùng DATE type để validate).
    \end{description}

    \subsection{Big Data \& Data Warehousing}
    \begin{description}[leftmargin=*, font=\bfseries\color{red!70!black}, itemsep=4pt]
        \item[Q: "C" trong CAP vs "C" trong ACID khác nhau thế nào?] $\rightarrow$ \textbf{CAP-C:} Consistency of Replicas (mọi node cùng nhìn thấy dữ liệu).
        \newline $\rightarrow$ \textbf{ACID-C:} Data thỏa ràng buộc toàn vẹn (Constraints).
        \newline \textit{Bẫy:} Đánh đồng hai chữ "Consistency".
        
        \item[Q: MapReduce lưu dữ liệu trung gian ở đâu?] $\rightarrow$ Ghi xuống \textbf{Đĩa cứng (Disk)} của local node.
        \newline \textit{Bẫy:} Nhầm với \textbf{Spark}, Spark cache trên \textbf{RAM} (nhanh hơn).
        
        \item[Q: Thứ tự đúng của Kimball 4-Step?] $\rightarrow$ (1) Business Process $\to$ (2) \textbf{Grain} $\to$ (3) Dimensions $\to$ (4) Facts.
        \newline \textit{Bẫy:} Xác định Dimensions/Facts trước \textbf{Grain} $\to$ toàn bộ thiết kế sai.
        
        \item[Q: Fact Table chứa gì?] $\rightarrow$ FK trỏ Dimensions + \textbf{Measures (số đo)}.
        \newline \textit{Bẫy:} Nghĩ Fact chứa thông tin mô tả. Fact thường toàn số và ID.
        
        \item[Q: Mục đích Data Warehouse theo Inmon?] $\rightarrow$ \textbf{Hỗ trợ ra quyết định} (Decision Support).
        \newline \textit{4 đặc điểm:} Subject-oriented, Integrated, Time-variant, Non-volatile.
        
        \item[Q: Subject-oriented nghĩa là gì?] $\rightarrow$ Dữ liệu xoay quanh \textbf{chủ đề nghiệp vụ} (khách hàng, sản phẩm, doanh thu) chứ không phải giao dịch.
        
        \item[Q: ETL vs ELT khác nhau?] $\rightarrow$ \textbf{ETL:} Transform trước khi Load (truyền thống, data nhỏ/vừa).
        \newline \textbf{ELT:} Load rồi Transform tại đích (Big Data, cloud, dữ liệu phức tạp).
        
        \item[Q: Star Schema vs Snowflake Schema?] $\rightarrow$ \textbf{Star:} Dimension denormalized (ít JOIN, dễ query).
        \newline \textbf{Snowflake:} Dimension normalized (ít redundancy, nhiều JOIN).
        \newline \textit{Lưu ý:} \textbf{Fact table LUÔN normalized} trong cả hai.
        
        \item[Q: Fact vs Dimension relationship?] $\rightarrow$ \textbf{One-to-Many} (1 Dimension $\to$ N Facts).
        \newline \textit{VD:} 1 Product có thể bán nhiều lần (nhiều dòng trong Fact).
        
        \item[Q: Additive, Semi-Additive, Non-Additive Measure?] $\rightarrow$ \textbf{Additive:} Cộng được trên mọi dimension (Revenue, Quantity).
        \newline \textbf{Semi-Additive:} Cộng được trên 1 số dimension (Balance - không cộng theo time).
        \newline \textbf{Non-Additive:} Không cộng được (Ratio, Average, Price).
        
        \item[Q: Grain (độ mịn dữ liệu) là gì?] $\rightarrow$ \textbf{Mức chi tiết thấp nhất} của 1 dòng trong Fact.
        \newline \textit{VD:} Grain = "Mỗi dòng là 1 giao dịch bán hàng của 1 khách tại 1 thời điểm".
        
        \item[Q: Hierarchy trong Dimension?] $\rightarrow$ Cấu trúc phân cấp để drill-down/roll-up.
        \newline \textit{VD:} Date: Day $\to$ Week $\to$ Month $\to$ Quarter $\to$ Year.
        
        \item[Q: Data Warehouse vs Data Mart?] $\rightarrow$ \textbf{DW:} Toàn doanh nghiệp, nhiều subject.
        \newline \textbf{Data Mart:} 1 bộ phận/chủ đề cụ thể (Sales DM, HR DM).
        
        \item[Q: Data Lake đặc điểm?] $\rightarrow$ Lưu \textbf{raw data}, mọi cấu trúc, \textbf{schema-on-read}.
        \newline \textit{Khác DW:} DW cần transform trước (schema-on-write).
        
        \item[Q: Data Lakehouse là gì?] $\rightarrow$ Kết hợp \textbf{flexibility của Lake + structure của Warehouse}.
        \newline \textit{Đặc điểm:} Quản lý metadata/index thống nhất, hỗ trợ cả structured và unstructured.
        
        \item[Q: OLTP vs OLAP?] $\rightarrow$ \textbf{OLTP:} Giao dịch hàng ngày (INSERT/UPDATE nhiều), dữ liệu hiện tại.
        \newline \textbf{OLAP:} Phân tích (SELECT phức tạp), dữ liệu lịch sử, read-heavy.
    \end{description}

    \subsection{Big Data Technologies}
    \begin{description}[leftmargin=*, font=\bfseries\color{red!70!black}, itemsep=4pt]
        \item[Q: 5V của Big Data?] $\rightarrow$ \textbf{Volume, Velocity, Variety, Veracity, Value}.
        \newline \textit{Ghi nhớ:} Lượng lớn, Nhanh, Đa dạng, Chất lượng, Giá trị.
        
        \item[Q: HDFS hoạt động thế nào?] $\rightarrow$ \textbf{NameNode:} Lưu metadata.
        \newline \textbf{DataNode:} Lưu data blocks (replication mặc định = 3).
        \newline \textit{Fault tolerance:} Nếu 1 node chết, dùng replica ở node khác.
        
        \item[Q: MapReduce hoạt động?] $\rightarrow$ \textbf{Map:} (key, value) $\to$ intermediate (key, list of values).
        \newline \textbf{Shuffle:} Group by key. \textbf{Reduce:} Aggregate từng group.
        \newline \textit{Lưu ý:} Dữ liệu trung gian ghi xuống \textbf{disk}.
        
        \item[Q: Spark khác Hadoop MapReduce?] $\rightarrow$ Spark dùng \textbf{RDD in-memory} (nhanh hơn 10-100x).
        \newline MapReduce ghi disk mỗi stage. Spark có thể chain operations.
        
        \item[Q: RDD trong Spark là gì?] $\rightarrow$ \textbf{Resilient Distributed Dataset} - tập dữ liệu phân tán, immutable, fault-tolerant.
        \newline \textit{Fault recovery:} Dùng \textbf{lineage} (ghi lại cách tính) để recompute.
        
        \item[Q: Batch vs Stream Processing?] $\rightarrow$ \textbf{Batch:} Xử lý lô lớn định kỳ (hourly/daily).
        \newline \textbf{Stream:} Xử lý real-time/near real-time (seconds).
        \newline \textit{VD Stream:} Fraud detection, IoT sensors, stock trading.
        
        \item[Q: Spark Streaming vs Kafka Streams?] $\rightarrow$ \textbf{Spark Streaming:} Micro-batch (giả lập stream).
        \newline \textbf{Kafka Streams:} True streaming (event-by-event).
        
        \item[Q: Checkpoint trong Spark Streaming?] $\rightarrow$ Lưu \textbf{RDD + metadata} xuống HDFS để recover (khôi phục) khi lỗi.
        
        \item[Q: Apache Hive là gì?] $\rightarrow$ \textbf{SQL-on-Hadoop}. Viết SQL, Hive compile thành MapReduce/Spark jobs.
        \newline \textit{Use case:} DW trên HDFS.
        
        \item[Q: CAP Theorem?] $\rightarrow$ Chỉ chọn được \textbf{2 trong 3}: Consistency, Availability, Partition Tolerance.
        \newline \textit{VD:} MongoDB (CP), Cassandra (AP).
        
        \item[Q: NoSQL models?] $\rightarrow$ \textbf{Key-Value} (Redis), \textbf{Document} (MongoDB), \textbf{Column} (Cassandra), \textbf{Graph} (Neo4j).
        
        \item[Q: BASE vs ACID?] $\rightarrow$ \textbf{BASE:} Basically Available, Soft state, Eventually consistent (NoSQL).
        \newline \textbf{ACID:} Atomicity, Consistency, Isolation, Durability (SQL).
        
        \item[Q: Master-Master vs Master-Slave?] $\rightarrow$ \textbf{M-M:} Cả hai node đều write được (high availability).
        \newline \textbf{M-S:} Master write, Slave read-only (simpler, consistency).
    \end{description}

    \subsection{Query Optimization}
    \begin{description}[leftmargin=*, font=\bfseries\color{red!70!black}, itemsep=4pt]
        \item[Q: Tại sao Optimizer chuyển CROSS JOIN thành JOIN?] $\rightarrow$ Để tránh tạo ra $|R| \times |S|$ dòng trung gian (rất tốn kém).
        \newline \textit{Bẫy:} Nghĩa DB "không hỗ trợ" Cross Join. DB hỗ trợ nhưng Optimizer tránh.
        
        \item[Q: Mục tiêu tối thượng của Query Optimization?] $\rightarrow$ Chọn plan có \textbf{chi phí ước tính thấp nhất} (Cost-based).
        \newline \textit{Bẫy:} "Tìm plan tốt nhất tuyệt đối". Thực tế là "đủ tốt" trong thời gian cho phép.
        
        \item[Q: Query Rewriting là gì?] $\rightarrow$ Biến đổi query thành dạng tương đương nhưng hiệu quả hơn.
        \newline \textit{VD:} \texttt{WHERE A=1 AND (B=2 OR B=3)} $\to$ \texttt{WHERE A=1 AND B IN (2,3)}.
        
        \item[Q: Subquery vs JOIN nào nhanh hơn?] $\rightarrow$ Thường \textbf{JOIN nhanh hơn} (optimizer có nhiều lựa chọn).
        \newline \textit{Lưu ý:} Correlated subquery (chạy N lần) rất chậm.
        
        \item[Q: Selectivity là gì?] $\rightarrow$ \textbf{Tỷ lệ dòng thỏa điều kiện} = $\frac{\text{matching rows}}{\text{total rows}}$.
        \newline \textit{Ứng dụng:} Ước tính kích thước kết quả trung gian, quyết định thứ tự JOIN.
        
        \item[Q: Index được dùng khi nào?] $\rightarrow$ Khi \textbf{selectivity thấp} (trả về ít dòng). Nếu trả về >15-20\% $\to$ Full Scan nhanh hơn.
        
        \item[Q: Partition Pruning là gì?] $\rightarrow$ Chỉ scan các partition liên quan, bỏ qua partition không thỏa điều kiện.
        \newline \textit{VD:} \texttt{WHERE date >= '2024-01-01'} $\to$ chỉ scan partition Q1-2024.
    \end{description}

    \subsection{Các Khái Niệm Khác}
    \begin{description}[leftmargin=*, font=\bfseries\color{red!70!black}, itemsep=4pt]
        \item[Q: Slowly Changing Dimension (SCD)?] $\rightarrow$ Xử lý dimension thay đổi theo thời gian.
        \newline \textbf{Type 1:} Overwrite (mất lịch sử).
        \newline \textbf{Type 2:} Thêm dòng mới (valid\_from, valid\_to, is\_active).
        \newline \textbf{Type 3:} Thêm cột lưu giá trị cũ.
        
        \item[Q: Factless Fact Table?] $\rightarrow$ Fact \textbf{không có measure}, chỉ ghi nhận sự kiện xảy ra.
        \newline \textit{VD:} Student-Class enrollment (chỉ cần biết ai học lớp nào, không có số đo).
        
        \item[Q: Surrogate Key là gì?] $\rightarrow$ Khóa \textbf{nhân tạo} (auto-increment, UUID) thay natural key.
        \newline \textit{Lợi ích:} Ổn định, đơn giản, hỗ trợ SCD Type 2.
        
        \item[Q: Junk Dimension?] $\rightarrow$ Gom các \textbf{low-cardinality flags/indicators} vào 1 dimension.
        \newline \textit{VD:} PaymentMethod, OrderType, ShipStatus $\to$ 1 bảng JunkDim.
        
        \item[Q: Degenerate Dimension?] $\rightarrow$ Dimension chỉ có \textbf{1 thuộc tính} (thường là ID), không tạo bảng riêng, để luôn trong Fact.
        \newline \textit{VD:} OrderID, InvoiceNumber trong Fact.
        
        \item[Q: Conformed Dimension?] $\rightarrow$ Dimension \textbf{dùng chung} cho nhiều Fact (đảm bảo consistency).
        \newline \textit{VD:} DateDim dùng cho SalesFact, InventoryFact, ShippingFact.
    \end{description}

\end{multicols}
\end{document}